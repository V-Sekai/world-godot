diff --git a/thirdparty/libdatachannel/include/rtc/candidate.hpp b/thirdparty/libdatachannel/include/rtc/candidate.hpp
index 88524851ab..c243a829c6 100644
--- a/thirdparty/libdatachannel/include/rtc/candidate.hpp
+++ b/thirdparty/libdatachannel/include/rtc/candidate.hpp
@@ -22,13 +22,13 @@ public:
 	enum class TransportType { Unknown, Udp, TcpActive, TcpPassive, TcpSo, TcpUnknown };
 
 	Candidate();
-	Candidate(string candidate);
-	Candidate(string candidate, string mid);
+	static RTC_WRAPPED(Candidate) create(string candidate);
+	static RTC_WRAPPED(Candidate) create(string candidate, string mid);
 
 	void hintMid(string mid);
-	void changeAddress(string addr);
-	void changeAddress(string addr, uint16_t port);
-	void changeAddress(string addr, string service);
+	RTC_WRAPPED(void) changeAddress(string addr);
+	RTC_WRAPPED(void) changeAddress(string addr, uint16_t port);
+	RTC_WRAPPED(void) changeAddress(string addr, string service);
 
 	enum class ResolveMode { Simple, Lookup };
 	bool resolve(ResolveMode mode = ResolveMode::Simple);
@@ -49,7 +49,7 @@ public:
 	optional<uint16_t> port() const;
 
 private:
-	void parse(string candidate);
+	RTC_WRAPPED(void) parse(string candidate);
 
 	string mFoundation;
 	uint32_t mComponent, mPriority;
diff --git a/thirdparty/libdatachannel/include/rtc/channel.hpp b/thirdparty/libdatachannel/include/rtc/channel.hpp
index 384279d76a..32e69d27aa 100644
--- a/thirdparty/libdatachannel/include/rtc/channel.hpp
+++ b/thirdparty/libdatachannel/include/rtc/channel.hpp
@@ -25,8 +25,8 @@ public:
 	virtual ~Channel();
 
 	virtual void close() = 0;
-	virtual bool send(message_variant data) = 0; // returns false if buffered
-	virtual bool send(const byte *data, size_t size) = 0;
+	virtual RTC_WRAPPED(bool) send(message_variant data) = 0; // returns false if buffered
+	virtual RTC_WRAPPED(bool) send(const byte *data, size_t size) = 0;
 
 	virtual bool isOpen() const = 0;
 	virtual bool isClosed() const = 0;
diff --git a/thirdparty/libdatachannel/include/rtc/common.hpp b/thirdparty/libdatachannel/include/rtc/common.hpp
index 08f981cb8a..f94d6756de 100644
--- a/thirdparty/libdatachannel/include/rtc/common.hpp
+++ b/thirdparty/libdatachannel/include/rtc/common.hpp
@@ -53,9 +53,139 @@
 #include <string_view>
 #include <variant>
 #include <vector>
+#include <tuple>
 
 namespace rtc {
 
+#ifdef RTC_USE_CPP_EXCEPTIONS
+
+#define RTC_WHAT what
+#define RTC_EXCEPTION std::exception
+#define RTC_RUNTIME_ERROR std::runtime_error
+#define RTC_LOGIC_ERROR std::logic_error
+#define RTC_INVALID_ARGUMENT std::invalid_argument
+#define RTC_OUT_OF_RANGE std::out_of_range
+
+#define RTC_THROW throw
+#define RTC_THROW_WITHIN(exception) throw exception
+#define RTC_BEGIN
+#define RTC_TRY try
+#define RTC_CATCH catch
+#define RTC_WRAPPED(T) T
+#define RTC_VOID
+#define RTC_RET return
+
+#define RTC_UNWRAP_EXPR(func) (func)
+#define RTC_CHECK_EXCEPTION
+#define RTC_RETHROW throw
+
+#define RTC_UNWRAP_CATCH(func) (func)
+#define RTC_UNWRAP_RETHROW(func) (func)
+#define RTC_UNWRAP_CATCH_DECL(typ, var, func) typ var = (func)
+#define RTC_UNWRAP_RETHROW_DECL(typ, var, func) typ var = (func)
+#define RTC_UNWRAP_CATCH_VAR(var, func) var = (func)
+#define RTC_UNWRAP_RETHROW_VAR(var, func) var = (func)
+#define RTC_UNWRAP_CATCH_ARG(wrap, func) wrap((func))
+#define RTC_UNWRAP_RETHROW_ARG(wrap, func) wrap((func))
+#define RTC_COMMA ,
+
+#else
+
+
+
+
+
+
+#define RTC_WHAT c_str
+#define RTC_EXCEPTION std::string
+#define RTC_RUNTIME_ERROR std::string
+#define RTC_LOGIC_ERROR std::string
+#define RTC_INVALID_ARGUMENT std::string
+#define RTC_OUT_OF_RANGE std::string
+
+#ifdef _MSC_VER
+#pragma warning(error : 4715)
+#pragma warning(error : 4716)
+#pragma warning(error : 4834)
+#endif
+
+class Void {};
+
+class [[nodiscard]] ExceptionCast {
+	RTC_EXCEPTION &&rtc_exception;
+
+public:
+	ExceptionCast(RTC_EXCEPTION &&rtc_exception) :
+			rtc_exception(std::move(rtc_exception)) {
+	}
+	RTC_EXCEPTION &&exception() {
+		return std::move(rtc_exception);
+	}
+};
+template <class T>
+struct [[nodiscard]] WrappedResult {
+	using ExT = RTC_EXCEPTION;
+	T rtc_value;
+	ExT rtc_exception;
+	bool rtc_is_exception;
+
+	WrappedResult(T &&value) :
+			rtc_value(std::move(value)), rtc_exception(ExT()), rtc_is_exception(false) {
+	}
+	WrappedResult(const T &value) :
+			rtc_value(value), rtc_exception(ExT()), rtc_is_exception(false) {
+	}
+	WrappedResult(ExceptionCast exception_cast) :
+			rtc_value(T()), rtc_exception(std::move(exception_cast.exception())), rtc_is_exception(true) {
+	}
+};
+
+template<>
+struct [[nodiscard]] WrappedResult<void> {
+	using ExT = RTC_EXCEPTION;
+	Void rtc_value;
+	ExT rtc_exception;
+	bool rtc_is_exception;
+
+	WrappedResult() :
+			rtc_value(Void()), rtc_exception(ExT()), rtc_is_exception(false) {
+	}
+	WrappedResult(Void) :
+			rtc_value(Void()), rtc_exception(ExT()), rtc_is_exception(false) {
+	}
+	WrappedResult(ExceptionCast exception_cast) :
+			rtc_value(Void()), rtc_exception(std::move(exception_cast.exception())), rtc_is_exception(true) {
+	}
+};
+
+#define RTC_WRAPPED_DEFAULT_CONSTRUCTABLE(clsname) friend struct WrappedResult<clsname>
+#define RTC_THROW return (::rtc::ExceptionCast)
+#define RTC_TRY RTC_EXCEPTION e; bool rtcexc_was_thrown;
+#define RTC_BEGIN RTC_EXCEPTION e; bool rtcexc_was_thrown
+#define RTC_CATCH(extype) while (false) rtcexc_catch_label: 
+#define RTC_WRAPPED(T) ::rtc::WrappedResult<T>
+#define RTC_THROW_WITHIN(exception) while ((e = (exception)), (rtcexc_was_thrown = true)) goto rtcexc_catch_label
+#define RTC_VOID ::rtc::WrappedResult<void>()
+#define RTC_RET return RTC_VOID
+
+#define RTC_UNWRAP_EXPR(func) ([&](){ auto [rtcexc_value, _rtcexc_e, _rtcexc_was_thrown] = (func); e = _rtcexc_e; rtcexc_was_thrown = rtcexc_was_thrown || _rtcexc_was_thrown; return rtcexc_value; })()
+#define RTC_CATCH_EXCEPTION while (rtcexc_was_thrown) goto rtcexc_catch_label
+#define RTC_RETHROW while (rtcexc_was_thrown) return e
+
+#define RTC_UNWRAP_CATCH(func) do { RTC_UNWRAP_EXPR(func); RTC_CATCH_EXCEPTION; } while (0)
+#define RTC_UNWRAP_RETHROW(func) do { RTC_UNWRAP_EXPR(func); RTC_RETHROW; } while (0)
+#define RTC_UNWRAP_CATCH_ARG(wrap, func) do { wrap(RTC_UNWRAP_EXPR(func)); RTC_CATCH_EXCEPTION; } while (0)
+#define RTC_UNWRAP_RETHROW_ARG(wrap, func) do { wrap(RTC_UNWRAP_EXPR(func)); RTC_RETHROW; } while (0)
+// Note: in a single-line if statement, this would fall out.
+// This should only be used for variable declarations which cannot occur in a single line.
+#define RTC_UNWRAP_CATCH_DECL(typ, var, func) typ var = RTC_UNWRAP_EXPR(func); RTC_CATCH_EXCEPTION;
+#define RTC_UNWRAP_RETHROW_DECL(typ, var, func) typ var = RTC_UNWRAP_EXPR(func); RTC_RETHROW;
+#define RTC_UNWRAP_CATCH_VAR(var, func) do { var = RTC_UNWRAP_EXPR(func); RTC_CATCH_EXCEPTION; } while (0)
+#define RTC_UNWRAP_RETHROW_VAR(var, func) do { var = RTC_UNWRAP_EXPR(func); RTC_RETHROW; } while (0)
+#define RTC_COMMA ,
+
+#endif
+
 using std::byte;
 using std::nullopt;
 using std::optional;
diff --git a/thirdparty/libdatachannel/include/rtc/datachannel.hpp b/thirdparty/libdatachannel/include/rtc/datachannel.hpp
index 0e83a97900..b866d7e659 100644
--- a/thirdparty/libdatachannel/include/rtc/datachannel.hpp
+++ b/thirdparty/libdatachannel/include/rtc/datachannel.hpp
@@ -40,8 +40,8 @@ public:
 	size_t maxMessageSize() const override;
 
 	void close(void) override;
-	bool send(message_variant data) override;
-	bool send(const byte *data, size_t size) override;
+	RTC_WRAPPED(bool) send(message_variant data) override;
+	RTC_WRAPPED(bool) send(const byte *data, size_t size) override;
 	template <typename Buffer> bool sendBuffer(const Buffer &buf);
 	template <typename Iterator> bool sendBuffer(Iterator first, Iterator last);
 
diff --git a/thirdparty/libdatachannel/include/rtc/description.hpp b/thirdparty/libdatachannel/include/rtc/description.hpp
index 22174a7824..ab8661b537 100644
--- a/thirdparty/libdatachannel/include/rtc/description.hpp
+++ b/thirdparty/libdatachannel/include/rtc/description.hpp
@@ -41,8 +41,12 @@ public:
 		Unknown = RTC_DIRECTION_UNKNOWN
 	};
 
-	Description(const string &sdp, Type type = Type::Unspec, Role role = Role::ActPass);
-	Description(const string &sdp, string typeString);
+private:
+	RTC_WRAPPED_DEFAULT_CONSTRUCTABLE(Description);
+	Description(Type type = Type::Unspec, Role role = Role::ActPass);
+public:
+	static RTC_WRAPPED(Description) create(const string &sdp, Type type = Type::Unspec, Role role = Role::ActPass);
+	static RTC_WRAPPED(Description) create(const string &sdp, string typeString);
 
 	Type type() const;
 	string typeString() const;
@@ -55,7 +59,7 @@ public:
 	bool ended() const;
 
 	void hintType(Type type);
-	void setFingerprint(string fingerprint);
+	RTC_WRAPPED(void) setFingerprint(string fingerprint);
 	void addIceOption(string option);
 	void removeIceOption(const string &option);
 
@@ -94,12 +98,16 @@ public:
 		void addRid(string rid);
 
 		struct RTC_CPP_EXPORT ExtMap {
-			static int parseId(string_view description);
+		private:
+			RTC_WRAPPED_DEFAULT_CONSTRUCTABLE(ExtMap);
+			ExtMap() {}
+		public:
+			static RTC_WRAPPED(int) parseId(string_view description);
 
 			ExtMap(int id, string uri, Direction direction = Direction::Unknown);
-			ExtMap(string_view description);
+			static RTC_WRAPPED(ExtMap) create(string_view description);
 
-			void setDescription(string_view description);
+			RTC_WRAPPED(void) setDescription(string_view description);
 
 			int id;
 			string uri;
@@ -108,7 +116,7 @@ public:
 		};
 
 		std::vector<int> extIds();
-		ExtMap *extMap(int id);
+		RTC_WRAPPED(ExtMap *) extMap(int id);
 		void addExtMap(ExtMap map);
 		void removeExtMap(int id);
 
@@ -116,9 +124,10 @@ public:
 		string generateSdp(string_view eol = "\r\n", string_view addr = "0.0.0.0",
 		                   uint16_t port = 9) const;
 
-		virtual void parseSdpLine(string_view line);
+		virtual RTC_WRAPPED(void) parseSdpLine(string_view line);
 
 	protected:
+		Entry() {}
 		Entry(const string &mline, string mid, Direction dir = Direction::Unknown);
 
 		virtual string generateSdpLines(string_view eol) const;
@@ -151,7 +160,7 @@ public:
 		optional<uint16_t> sctpPort() const;
 		optional<size_t> maxMessageSize() const;
 
-		virtual void parseSdpLine(string_view line) override;
+		virtual RTC_WRAPPED(void) parseSdpLine(string_view line) override;
 
 	private:
 		virtual string generateSdpLines(string_view eol) const override;
@@ -162,8 +171,11 @@ public:
 
 	// Media (non-data)
 	class RTC_CPP_EXPORT Media : public Entry {
-	public:
+		RTC_WRAPPED_DEFAULT_CONSTRUCTABLE(Media);
+		Media() {}
 		Media(const string &sdp);
+	public:
+		RTC_WRAPPED(Media) create(const string &sdp);
 		Media(const string &mline, string mid, Direction dir = Direction::SendOnly);
 		virtual ~Media() = default;
 
@@ -184,12 +196,16 @@ public:
 		void setBitrate(int bitrate);
 
 		struct RTC_CPP_EXPORT RtpMap {
-			static int parsePayloadType(string_view description);
+		private:
+			RTC_WRAPPED_DEFAULT_CONSTRUCTABLE(RtpMap);
+			RtpMap() {}
+		public:
+			static RTC_WRAPPED(int) parsePayloadType(string_view description);
 
 			explicit RtpMap(int payloadType);
-			RtpMap(string_view description);
+			static RTC_WRAPPED(RtpMap) create(string_view description);
 
-			void setDescription(string_view description);
+			RTC_WRAPPED(void) setDescription(string_view description);
 
 			void addFeedback(string fb);
 			void removeFeedback(const string &str);
@@ -207,14 +223,14 @@ public:
 
 		bool hasPayloadType(int payloadType) const;
 		std::vector<int> payloadTypes() const;
-		RtpMap *rtpMap(int payloadType);
+		RTC_WRAPPED(RtpMap *) rtpMap(int payloadType);
 		void addRtpMap(RtpMap map);
 		void removeRtpMap(int payloadType);
 		void removeFormat(const string &format);
 
-		void addRtxCodec(int payloadType, int origPayloadType, unsigned int clockRate);
+		RTC_WRAPPED(void) addRtxCodec(int payloadType, int origPayloadType, unsigned int clockRate);
 
-		virtual void parseSdpLine(string_view line) override;
+		virtual RTC_WRAPPED(void) parseSdpLine(string_view line) override;
 
 	private:
 		virtual string generateSdpLines(string_view eol) const override;
@@ -230,25 +246,25 @@ public:
 	public:
 		Audio(string mid = "audio", Direction dir = Direction::SendOnly);
 
-		void addAudioCodec(int payloadType, string codec, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addAudioCodec(int payloadType, string codec, optional<string> profile = std::nullopt);
 
-		void addOpusCodec(int payloadType, optional<string> profile = DEFAULT_OPUS_AUDIO_PROFILE);
-		void addPCMACodec(int payloadType, optional<string> profile = std::nullopt);
-		void addPCMUCodec(int payloadType, optional<string> profile = std::nullopt);
-		void addAacCodec(int payloadType, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addOpusCodec(int payloadType, optional<string> profile = DEFAULT_OPUS_AUDIO_PROFILE);
+		RTC_WRAPPED(void) addPCMACodec(int payloadType, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addPCMUCodec(int payloadType, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addAacCodec(int payloadType, optional<string> profile = std::nullopt);
 	};
 
 	class RTC_CPP_EXPORT Video : public Media {
 	public:
 		Video(string mid = "video", Direction dir = Direction::SendOnly);
 
-		void addVideoCodec(int payloadType, string codec, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addVideoCodec(int payloadType, string codec, optional<string> profile = std::nullopt);
 
-		void addH264Codec(int payloadType, optional<string> profile = DEFAULT_H264_VIDEO_PROFILE);
-		void addH265Codec(int payloadType, optional<string> profile = std::nullopt);
-		void addVP8Codec(int payloadType, optional<string> profile = std::nullopt);
-		void addVP9Codec(int payloadType, optional<string> profile = std::nullopt);
-		void addAV1Codec(int payloadType, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addH264Codec(int payloadType, optional<string> profile = DEFAULT_H264_VIDEO_PROFILE);
+		RTC_WRAPPED(void) addH265Codec(int payloadType, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addVP8Codec(int payloadType, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addVP9Codec(int payloadType, optional<string> profile = std::nullopt);
+		RTC_WRAPPED(void) addAV1Codec(int payloadType, optional<string> profile = std::nullopt);
 	};
 
 	bool hasApplication() const;
@@ -262,8 +278,9 @@ public:
 	int addAudio(string mid = "audio", Direction dir = Direction::SendOnly);
 	void clearMedia();
 
-	variant<Media *, Application *> media(unsigned int index);
-	variant<const Media *, const Application *> media(unsigned int index) const;
+	RTC_WRAPPED(variant<Media * RTC_COMMA Application *>) media(unsigned int index);
+	RTC_WRAPPED(variant<const Media * RTC_COMMA const Application *>) media(unsigned int index) const;
+
 	unsigned int mediaCount() const;
 
 	const Application *application() const;
diff --git a/thirdparty/libdatachannel/include/rtc/global.hpp b/thirdparty/libdatachannel/include/rtc/global.hpp
index a2038ed095..b4910e0994 100644
--- a/thirdparty/libdatachannel/include/rtc/global.hpp
+++ b/thirdparty/libdatachannel/include/rtc/global.hpp
@@ -50,7 +50,7 @@ struct SctpSettings {
 	optional<std::chrono::milliseconds> heartbeatInterval;
 };
 
-RTC_CPP_EXPORT void SetSctpSettings(SctpSettings s);
+RTC_CPP_EXPORT RTC_WRAPPED(void) SetSctpSettings(SctpSettings s);
 
 } // namespace rtc
 
diff --git a/thirdparty/libdatachannel/include/rtc/peerconnection.hpp b/thirdparty/libdatachannel/include/rtc/peerconnection.hpp
index 512bed3c83..ebcd41f989 100644
--- a/thirdparty/libdatachannel/include/rtc/peerconnection.hpp
+++ b/thirdparty/libdatachannel/include/rtc/peerconnection.hpp
@@ -87,18 +87,18 @@ public:
 	optional<string> localAddress() const;
 	optional<string> remoteAddress() const;
 	uint16_t maxDataChannelId() const;
-	bool getSelectedCandidatePair(Candidate *local, Candidate *remote);
+	RTC_WRAPPED(bool) getSelectedCandidatePair(Candidate *local, Candidate *remote);
 
-	void setLocalDescription(Description::Type type = Description::Type::Unspec);
-	void setRemoteDescription(Description description);
-	void addRemoteCandidate(Candidate candidate);
+	RTC_WRAPPED(void) setLocalDescription(Description::Type type = Description::Type::Unspec);
+	RTC_WRAPPED(void) setRemoteDescription(Description description);
+	RTC_WRAPPED(void) addRemoteCandidate(Candidate candidate);
 
 #if RTC_ENABLE_MEDIA
 	void setMediaHandler(shared_ptr<MediaHandler> handler);
 	shared_ptr<MediaHandler> getMediaHandler();
 #endif
 
-	[[nodiscard]] shared_ptr<DataChannel> createDataChannel(string label,
+	[[nodiscard]] RTC_WRAPPED(shared_ptr<DataChannel>) createDataChannel(string label,
 	                                                        DataChannelInit init = {});
 	void onDataChannel(std::function<void(std::shared_ptr<DataChannel> dataChannel)> callback);
 
diff --git a/thirdparty/libdatachannel/include/rtc/track.hpp b/thirdparty/libdatachannel/include/rtc/track.hpp
index a47ba5ae65..6f217b8d03 100644
--- a/thirdparty/libdatachannel/include/rtc/track.hpp
+++ b/thirdparty/libdatachannel/include/rtc/track.hpp
@@ -34,8 +34,8 @@ public:
 	void setDescription(Description::Media description);
 
 	void close(void) override;
-	bool send(message_variant data) override;
-	bool send(const byte *data, size_t size) override;
+	RTC_WRAPPED(bool) send(message_variant data) override;
+	RTC_WRAPPED(bool) send(const byte *data, size_t size) override;
 
 	bool isOpen(void) const override;
 	bool isClosed(void) const override;
diff --git a/thirdparty/libdatachannel/src/candidate.cpp b/thirdparty/libdatachannel/src/candidate.cpp
index cd88b0e108..d5ae9e69e4 100644
--- a/thirdparty/libdatachannel/src/candidate.cpp
+++ b/thirdparty/libdatachannel/src/candidate.cpp
@@ -57,19 +57,27 @@ Candidate::Candidate()
       mTransportString("unknown"), mType(Type::Unknown), mTransportType(TransportType::Unknown),
       mNode("0.0.0.0"), mService("9"), mFamily(Family::Unresolved), mPort(0) {}
 
-Candidate::Candidate(string candidate) : Candidate() {
-	if (!candidate.empty())
-		parse(std::move(candidate));
+RTC_WRAPPED(Candidate) Candidate::create(string candidate) {
+	RTC_BEGIN;
+	Candidate ret;
+	if (!candidate.empty()) {
+		RTC_UNWRAP_RETHROW(ret.parse(std::move(candidate)));
+	}
+	return ret;
 }
 
-Candidate::Candidate(string candidate, string mid) : Candidate() {
-	if (!candidate.empty())
-		parse(std::move(candidate));
+RTC_WRAPPED(Candidate) Candidate::create(string candidate, string mid) {
+	RTC_BEGIN;
+	Candidate ret;
+	if (!candidate.empty()) {
+		RTC_UNWRAP_RETHROW(ret.parse(std::move(candidate)));
+	}
 	if (!mid.empty())
-		mMid.emplace(std::move(mid));
+		ret.mMid.emplace(std::move(mid));
+	return ret;
 }
 
-void Candidate::parse(string candidate) {
+RTC_WRAPPED(void) Candidate::parse(string candidate) {
 	using TypeMap_t = std::unordered_map<string, Type>;
 	using TcpTypeMap_t = std::unordered_map<string, TransportType>;
 
@@ -93,8 +101,11 @@ void Candidate::parse(string candidate) {
 	std::istringstream iss(candidate);
 	string typ_;
 	if (!(iss >> mFoundation >> mComponent >> mTransportString >> mPriority &&
-	      iss >> mNode >> mService >> typ_ >> mTypeString && typ_ == "typ"))
-		throw std::invalid_argument("Invalid candidate format");
+	      iss >> mNode >> mService >> typ_ >> mTypeString && typ_ == "typ")) {
+		PLOG_ERROR << "Invalid candidate format";
+		mType = Type::Unknown;
+		RTC_RET;
+	}
 
 	std::getline(iss, mTail);
 	trim_begin(mTail);
@@ -123,6 +134,7 @@ void Candidate::parse(string candidate) {
 	} else {
 		mTransportType = TransportType::Unknown;
 	}
+	return RTC_VOID;
 }
 
 void Candidate::hintMid(string mid) {
@@ -130,13 +142,19 @@ void Candidate::hintMid(string mid) {
 		mMid.emplace(std::move(mid));
 }
 
-void Candidate::changeAddress(string addr) { changeAddress(std::move(addr), mService); }
+RTC_WRAPPED(void) Candidate::changeAddress(string addr) {
+	RTC_BEGIN;
+	RTC_UNWRAP_RETHROW(changeAddress(std::move(addr), mService));
+	return RTC_VOID;
+}
 
-void Candidate::changeAddress(string addr, uint16_t port) {
-	changeAddress(std::move(addr), std::to_string(port));
+RTC_WRAPPED(void) Candidate::changeAddress(string addr, uint16_t port) {
+	RTC_BEGIN;
+	RTC_UNWRAP_RETHROW(changeAddress(std::move(addr), std::to_string(port)));
+	return RTC_VOID;
 }
 
-void Candidate::changeAddress(string addr, string service) {
+RTC_WRAPPED(void) Candidate::changeAddress(string addr, string service) {
 	mNode = std::move(addr);
 	mService = std::move(service);
 
@@ -145,7 +163,8 @@ void Candidate::changeAddress(string addr, string service) {
 	mPort = 0;
 
 	if (!resolve(ResolveMode::Simple))
-		throw std::invalid_argument("Invalid candidate address \"" + addr + ":" + service + "\"");
+		RTC_THROW RTC_INVALID_ARGUMENT("Invalid candidate address \"" + addr + ":" + service + "\"");
+	RTC_RET;
 }
 
 bool Candidate::resolve(ResolveMode mode) {
@@ -177,9 +196,9 @@ bool Candidate::resolve(ResolveMode mode) {
 				if (getnameinfo(p->ai_addr, socklen_t(p->ai_addrlen), nodebuffer,
 				                MAX_NUMERICNODE_LEN, servbuffer, MAX_NUMERICSERV_LEN,
 				                NI_NUMERICHOST | NI_NUMERICSERV) == 0) {
-					try {
+					RTC_TRY {
 						mPort = uint16_t(std::stoul(servbuffer));
-					} catch (...) {
+					} RTC_CATCH (...) {
 						return false;
 					}
 					mAddress = nodebuffer;
diff --git a/thirdparty/libdatachannel/src/configuration.cpp b/thirdparty/libdatachannel/src/configuration.cpp
index fe28aef715..6b576bc146 100644
--- a/thirdparty/libdatachannel/src/configuration.cpp
+++ b/thirdparty/libdatachannel/src/configuration.cpp
@@ -7,10 +7,13 @@
  */
 
 #include "configuration.hpp"
+#include "rtp.hpp"
 
+#include "impl/internals.hpp"
 #include "impl/utils.hpp"
 
 #include <cassert>
+#include <cstdlib>
 #include <regex>
 
 namespace {
@@ -42,8 +45,10 @@ namespace utils = impl::utils;
 
 IceServer::IceServer(const string &url) {
 	std::vector<optional<string>> opt;
-	if (!parse_url(url, opt))
-		throw std::invalid_argument("Invalid ICE server URL: " + url);
+	if (!parse_url(url, opt)) {
+		PLOG_WARNING << "Invalid ICE server URL: " << url;
+		return;
+	}
 
 	string scheme = opt[2].value_or("stun");
 	relayType = RelayType::TurnUdp;
@@ -54,8 +59,10 @@ IceServer::IceServer(const string &url) {
 	else if (scheme == "turns" || scheme == "TURNS") {
 		type = Type::Turn;
 		relayType = RelayType::TurnTls;
-	} else
-		throw std::invalid_argument("Unknown ICE server protocol: " + scheme);
+	} else {
+		type = Type::Turn;
+		PLOG_WARNING << "Unknown ICE server protocol: " << scheme;
+	}
 
 	if (auto &query = opt[15]) {
 		if (query->find("transport=udp") != string::npos)
@@ -79,10 +86,11 @@ IceServer::IceServer(const string &url) {
 	}
 
 	string service = opt[12].value_or(relayType == RelayType::TurnTls ? "5349" : "3478");
-	try {
-		port = uint16_t(std::stoul(service));
-	} catch (...) {
-		throw std::invalid_argument("Invalid ICE server port in URL: " + service);
+	{
+		port = uint16_t(std::strtoul(service.c_str(), nullptr, 10));
+	}
+	if (port == 0) {
+		PLOG_WARNING << "Invalid ICE server port in URL: " << service;
 	}
 }
 
@@ -91,10 +99,11 @@ IceServer::IceServer(string hostname_, uint16_t port_)
 
 IceServer::IceServer(string hostname_, string service_)
     : hostname(std::move(hostname_)), type(Type::Stun) {
-	try {
-		port = uint16_t(std::stoul(service_));
-	} catch (...) {
-		throw std::invalid_argument("Invalid ICE server port: " + service_);
+	{
+		port = uint16_t(std::strtoul(service_.c_str(), nullptr, 10));
+	}
+	if (port == 0) {
+		PLOG_WARNING << "Invalid ICE server port: " << service_;
 	}
 }
 
@@ -107,25 +116,30 @@ IceServer::IceServer(string hostname_, string service_, string username_, string
                      RelayType relayType_)
     : hostname(std::move(hostname_)), type(Type::Turn), username(std::move(username_)),
       password(std::move(password_)), relayType(relayType_) {
-	try {
-		port = uint16_t(std::stoul(service_));
-	} catch (...) {
-		throw std::invalid_argument("Invalid ICE server port: " + service_);
+	{
+		port = uint16_t(std::strtoul(service_.c_str(), nullptr, 10));
+	}
+	if (port == 0) {
+		PLOG_WARNING << "Invalid ICE server port : " << service_;
 	}
 }
 
 ProxyServer::ProxyServer(const string &url) {
 	std::vector<optional<string>> opt;
-	if (!parse_url(url, opt))
-		throw std::invalid_argument("Invalid proxy server URL: " + url);
+	if (!parse_url(url, opt)) {
+		PLOG_WARNING << "Invalid proxy server URL: " << url;
+		return;
+	}
 
 	string scheme = opt[2].value_or("http");
 	if (scheme == "http" || scheme == "HTTP")
 		type = Type::Http;
 	else if (scheme == "socks5" || scheme == "SOCKS5")
 		type = Type::Socks5;
-	else
-		throw std::invalid_argument("Unknown proxy server protocol: " + scheme);
+	else {
+		type = Type::Http;
+		PLOG_WARNING << "Unknown proxy server protocol: " << scheme;
+	}
 
 	username = opt[6];
 	password = opt[8];
@@ -137,10 +151,11 @@ ProxyServer::ProxyServer(const string &url) {
 		hostname.pop_back();
 
 	string service = opt[12].value_or(type == Type::Socks5 ? "1080" : "3128");
-	try {
-		port = uint16_t(std::stoul(service));
-	} catch (...) {
-		throw std::invalid_argument("Invalid proxy server port in URL: " + service);
+	{
+		port = uint16_t(std::strtoul(service.c_str(), nullptr, 10));
+	}
+	if (port == 0) {
+		PLOG_WARNING << "Invalid proxy server port in URL: " << service;
 	}
 }
 
diff --git a/thirdparty/libdatachannel/src/datachannel.cpp b/thirdparty/libdatachannel/src/datachannel.cpp
index 80a151f33e..a80a5af175 100644
--- a/thirdparty/libdatachannel/src/datachannel.cpp
+++ b/thirdparty/libdatachannel/src/datachannel.cpp
@@ -46,11 +46,11 @@ bool DataChannel::isClosed(void) const { return impl()->isClosed(); }
 
 size_t DataChannel::maxMessageSize() const { return impl()->maxMessageSize(); }
 
-bool DataChannel::send(message_variant data) {
+RTC_WRAPPED(bool) DataChannel::send(message_variant data) {
 	return impl()->outgoing(make_message(std::move(data)));
 }
 
-bool DataChannel::send(const byte *data, size_t size) {
+RTC_WRAPPED(bool) DataChannel::send(const byte *data, size_t size) {
 	return impl()->outgoing(std::make_shared<Message>(data, data + size, Message::Binary));
 }
 
diff --git a/thirdparty/libdatachannel/src/description.cpp b/thirdparty/libdatachannel/src/description.cpp
index f153e6f0e3..b276357ecd 100644
--- a/thirdparty/libdatachannel/src/description.cpp
+++ b/thirdparty/libdatachannel/src/description.cpp
@@ -55,13 +55,14 @@ inline std::pair<string_view, string_view> parse_pair(string_view attr) {
 	return std::make_pair(std::move(key), std::move(value));
 }
 
-template <typename T> T to_integer(string_view s) {
+template <typename T> RTC_WRAPPED(T) to_integer(string_view s) {
 	const string str(s);
-	try {
-		return std::is_signed<T>::value ? T(std::stol(str)) : T(std::stoul(str));
-	} catch (...) {
-		throw std::invalid_argument("Invalid integer \"" + str + "\" in description");
+	char *p;
+	T ret = std::is_signed<T>::value ? T(strtol(str.c_str(), &p, 10)) : T(strtoul(str.c_str(), &p, 10));
+	if (*p == 0) {
+		RTC_THROW RTC_INVALID_ARGUMENT("Invalid integer \"" + str + "\" in description");
 	}
+	return ret;
 }
 
 inline bool is_sha256_fingerprint(string_view f) {
@@ -86,9 +87,13 @@ namespace rtc {
 
 namespace utils = impl::utils;
 
-Description::Description(const string &sdp, Type type, Role role)
+Description::Description(Type type, Role role)
     : mType(Type::Unspec), mRole(role) {
-	hintType(type);
+}
+RTC_WRAPPED(Description) Description::create(const string &sdp, Type type, Role role) {
+	RTC_BEGIN;
+	Description ret(type, role);
+	ret.hintType(type);
 
 	int index = -1;
 	shared_ptr<Entry> current;
@@ -101,11 +106,11 @@ Description::Description(const string &sdp, Type type, Role role)
 			continue;
 
 		if (match_prefix(line, "m=")) { // Media description line (aka m-line)
-			current = createEntry(line.substr(2), std::to_string(++index), Direction::Unknown);
+			current = ret.createEntry(line.substr(2), std::to_string(++index), Direction::Unknown);
 
 		} else if (match_prefix(line, "o=")) { // Origin line
 			std::istringstream origin(line.substr(2));
-			origin >> mUsername >> mSessionId;
+			origin >> ret.mUsername >> ret.mSessionId;
 
 		} else if (match_prefix(line, "a=")) { // Attribute line
 			string attr = line.substr(2);
@@ -113,53 +118,56 @@ Description::Description(const string &sdp, Type type, Role role)
 
 			if (key == "setup") {
 				if (value == "active")
-					mRole = Role::Active;
+					ret.mRole = Role::Active;
 				else if (value == "passive")
-					mRole = Role::Passive;
+					ret.mRole = Role::Passive;
 				else
-					mRole = Role::ActPass;
+					ret.mRole = Role::ActPass;
 
 			} else if (key == "fingerprint") {
 				if (match_prefix(value, "sha-256 ") || match_prefix(value, "SHA-256 ")) {
 					string fingerprint{value.substr(8)};
 					trim_begin(fingerprint);
-					setFingerprint(std::move(fingerprint));
+					RTC_UNWRAP_RETHROW(ret.setFingerprint(std::move(fingerprint)));
 				} else {
 					PLOG_WARNING << "Unknown SDP fingerprint format: " << value;
 				}
 			} else if (key == "ice-ufrag") {
-				mIceUfrag = value;
+				ret.mIceUfrag = value;
 			} else if (key == "ice-pwd") {
-				mIcePwd = value;
+				ret.mIcePwd = value;
 			} else if (key == "ice-options") {
-				mIceOptions = utils::explode(string(value), ',');
+				ret.mIceOptions = utils::explode(string(value), ',');
 			} else if (key == "candidate") {
-				addCandidate(Candidate(attr, bundleMid()));
+				RTC_UNWRAP_RETHROW_DECL(Candidate, tmp, Candidate::create(attr, ret.bundleMid()));
+				ret.addCandidate(tmp);
 			} else if (key == "end-of-candidates") {
-				mEnded = true;
+				ret.mEnded = true;
 			} else if (current) {
-				current->parseSdpLine(std::move(line));
+				RTC_UNWRAP_RETHROW(current->parseSdpLine(std::move(line)));
 			} else {
-				mAttributes.emplace_back(attr);
+				ret.mAttributes.emplace_back(attr);
 			}
 
 		} else if (current) {
-			current->parseSdpLine(std::move(line));
+			RTC_UNWRAP_RETHROW(current->parseSdpLine(std::move(line)));
 		}
 	}
 
-	if (mUsername.empty())
-		mUsername = "rtc";
+	if (ret.mUsername.empty())
+		ret.mUsername = "rtc";
 
-	if (mSessionId.empty()) {
+	if (ret.mSessionId.empty()) {
 		auto uniform = std::bind(std::uniform_int_distribution<uint32_t>(), utils::random_engine());
-		mSessionId = std::to_string(uniform());
+		ret.mSessionId = std::to_string(uniform());
 	}
+	return ret;
 }
 
-Description::Description(const string &sdp, string typeString)
-    : Description(sdp, !typeString.empty() ? stringToType(typeString) : Type::Unspec,
-                  Role::ActPass) {}
+RTC_WRAPPED(Description) Description::create(const string &sdp, string typeString) {
+    return create(sdp, !typeString.empty() ? stringToType(typeString) : Type::Unspec,
+                  Role::ActPass);
+}
 
 Description::Type Description::type() const { return mType; }
 
@@ -191,13 +199,14 @@ void Description::hintType(Type type) {
 		mType = type;
 }
 
-void Description::setFingerprint(string fingerprint) {
+RTC_WRAPPED(void) Description::setFingerprint(string fingerprint) {
 	if (!is_sha256_fingerprint(fingerprint))
-		throw std::invalid_argument("Invalid SHA256 fingerprint \"" + fingerprint + "\"");
+		RTC_THROW RTC_INVALID_ARGUMENT("Invalid SHA256 fingerprint \"" + fingerprint + "\"");
 
 	std::transform(fingerprint.begin(), fingerprint.end(), fingerprint.begin(),
 	               [](char c) { return char(std::toupper(c)); });
 	mFingerprint.emplace(std::move(fingerprint));
+	RTC_RET;
 }
 
 void Description::addIceOption(string option) {
@@ -459,44 +468,45 @@ void Description::clearMedia() {
 	mApplication.reset();
 }
 
-variant<Description::Media *, Description::Application *> Description::media(unsigned int index) {
+RTC_WRAPPED(variant<Description::Media * RTC_COMMA Description::Application *>)
+Description::media(unsigned int index) {
 	if (index >= mEntries.size())
-		throw std::out_of_range("Media index out of range");
+		RTC_THROW RTC_OUT_OF_RANGE("Media index out of range");
 
 	const auto &entry = mEntries[index];
 	if (entry == mApplication) {
 		auto result = dynamic_cast<Application *>(entry.get());
 		if (!result)
-			throw std::logic_error("Bad type of application in description");
+			RTC_THROW RTC_LOGIC_ERROR("Bad type of application in description");
 
 		return result;
 
 	} else {
 		auto result = dynamic_cast<Media *>(entry.get());
 		if (!result)
-			throw std::logic_error("Bad type of media in description");
+			RTC_THROW RTC_LOGIC_ERROR("Bad type of media in description");
 
 		return result;
 	}
 }
 
-variant<const Description::Media *, const Description::Application *>
+RTC_WRAPPED(variant<const Description::Media * RTC_COMMA const Description::Application *>)
 Description::media(unsigned int index) const {
 	if (index >= mEntries.size())
-		throw std::out_of_range("Media index out of range");
+		RTC_THROW RTC_OUT_OF_RANGE("Media index out of range");
 
 	const auto &entry = mEntries[index];
 	if (entry == mApplication) {
 		auto result = dynamic_cast<Application *>(entry.get());
 		if (!result)
-			throw std::logic_error("Bad type of application in description");
+			RTC_THROW RTC_LOGIC_ERROR("Bad type of application in description");
 
 		return result;
 
 	} else {
 		auto result = dynamic_cast<Media *>(entry.get());
 		if (!result)
-			throw std::logic_error("Bad type of media in description");
+			RTC_THROW RTC_LOGIC_ERROR("Bad type of media in description");
 
 		return result;
 	}
@@ -559,10 +569,10 @@ std::vector<int> Description::Entry::extIds() {
 	return result;
 }
 
-Description::Entry::ExtMap *Description::Entry::extMap(int id) {
+RTC_WRAPPED(Description::Entry::ExtMap *) Description::Entry::extMap(int id) {
 	auto it = mExtMaps.find(id);
 	if (it == mExtMaps.end())
-		throw std::invalid_argument("extmap not found");
+		RTC_THROW RTC_INVALID_ARGUMENT("extmap not found");
 
 	return &it->second;
 }
@@ -641,7 +651,8 @@ string Description::Entry::generateSdpLines(string_view eol) const {
 	return sdp.str();
 }
 
-void Description::Entry::parseSdpLine(string_view line) {
+RTC_WRAPPED(void) Description::Entry::parseSdpLine(string_view line) {
+	RTC_BEGIN;
 	if (match_prefix(line, "a=")) {
 		string_view attr = line.substr(2);
 		auto [key, value] = parse_pair(attr);
@@ -649,12 +660,13 @@ void Description::Entry::parseSdpLine(string_view line) {
 		if (key == "mid") {
 			mMid = value;
 		} else if (key == "extmap") {
-			auto id = Description::Media::ExtMap::parseId(value);
+			RTC_UNWRAP_RETHROW_DECL(int, id, Description::Media::ExtMap::parseId(value));
 			auto it = mExtMaps.find(id);
-			if (it == mExtMaps.end())
-				it = mExtMaps.insert(std::make_pair(id, Description::Media::ExtMap(value))).first;
-			else
-				it->second.setDescription(value);
+			if (it == mExtMaps.end()) {
+				RTC_UNWRAP_RETHROW_DECL(auto, tmp, Description::Media::ExtMap::create(value));
+				it = mExtMaps.insert(std::make_pair(id, tmp)).first;
+			} else
+				RTC_UNWRAP_RETHROW(it->second.setDescription(value));
 
 		} else if (attr == "sendonly")
 			mDirection = Direction::SendOnly;
@@ -673,9 +685,10 @@ void Description::Entry::parseSdpLine(string_view line) {
 			mAttributes.emplace_back(attr);
 		}
 	}
+	RTC_RET;
 }
 
-int Description::Entry::ExtMap::parseId(string_view description) {
+RTC_WRAPPED(int) Description::Entry::ExtMap::parseId(string_view description) {
 	size_t p = description.find(' ');
 	return to_integer<int>(description.substr(0, p));
 }
@@ -686,19 +699,26 @@ Description::Entry::ExtMap::ExtMap(int id, string uri, Direction direction) {
 	this->direction = direction;
 }
 
-Description::Entry::ExtMap::ExtMap(string_view description) { setDescription(description); }
+RTC_WRAPPED(Description::Entry::ExtMap) Description::Entry::ExtMap::create(string_view description) {
+	Description::Entry::ExtMap ret;
+	RTC_BEGIN;
+	RTC_UNWRAP_RETHROW(ret.setDescription(description));
+	return ret;
+}
 
-void Description::Entry::ExtMap::setDescription(string_view description) {
+RTC_WRAPPED(void)
+Description::Entry::ExtMap::setDescription(string_view description) {
+	RTC_BEGIN;
 	const size_t uriStart = description.find(' ');
 	if (uriStart == string::npos)
-		throw std::invalid_argument("Invalid description for extmap");
+		RTC_THROW RTC_INVALID_ARGUMENT("Invalid description for extmap");
 
 	const string_view idAndDirection = description.substr(0, uriStart);
 	const size_t idSplit = idAndDirection.find('/');
-	if (idSplit == string::npos) {
-		this->id = to_integer<int>(idAndDirection);
-	} else {
-		this->id = to_integer<int>(idAndDirection.substr(0, idSplit));
+	if (idSplit == string::npos)
+		RTC_UNWRAP_RETHROW_VAR(this->id, to_integer<int>(idAndDirection));
+	else {
+		RTC_UNWRAP_RETHROW_VAR(this->id, (to_integer<int>(idAndDirection.substr(0, idSplit))));
 
 		const string_view directionStr = idAndDirection.substr(idSplit + 1);
 		if (directionStr == "sendonly")
@@ -710,7 +730,7 @@ void Description::Entry::ExtMap::setDescription(string_view description) {
 		else if (directionStr == "inactive")
 			this->direction = Direction::Inactive;
 		else
-			throw std::invalid_argument("Invalid direction for extmap");
+			RTC_THROW RTC_INVALID_ARGUMENT("Invalid direction for extmap");
 	}
 
 	const string_view uriAndAttributes = description.substr(uriStart + 1);
@@ -722,6 +742,7 @@ void Description::Entry::ExtMap::setDescription(string_view description) {
 		this->uri = uriAndAttributes.substr(0, attributeSplit);
 		this->attributes = uriAndAttributes.substr(attributeSplit + 1);
 	}
+	RTC_RET;
 }
 
 void Description::Media::addSSRC(uint32_t ssrc, optional<string> name, optional<string> msid,
@@ -825,24 +846,32 @@ string Description::Application::generateSdpLines(string_view eol) const {
 	return sdp.str();
 }
 
-void Description::Application::parseSdpLine(string_view line) {
+RTC_WRAPPED(void) Description::Application::parseSdpLine(string_view line) {
+	RTC_BEGIN;
 	if (match_prefix(line, "a=")) {
 		string_view attr = line.substr(2);
 		auto [key, value] = parse_pair(attr);
 
 		if (key == "sctp-port") {
-			mSctpPort = to_integer<uint16_t>(value);
+			RTC_UNWRAP_RETHROW_VAR(mSctpPort, to_integer<uint16_t>(value));
 		} else if (key == "max-message-size") {
-			mMaxMessageSize = to_integer<size_t>(value);
+			RTC_UNWRAP_RETHROW_VAR(mMaxMessageSize, to_integer<size_t>(value));
 		} else {
-			Entry::parseSdpLine(line);
+			RTC_UNWRAP_RETHROW(Entry::parseSdpLine(line));
 		}
 	} else {
-		Entry::parseSdpLine(line);
+		RTC_UNWRAP_RETHROW(Entry::parseSdpLine(line));
 	}
+	RTC_RET;
+}
+
+Description::Media::Media(const string& sdp) :
+	Entry(sdp, "", Direction::Unknown) {
 }
 
-Description::Media::Media(const string &sdp) : Entry(sdp, "", Direction::Unknown) {
+RTC_WRAPPED(Description::Media) Description::Media::create(const string &sdp) {
+	RTC_BEGIN;
+	Media ret = sdp;
 	std::istringstream ss(sdp);
 	while (ss) {
 		string line;
@@ -851,11 +880,12 @@ Description::Media::Media(const string &sdp) : Entry(sdp, "", Direction::Unknown
 		if (line.empty())
 			continue;
 
-		parseSdpLine(line);
+		RTC_UNWRAP_RETHROW(ret.parseSdpLine(line));
 	}
 
-	if (mid().empty())
-		throw std::invalid_argument("Missing mid in media description");
+	if (ret.mid().empty())
+		PLOG_WARNING << "Missing mid in media description";
+	return ret;
 }
 
 Description::Media::Media(const string &mline, string mid, Direction dir)
@@ -929,10 +959,10 @@ std::vector<int> Description::Media::payloadTypes() const {
 	return result;
 }
 
-Description::Media::RtpMap *Description::Media::rtpMap(int payloadType) {
+RTC_WRAPPED(Description::Media::RtpMap *) Description::Media::rtpMap(int payloadType) {
 	auto it = mRtpMaps.find(payloadType);
 	if (it == mRtpMaps.end())
-		throw std::invalid_argument("rtpmap not found");
+		RTC_THROW RTC_INVALID_ARGUMENT("rtpmap not found");
 
 	return &it->second;
 }
@@ -968,10 +998,12 @@ void Description::Media::removeFormat(const string &format) {
 		removeRtpMap(pt);
 }
 
-void Description::Media::addRtxCodec(int payloadType, int origPayloadType, unsigned int clockRate) {
-	RtpMap rtp(std::to_string(payloadType) + " RTX/" + std::to_string(clockRate));
+RTC_WRAPPED(void) Description::Media::addRtxCodec(int payloadType, int origPayloadType, unsigned int clockRate) {
+	RTC_BEGIN;
+	RTC_UNWRAP_RETHROW_DECL(RtpMap, rtp, RtpMap::create(std::to_string(payloadType) + " RTX/" + std::to_string(clockRate)));
 	rtp.fmtps.emplace_back("apt=" + std::to_string(origPayloadType));
 	addRtpMap(rtp);
+	RTC_RET;
 }
 
 string Description::Media::generateSdpLines(string_view eol) const {
@@ -1002,22 +1034,24 @@ string Description::Media::generateSdpLines(string_view eol) const {
 	return sdp.str();
 }
 
-void Description::Media::parseSdpLine(string_view line) {
+RTC_WRAPPED(void) Description::Media::parseSdpLine(string_view line) {
+	RTC_BEGIN;
 	if (match_prefix(line, "a=")) {
 		string_view attr = line.substr(2);
 		auto [key, value] = parse_pair(attr);
 
 		if (key == "rtpmap") {
-			auto pt = Description::Media::RtpMap::parsePayloadType(value);
+			RTC_UNWRAP_RETHROW_DECL(auto, pt, Description::Media::RtpMap::parsePayloadType(value));
 			auto it = mRtpMaps.find(pt);
-			if (it == mRtpMaps.end())
-				it = mRtpMaps.insert(std::make_pair(pt, Description::Media::RtpMap(value))).first;
-			else
-				it->second.setDescription(value);
+			if (it == mRtpMaps.end()) {
+				RTC_UNWRAP_RETHROW_DECL(Description::Media::RtpMap, tmp, Description::Media::RtpMap::create(value));
+				it = mRtpMaps.insert(std::make_pair(pt, tmp)).first;
+			} else
+				RTC_UNWRAP_RETHROW(it->second.setDescription(value));
 
 		} else if (key == "rtcp-fb") {
 			size_t p = value.find(' ');
-			int pt = to_integer<int>(value.substr(0, p));
+			RTC_UNWRAP_RETHROW_DECL(int, pt, to_integer<int>(value.substr(0, p)));
 			auto it = mRtpMaps.find(pt);
 			if (it == mRtpMaps.end())
 				it = mRtpMaps.insert(std::make_pair(pt, Description::Media::RtpMap(pt))).first;
@@ -1026,7 +1060,7 @@ void Description::Media::parseSdpLine(string_view line) {
 
 		} else if (key == "fmtp") {
 			size_t p = value.find(' ');
-			int pt = to_integer<int>(value.substr(0, p));
+			RTC_UNWRAP_RETHROW_DECL(int, pt, to_integer<int>(value.substr(0, p)));
 			auto it = mRtpMaps.find(pt);
 			if (it == mRtpMaps.end())
 				it = mRtpMaps.insert(std::make_pair(pt, Description::Media::RtpMap(pt))).first;
@@ -1037,7 +1071,7 @@ void Description::Media::parseSdpLine(string_view line) {
 			// always added
 
 		} else if (key == "ssrc") {
-			auto ssrc = to_integer<uint32_t>(value);
+			RTC_UNWRAP_RETHROW_DECL(auto, ssrc, to_integer<uint32_t>(value));
 			if (!hasSSRC(ssrc))
 				mSsrcs.emplace_back(ssrc);
 
@@ -1049,14 +1083,15 @@ void Description::Media::parseSdpLine(string_view line) {
 			mAttributes.emplace_back(attr);
 
 		} else {
-			Entry::parseSdpLine(line);
+			RTC_UNWRAP_RETHROW(Entry::parseSdpLine(line));
 		}
 
 	} else if (match_prefix(line, "b=AS")) {
-		mBas = to_integer<int>(line.substr(line.find(':') + 1));
+		RTC_UNWRAP_RETHROW_VAR(mBas, to_integer<int>(line.substr(line.find(':') + 1)));
 	} else {
-		Entry::parseSdpLine(line);
+		RTC_UNWRAP_RETHROW(Entry::parseSdpLine(line));
 	}
+	RTC_RET;
 }
 
 Description::Media::RtpMap::RtpMap(int payloadType) {
@@ -1064,24 +1099,31 @@ Description::Media::RtpMap::RtpMap(int payloadType) {
 	this->clockRate = 0;
 }
 
-int Description::Media::RtpMap::parsePayloadType(string_view mline) {
+RTC_WRAPPED(Description::Media::RtpMap) Description::Media::RtpMap::create(string_view description) {
+	RTC_BEGIN;
+	RtpMap ret = RtpMap(0);
+	RTC_UNWRAP_RETHROW(ret.setDescription(description));
+	return ret;
+}
+
+
+RTC_WRAPPED(int) Description::Media::RtpMap::parsePayloadType(string_view mline) {
 	size_t p = mline.find(' ');
 	return to_integer<int>(mline.substr(0, p));
 }
 
-Description::Media::RtpMap::RtpMap(string_view description) { setDescription(description); }
-
-void Description::Media::RtpMap::setDescription(string_view description) {
+RTC_WRAPPED(void) Description::Media::RtpMap::setDescription(string_view description) {
+	RTC_BEGIN;
 	size_t p = description.find(' ');
 	if (p == string::npos)
-		throw std::invalid_argument("Invalid format description for rtpmap");
+		RTC_THROW RTC_INVALID_ARGUMENT("Invalid format description for rtpmap");
 
-	this->payloadType = to_integer<int>(description.substr(0, p));
+	RTC_UNWRAP_RETHROW_VAR(this->payloadType, to_integer<int>(description.substr(0, p)));
 
 	string_view line = description.substr(p + 1);
 	size_t spl = line.find('/');
 	if (spl == string::npos)
-		throw std::invalid_argument("Invalid format description for rtpmap");
+		RTC_THROW RTC_INVALID_ARGUMENT("Invalid format description for rtpmap");
 
 	this->format = line.substr(0, spl);
 
@@ -1091,11 +1133,12 @@ void Description::Media::RtpMap::setDescription(string_view description) {
 		spl = line.find(' ');
 	}
 	if (spl == string::npos)
-		this->clockRate = to_integer<int>(line);
+		RTC_UNWRAP_RETHROW_VAR(this->clockRate, to_integer<int>(line));
 	else {
-		this->clockRate = to_integer<int>(line.substr(0, spl));
+		RTC_UNWRAP_RETHROW_VAR(this->clockRate, (to_integer<int>(line.substr(0, spl))));
 		this->encParams = line.substr(spl + 1);
 	}
+	RTC_RET;
 }
 
 void Description::Media::RtpMap::addFeedback(string fb) {
@@ -1127,7 +1170,8 @@ void Description::Media::RtpMap::removeParameter(const string &str) {
 Description::Audio::Audio(string mid, Direction dir)
     : Media("audio 9 UDP/TLS/RTP/SAVPF", std::move(mid), dir) {}
 
-void Description::Audio::addAudioCodec(int payloadType, string codec, optional<string> profile) {
+RTC_WRAPPED(void) Description::Audio::addAudioCodec(int payloadType, string codec, optional<string> profile) {
+	RTC_BEGIN;
 	if (codec.find('/') == string::npos) {
 		if (codec == "PCMA" || codec == "PCMU")
 			codec += "/8000/1";
@@ -1135,42 +1179,44 @@ void Description::Audio::addAudioCodec(int payloadType, string codec, optional<s
 			codec += "/48000/2";
 	}
 
-	RtpMap map(std::to_string(payloadType) + ' ' + codec);
+	RTC_UNWRAP_RETHROW_DECL(RtpMap, map, RtpMap::create(std::to_string(payloadType) + ' ' + codec));
 
 	if (profile)
 		map.fmtps.emplace_back(*profile);
 
 	addRtpMap(map);
+	RTC_RET;
 }
 
-void Description::Audio::addOpusCodec(int payloadType, optional<string> profile) {
-	addAudioCodec(payloadType, "opus", profile);
+RTC_WRAPPED(void) Description::Audio::addOpusCodec(int payloadType, optional<string> profile) {
+	return addAudioCodec(payloadType, "opus", profile);
 }
 
-void Description::Audio::addPCMACodec(int payloadType, optional<string> profile) {
-	addAudioCodec(payloadType, "PCMA", profile);
+RTC_WRAPPED(void) Description::Audio::addPCMACodec(int payloadType, optional<string> profile) {
+	return addAudioCodec(payloadType, "PCMA", profile);
 }
 
-void Description::Audio::addPCMUCodec(int payloadType, optional<string> profile) {
-	addAudioCodec(payloadType, "PCMU", profile);
+RTC_WRAPPED(void) Description::Audio::addPCMUCodec(int payloadType, optional<string> profile) {
+	return addAudioCodec(payloadType, "PCMU", profile);
 }
 
-void Description::Audio::addAacCodec(int payloadType, optional<string> profile) {
+RTC_WRAPPED(void) Description::Audio::addAacCodec(int payloadType, optional<string> profile) {
 	if (profile) {
-		addAudioCodec(payloadType, "MP4A-LATM", profile);
+		return addAudioCodec(payloadType, "MP4A-LATM", profile);
 	} else {
-		addAudioCodec(payloadType, "MP4A-LATM", "cpresent=1");
+		return addAudioCodec(payloadType, "MP4A-LATM", "cpresent=1");
 	}
 }
 
 Description::Video::Video(string mid, Direction dir)
     : Media("video 9 UDP/TLS/RTP/SAVPF", std::move(mid), dir) {}
 
-void Description::Video::addVideoCodec(int payloadType, string codec, optional<string> profile) {
+RTC_WRAPPED(void) Description::Video::addVideoCodec(int payloadType, string codec, optional<string> profile) {
+	RTC_BEGIN;
 	if (codec.find('/') == string::npos)
 		codec += "/90000";
 
-	RtpMap map(std::to_string(payloadType) + ' ' + codec);
+	RTC_UNWRAP_RETHROW_DECL(RtpMap, map, RtpMap::create(std::to_string(payloadType) + ' ' + codec));
 
 	map.addFeedback("nack");
 	map.addFeedback("nack pli");
@@ -1194,26 +1240,27 @@ void Description::Video::addVideoCodec(int payloadType, string codec, optional<s
 	// // TODO rtx-time is how long can a request be stashed for before needing to resend it.
 	// Needs to be parameterized rtx.addAttribute("apt=" + std::to_string(payloadType) +
 	// ";rtx-time=3000"); addFormat(rtx);
+	RTC_RET;
 }
 
-void Description::Video::addH264Codec(int payloadType, optional<string> profile) {
-	addVideoCodec(payloadType, "H264", profile);
+RTC_WRAPPED(void) Description::Video::addH264Codec(int payloadType, optional<string> profile) {
+	return addVideoCodec(payloadType, "H264", profile);
 }
 
-void Description::Video::addH265Codec(int payloadType, optional<string> profile) {
-	addVideoCodec(payloadType, "H265", profile);
+RTC_WRAPPED(void) Description::Video::addH265Codec(int payloadType, optional<string> profile) {
+	return addVideoCodec(payloadType, "H265", profile);
 }
 
-void Description::Video::addVP8Codec(int payloadType, optional<string> profile) {
-	addVideoCodec(payloadType, "VP8", profile);
+RTC_WRAPPED(void) Description::Video::addVP8Codec(int payloadType, optional<string> profile) {
+	return addVideoCodec(payloadType, "VP8", profile);
 }
 
-void Description::Video::addVP9Codec(int payloadType, optional<string> profile) {
-	addVideoCodec(payloadType, "VP9", profile);
+RTC_WRAPPED(void) Description::Video::addVP9Codec(int payloadType, optional<string> profile) {
+	return addVideoCodec(payloadType, "VP9", profile);
 }
 
-void Description::Video::addAV1Codec(int payloadType, optional<string> profile) {
-	addVideoCodec(payloadType, "AV1", profile);
+RTC_WRAPPED(void) Description::Video::addAV1Codec(int payloadType, optional<string> profile) {
+	return addVideoCodec(payloadType, "AV1", profile);
 }
 
 Description::Type Description::stringToType(const string &typeString) {
diff --git a/thirdparty/libdatachannel/src/exception_wrapper_godot.cpp b/thirdparty/libdatachannel/src/exception_wrapper_godot.cpp
index a9e6d0151e..1c8c366b36 100644
--- a/thirdparty/libdatachannel/src/exception_wrapper_godot.cpp
+++ b/thirdparty/libdatachannel/src/exception_wrapper_godot.cpp
@@ -1,78 +1,95 @@
 #include "rtc/rtc.hpp"
 #include "rtc/exception_wrapper_godot.hpp"
 
-void LibDataChannelExceptionWrapper::close_data_channel(std::shared_ptr<rtc::DataChannel> p_channel) try {
-	if (p_channel) {
-		p_channel->close();
+void LibDataChannelExceptionWrapper::close_data_channel(std::shared_ptr<rtc::DataChannel> p_channel) {
+	RTC_TRY {
+		if (p_channel) {
+			p_channel->close();
+		}
+	} RTC_CATCH (...) {
 	}
-} catch (...) {
 }
 
 
-void LibDataChannelExceptionWrapper::close_peer_connection(std::shared_ptr<rtc::PeerConnection> p_peer_connection) try {
+void LibDataChannelExceptionWrapper::close_peer_connection(std::shared_ptr<rtc::PeerConnection> p_peer_connection) {
+RTC_TRY {
 	if (p_peer_connection) {
 		p_peer_connection->close();
 	}
-} catch (...) {
+} RTC_CATCH (...) {
+}
 }
 
 
-bool LibDataChannelExceptionWrapper::put_packet(std::shared_ptr<rtc::DataChannel> p_channel, const uint8_t *p_buffer, int32_t p_len, bool p_is_text, std::string &r_error) try {
+bool LibDataChannelExceptionWrapper::put_packet(std::shared_ptr<rtc::DataChannel> p_channel, const uint8_t *p_buffer, int32_t p_len, bool p_is_text, std::string &r_error) {
+RTC_TRY {
 	if (p_is_text) {
 		std::string str((const char *)p_buffer, (size_t)p_len);
-		p_channel->send(str);
+		RTC_UNWRAP_CATCH(p_channel->send(str));
 	} else {
-		p_channel->send(reinterpret_cast<const std::byte *>(p_buffer), p_len);
+		RTC_UNWRAP_CATCH(p_channel->send(reinterpret_cast<const std::byte *>(p_buffer), p_len));
 	}
 	return true;
-} catch (const std::exception &e) {
-	r_error = e.what();
+} RTC_CATCH (const RTC_EXCEPTION &e) {
+	r_error = e.RTC_WHAT();
 	return false;
 }
+}
 
 
-std::shared_ptr<rtc::DataChannel> LibDataChannelExceptionWrapper::create_data_channel(std::shared_ptr<rtc::PeerConnection> p_peer_connection, const char *p_label, rtc::DataChannelInit p_config, std::string &r_error) try {
-	return p_peer_connection->createDataChannel(p_label, p_config);
-} catch (const std::exception &e) {
-	r_error = e.what();
+std::shared_ptr<rtc::DataChannel> LibDataChannelExceptionWrapper::create_data_channel(std::shared_ptr<rtc::PeerConnection> p_peer_connection, const char *p_label, rtc::DataChannelInit p_config, std::string &r_error) {
+RTC_TRY {
+	RTC_UNWRAP_CATCH_DECL(std::shared_ptr<rtc::DataChannel>, ret, p_peer_connection->createDataChannel(p_label, p_config));
+	return ret;
+} RTC_CATCH (const RTC_EXCEPTION &e) {
+	r_error = e.RTC_WHAT();
 	return std::shared_ptr<rtc::DataChannel>();
 }
+}
 
-std::shared_ptr<rtc::PeerConnection> LibDataChannelExceptionWrapper::create_peer_connection(const rtc::Configuration &p_config, std::string &r_error) try {
+std::shared_ptr<rtc::PeerConnection> LibDataChannelExceptionWrapper::create_peer_connection(const rtc::Configuration &p_config, std::string &r_error) {
+RTC_TRY {
 	return std::make_shared<rtc::PeerConnection>(p_config);
-} catch (const std::exception &e) {
-	r_error = e.what();
+} RTC_CATCH (const RTC_EXCEPTION &e) {
+	r_error = e.RTC_WHAT();
 	return std::shared_ptr<rtc::PeerConnection>();
 }
+}
 
-bool LibDataChannelExceptionWrapper::create_offer(std::shared_ptr<rtc::PeerConnection> p_peer_connection, std::string &r_error) try {
-	p_peer_connection->setLocalDescription(rtc::Description::Type::Offer);
+bool LibDataChannelExceptionWrapper::create_offer(std::shared_ptr<rtc::PeerConnection> p_peer_connection, std::string &r_error) {
+RTC_TRY {
+	RTC_UNWRAP_CATCH(p_peer_connection->setLocalDescription(rtc::Description::Type::Offer));
 	return true;
-} catch (const std::exception &e) {
-	r_error = e.what();
+} RTC_CATCH (const RTC_EXCEPTION &e) {
+	r_error = e.RTC_WHAT();
 	return false;
 }
+}
 
-bool LibDataChannelExceptionWrapper::set_remote_description(std::shared_ptr<rtc::PeerConnection> p_peer_connection, const char *p_type, const char *p_sdp, std::string &r_error) try {
+bool LibDataChannelExceptionWrapper::set_remote_description(std::shared_ptr<rtc::PeerConnection> p_peer_connection, const char *p_type, const char *p_sdp, std::string &r_error) {
+RTC_TRY {
 	std::string sdp(p_sdp);
 	std::string type(p_type);
-	rtc::Description desc(sdp, type);
-	p_peer_connection->setRemoteDescription(desc);
+	RTC_UNWRAP_CATCH_DECL(rtc::Description, desc, rtc::Description::create(sdp, type));
+	RTC_UNWRAP_CATCH(p_peer_connection->setRemoteDescription(desc));
 	// Automatically create the answer.
 	if (type == "offer") {
-		p_peer_connection->setLocalDescription(rtc::Description::Type::Answer);
+		RTC_UNWRAP_CATCH(p_peer_connection->setLocalDescription(rtc::Description::Type::Answer));
 	}
 	return true;
-} catch (const std::exception &e) {
-	r_error = e.what();
+} RTC_CATCH (const RTC_EXCEPTION &e) {
+	r_error = e.RTC_WHAT();
 	return false;
 }
+}
 
-bool LibDataChannelExceptionWrapper::add_ice_candidate(std::shared_ptr<rtc::PeerConnection> p_peer_connection, const char *p_sdp_mid_name, const char *p_sdp_name, std::string &r_error) try {
-	rtc::Candidate candidate(p_sdp_name, p_sdp_mid_name);
-	p_peer_connection->addRemoteCandidate(candidate);
+bool LibDataChannelExceptionWrapper::add_ice_candidate(std::shared_ptr<rtc::PeerConnection> p_peer_connection, const char *p_sdp_mid_name, const char *p_sdp_name, std::string &r_error) {
+RTC_TRY {
+	RTC_UNWRAP_CATCH_DECL(rtc::Candidate, candidate, rtc::Candidate::create(p_sdp_name, p_sdp_mid_name));
+	RTC_UNWRAP_CATCH(p_peer_connection->addRemoteCandidate(candidate));
 	return true;
-} catch (const std::exception &e) {
-	r_error = e.what();
+} RTC_CATCH (const RTC_EXCEPTION &e) {
+	r_error = e.RTC_WHAT();
 	return false;
 }
+}
diff --git a/thirdparty/libdatachannel/src/global.cpp b/thirdparty/libdatachannel/src/global.cpp
index 747dd217a2..18b129dde7 100644
--- a/thirdparty/libdatachannel/src/global.cpp
+++ b/thirdparty/libdatachannel/src/global.cpp
@@ -97,7 +97,9 @@ void InitLogger(LogLevel level, LogCallback callback) {
 void Preload() { impl::Init::Instance().preload(); }
 std::shared_future<void> Cleanup() { return impl::Init::Instance().cleanup(); }
 
-void SetSctpSettings(SctpSettings s) { impl::Init::Instance().setSctpSettings(std::move(s)); }
+RTC_WRAPPED(void) SetSctpSettings(SctpSettings s) {
+	return impl::Init::Instance().setSctpSettings(std::move(s));
+}
 
 } // namespace rtc
 
diff --git a/thirdparty/libdatachannel/src/impl/certificate.cpp b/thirdparty/libdatachannel/src/impl/certificate.cpp
index eb4c419c86..cd8b715183 100644
--- a/thirdparty/libdatachannel/src/impl/certificate.cpp
+++ b/thirdparty/libdatachannel/src/impl/certificate.cpp
@@ -48,7 +48,7 @@ Certificate Certificate::FromFile(const string &crt_pem_file, const string &key_
 	return Certificate(std::move(creds));
 }
 
-Certificate Certificate::Generate(CertificateType type, const string &commonName) {
+RTC_WRAPPED(Certificate) Certificate::Generate(CertificateType type, const string &commonName) {
 	PLOG_DEBUG << "Generating certificate (GnuTLS)";
 
 	using namespace gnutls;
@@ -75,7 +75,7 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 		break;
 	}
 	default:
-		throw std::invalid_argument("Unknown certificate type");
+		RTC_THROW RTC_INVALID_ARGUMENT("Unknown certificate type");
 	}
 
 	using namespace std::chrono;
@@ -153,7 +153,7 @@ string make_fingerprint(mbedtls_x509_crt *crt) {
 	uint8_t buffer[size];
 	std::stringstream fingerprint;
 
-	mbedtls::check(
+	(void)mbedtls::check(
 	    mbedtls_sha256(crt->raw.p, crt->raw.len, reinterpret_cast<unsigned char *>(buffer), 0),
 	    "Failed to generate certificate fingerprint");
 
@@ -170,40 +170,42 @@ string make_fingerprint(mbedtls_x509_crt *crt) {
 Certificate::Certificate(shared_ptr<mbedtls_x509_crt> crt, shared_ptr<mbedtls_pk_context> pk)
     : mCrt(crt), mPk(pk), mFingerprint(make_fingerprint(crt.get())) {}
 
-Certificate Certificate::FromString(string crt_pem, string key_pem) {
+RTC_WRAPPED(Certificate) Certificate::FromString(string crt_pem, string key_pem) {
+	RTC_BEGIN;
 	PLOG_DEBUG << "Importing certificate from PEM string (MbedTLS)";
 
 	auto crt = mbedtls::new_x509_crt();
 	auto pk = mbedtls::new_pk_context();
 
-	mbedtls::check(mbedtls_x509_crt_parse(crt.get(),
+	RTC_UNWRAP_RETHROW(mbedtls::check(mbedtls_x509_crt_parse(crt.get(),
 	                                      reinterpret_cast<const unsigned char *>(crt_pem.c_str()),
 	                                      crt_pem.length()),
-	               "Failed to parse certificate");
-	mbedtls::check(mbedtls_pk_parse_key(pk.get(),
+	               "Failed to parse certificate"));
+	RTC_UNWRAP_RETHROW(mbedtls::check(mbedtls_pk_parse_key(pk.get(),
 	                                    reinterpret_cast<const unsigned char *>(key_pem.c_str()),
 	                                    key_pem.size(), NULL, 0, NULL, 0),
-	               "Failed to parse key");
+	               "Failed to parse key"));
 
 	return Certificate(std::move(crt), std::move(pk));
 }
 
-Certificate Certificate::FromFile(const string &crt_pem_file, const string &key_pem_file,
+RTC_WRAPPED(Certificate) Certificate::FromFile(const string &crt_pem_file, const string &key_pem_file,
                                   const string &pass) {
+	RTC_BEGIN;
 	PLOG_DEBUG << "Importing certificate from PEM file (MbedTLS): " << crt_pem_file;
 
 	auto crt = mbedtls::new_x509_crt();
 	auto pk = mbedtls::new_pk_context();
 
-	mbedtls::check(mbedtls_x509_crt_parse_file(crt.get(), crt_pem_file.c_str()),
-	               "Failed to parse certificate");
-	mbedtls::check(mbedtls_pk_parse_keyfile(pk.get(), key_pem_file.c_str(), pass.c_str(), 0, NULL),
-	               "Failed to parse key");
+	RTC_UNWRAP_RETHROW(mbedtls::check(mbedtls_x509_crt_parse_file(crt.get(), crt_pem_file.c_str()),
+	               "Failed to parse certificate"));
+	RTC_UNWRAP_RETHROW(mbedtls::check(mbedtls_pk_parse_keyfile(pk.get(), key_pem_file.c_str(), pass.c_str(), 0, NULL),
+	               "Failed to parse key"));
 
 	return Certificate(std::move(crt), std::move(pk));
 }
 
-Certificate Certificate::Generate(CertificateType type, const string &commonName) {
+RTC_WRAPPED(Certificate) Certificate::Generate(CertificateType type, const string &commonName) {
 	PLOG_DEBUG << "Generating certificate (MbedTLS)";
 
 	mbedtls_entropy_context entropy;
@@ -219,10 +221,10 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 	mbedtls_x509write_crt_init(&wcrt);
 	mbedtls_mpi_init(&serial);
 
-	try {
-		mbedtls::check(mbedtls_ctr_drbg_seed(
+	RTC_TRY {
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_ctr_drbg_seed(
 		    &drbg, mbedtls_entropy_func, &entropy,
-		    reinterpret_cast<const unsigned char *>(commonName.data()), commonName.size()));
+		    reinterpret_cast<const unsigned char *>(commonName.data()), commonName.size())));
 
 		switch (type) {
 		// RFC 8827 WebRTC Security Architecture 6.5. Communications Security
@@ -231,47 +233,47 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 		// See https://www.rfc-editor.org/rfc/rfc8827.html#section-6.5
 		case CertificateType::Default:
 		case CertificateType::Ecdsa: {
-			mbedtls::check(mbedtls_pk_setup(pk.get(), mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY)));
-			mbedtls::check(mbedtls_ecp_gen_key(MBEDTLS_ECP_DP_SECP256R1, mbedtls_pk_ec(*pk.get()),
+			RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_pk_setup(pk.get(), mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY))));
+			RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_ecp_gen_key(MBEDTLS_ECP_DP_SECP256R1, mbedtls_pk_ec(*pk.get()),
 			                                   mbedtls_ctr_drbg_random, &drbg),
-			               "Unable to generate ECDSA P-256 key pair");
+			               "Unable to generate ECDSA P-256 key pair"));
 			break;
 		}
 		case CertificateType::Rsa: {
 			const unsigned int nbits = 2048;
 			const int exponent = 65537;
 
-			mbedtls::check(mbedtls_pk_setup(pk.get(), mbedtls_pk_info_from_type(MBEDTLS_PK_RSA)));
-			mbedtls::check(mbedtls_rsa_gen_key(mbedtls_pk_rsa(*pk.get()), mbedtls_ctr_drbg_random,
+			RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_pk_setup(pk.get(), mbedtls_pk_info_from_type(MBEDTLS_PK_RSA))));
+			RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_rsa_gen_key(mbedtls_pk_rsa(*pk.get()), mbedtls_ctr_drbg_random,
 			                                   &drbg, nbits, exponent),
-			               "Unable to generate RSA key pair");
+			               "Unable to generate RSA key pair"));
 			break;
 		}
 		default:
-			throw std::invalid_argument("Unknown certificate type");
+			RTC_THROW_WITHIN(RTC_INVALID_ARGUMENT("Unknown certificate type"));
 		}
 
 		auto now = std::chrono::system_clock::now();
-		string notBefore = mbedtls::format_time(now - std::chrono::hours(1));
-		string notAfter = mbedtls::format_time(now + std::chrono::hours(24 * 365));
+		RTC_UNWRAP_CATCH_DECL(string, notBefore, mbedtls::format_time(now - std::chrono::hours(1)));
+		RTC_UNWRAP_CATCH_DECL(string, notAfter, mbedtls::format_time(now + std::chrono::hours(24 * 365)));
 
 		const size_t serialBufferSize = 16;
 		unsigned char serialBuffer[serialBufferSize];
-		mbedtls::check(mbedtls_ctr_drbg_random(&drbg, serialBuffer, serialBufferSize),
-		               "Failed to generate certificate");
-		mbedtls::check(mbedtls_mpi_read_binary(&serial, serialBuffer, serialBufferSize),
-		               "Failed to generate certificate");
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_ctr_drbg_random(&drbg, serialBuffer, serialBufferSize),
+		               "Failed to generate certificate"));
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_mpi_read_binary(&serial, serialBuffer, serialBufferSize),
+		               "Failed to generate certificate"));
 
 		std::string name = std::string("O=" + commonName + ",CN=" + commonName);
-		mbedtls::check(mbedtls_x509write_crt_set_serial_raw(&wcrt, rand_serial, sizeof(rand_serial)),
-		               "Failed to generate certificate");
-		mbedtls::check(mbedtls_x509write_crt_set_subject_name(&wcrt, name.c_str()),
-		               "Failed to generate certificate");
-		mbedtls::check(mbedtls_x509write_crt_set_issuer_name(&wcrt, name.c_str()),
-		               "Failed to generate certificate");
-		mbedtls::check(
+
+		uint8_t rand_serial[20];
+		mbedtls_ctr_drbg_random(&ctr_drbg, rand_serial, sizeof(rand_serial));
+
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_x509write_crt_set_serial_raw(&wcrt, &serial),
+		               "Failed to generate certificate"));
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_x509write_crt_set_subject_name(&wcrt, name.c_str()),
+		               "Failed to generate certificate"));
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_x509write_crt_set_issuer_name(&wcrt, name.c_str()),
+		               "Failed to generate certificate"));
+		RTC_UNWRAP_CATCH(mbedtls::check(
 		    mbedtls_x509write_crt_set_validity(&wcrt, notBefore.c_str(), notAfter.c_str()),
-		    "Failed to generate certificate");
+		    "Failed to generate certificate"));
 
 		mbedtls_x509write_crt_set_version(&wcrt, MBEDTLS_X509_CRT_VERSION_3);
 		mbedtls_x509write_crt_set_subject_key(&wcrt, pk.get());
@@ -285,19 +287,19 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 		auto certificateLen = mbedtls_x509write_crt_der(
 		    &wcrt, certificateBuffer, certificateBufferSize, mbedtls_ctr_drbg_random, &drbg);
 		if (certificateLen <= 0) {
-			throw std::runtime_error("Certificate generation failed");
+			RTC_THROW_WITHIN(RTC_RUNTIME_ERROR("Certificate generation failed"));
 		}
 
-		mbedtls::check(mbedtls_x509_crt_parse_der(
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_x509_crt_parse_der(
 		                   crt.get(), (certificateBuffer + certificateBufferSize - certificateLen),
 		                   certificateLen),
-		               "Failed to generate certificate");
-	} catch (...) {
+		               "Failed to generate certificate"));
+	} RTC_CATCH (...) {
 		mbedtls_entropy_free(&entropy);
 		mbedtls_ctr_drbg_free(&drbg);
 		mbedtls_x509write_crt_free(&wcrt);
 		mbedtls_mpi_free(&serial);
-		throw;
+		RTC_RETHROW;
 	}
 
 	mbedtls_entropy_free(&entropy);
@@ -328,7 +330,7 @@ int dummy_pass_cb(char *buf, int size, int /*rwflag*/, void *u) {
 
 } // namespace
 
-Certificate Certificate::FromString(string crt_pem, string key_pem) {
+RTC_WRAPPED(Certificate) Certificate::FromString(string crt_pem, string key_pem) {
 	PLOG_DEBUG << "Importing certificate from PEM string (OpenSSL)";
 
 	BIO *bio = BIO_new(BIO_s_mem());
@@ -336,7 +338,7 @@ Certificate Certificate::FromString(string crt_pem, string key_pem) {
 	auto x509 = shared_ptr<X509>(PEM_read_bio_X509(bio, nullptr, nullptr, nullptr), X509_free);
 	BIO_free(bio);
 	if (!x509)
-		throw std::invalid_argument("Unable to import PEM certificate");
+		RTC_THROW RTC_INVALID_ARGUMENT("Unable to import PEM certificate");
 
 	bio = BIO_new(BIO_s_mem());
 	BIO_write(bio, key_pem.data(), int(key_pem.size()));
@@ -344,46 +346,46 @@ Certificate Certificate::FromString(string crt_pem, string key_pem) {
 	                                 EVP_PKEY_free);
 	BIO_free(bio);
 	if (!pkey)
-		throw std::invalid_argument("Unable to import PEM key");
+		RTC_THROW RTC_INVALID_ARGUMENT("Unable to import PEM key");
 
 	return Certificate(x509, pkey);
 }
 
-Certificate Certificate::FromFile(const string &crt_pem_file, const string &key_pem_file,
+RTC_WRAPPED(Certificate) Certificate::FromFile(const string &crt_pem_file, const string &key_pem_file,
                                   const string &pass) {
 	PLOG_DEBUG << "Importing certificate from PEM file (OpenSSL): " << crt_pem_file;
 
 	BIO *bio = openssl::BIO_new_from_file(crt_pem_file);
 	if (!bio)
-		throw std::invalid_argument("Unable to open PEM certificate file");
+		RTC_THROW RTC_INVALID_ARGUMENT("Unable to open PEM certificate file");
 
 	auto x509 = shared_ptr<X509>(PEM_read_bio_X509(bio, nullptr, nullptr, nullptr), X509_free);
 	BIO_free(bio);
 	if (!x509)
-		throw std::invalid_argument("Unable to import PEM certificate from file");
+		RTC_THROW RTC_INVALID_ARGUMENT("Unable to import PEM certificate from file");
 
 	bio = openssl::BIO_new_from_file(key_pem_file);
 	if (!bio)
-		throw std::invalid_argument("Unable to open PEM key file");
+		RTC_THROW RTC_INVALID_ARGUMENT("Unable to open PEM key file");
 
 	auto pkey = shared_ptr<EVP_PKEY>(
 	    PEM_read_bio_PrivateKey(bio, nullptr, dummy_pass_cb, const_cast<char *>(pass.c_str())),
 	    EVP_PKEY_free);
 	BIO_free(bio);
 	if (!pkey)
-		throw std::invalid_argument("Unable to import PEM key from file");
+		RTC_THROW RTC_INVALID_ARGUMENT("Unable to import PEM key from file");
 
 	return Certificate(x509, pkey);
 }
 
-Certificate Certificate::Generate(CertificateType type, const string &commonName) {
+RTC_WRAPPED(Certificate) Certificate::Generate(CertificateType type, const string &commonName) {
 	PLOG_DEBUG << "Generating certificate (OpenSSL)";
 
 	shared_ptr<X509> x509(X509_new(), X509_free);
 	unique_ptr<BIGNUM, decltype(&BN_free)> serial_number(BN_new(), BN_free);
 	unique_ptr<X509_NAME, decltype(&X509_NAME_free)> name(X509_NAME_new(), X509_NAME_free);
 	if (!x509 || !serial_number || !name)
-		throw std::runtime_error("Unable to allocate structures for certificate generation");
+		RTC_THROW RTC_RUNTIME_ERROR("Unable to allocate structures for certificate generation");
 
 	shared_ptr<EVP_PKEY> pkey;
 	switch (type) {
@@ -401,7 +403,7 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 		unique_ptr<EC_KEY, decltype(&EC_KEY_free)> ecc(
 		    EC_KEY_new_by_curve_name(NID_X9_62_prime256v1), EC_KEY_free);
 		if (!pkey || !ecc)
-			throw std::runtime_error("Unable to allocate structure for ECDSA P-256 key pair");
+			RTC_THROW RTC_RUNTIME_ERROR("Unable to allocate structure for ECDSA P-256 key pair");
 
 		EC_KEY_set_asn1_flag(ecc.get(), OPENSSL_EC_NAMED_CURVE); // Set ASN1 OID
 		if (!EC_KEY_generate_key(ecc.get()) ||
@@ -409,7 +411,7 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 		                            ecc.release())) // the key will be freed when pkey is freed
 #endif
 		if (!pkey)
-			throw std::runtime_error("Unable to generate ECDSA P-256 key pair");
+			RTC_THROW RTC_RUNTIME_ERROR("Unable to generate ECDSA P-256 key pair");
 
 		break;
 	}
@@ -423,7 +425,7 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 		unique_ptr<RSA, decltype(&RSA_free)> rsa(RSA_new(), RSA_free);
 		unique_ptr<BIGNUM, decltype(&BN_free)> exponent(BN_new(), BN_free);
 		if (!pkey || !rsa || !exponent)
-			throw std::runtime_error("Unable to allocate structures for RSA key pair");
+			RTC_THROW RTC_RUNTIME_ERROR("Unable to allocate structures for RSA key pair");
 
 		const unsigned int e = 65537; // 2^16 + 1
 		if (!BN_set_word(exponent.get(), e) ||
@@ -432,12 +434,12 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 		                         rsa.release())) // the key will be freed when pkey is freed
 #endif
 		if (!pkey)
-			throw std::runtime_error("Unable to generate RSA key pair");
+			RTC_THROW RTC_RUNTIME_ERROR("Unable to generate RSA key pair");
 
 		break;
 	}
 	default:
-		throw std::invalid_argument("Unknown certificate type");
+		RTC_THROW RTC_INVALID_ARGUMENT("Unknown certificate type");
 	}
 
 	const size_t serialSize = 16;
@@ -445,7 +447,7 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 	    reinterpret_cast<unsigned char *>(const_cast<char *>(commonName.c_str()));
 
 	if (!X509_set_pubkey(x509.get(), pkey.get()))
-		throw std::runtime_error("Unable to set certificate public key");
+		RTC_THROW RTC_RUNTIME_ERROR("Unable to set certificate public key");
 
 	if (!X509_gmtime_adj(X509_getm_notBefore(x509.get()), 3600 * -1) ||
 	    !X509_gmtime_adj(X509_getm_notAfter(x509.get()), 3600 * 24 * 365) ||
@@ -455,10 +457,10 @@ Certificate Certificate::Generate(CertificateType type, const string &commonName
 	                                -1, 0) ||
 	    !X509_set_subject_name(x509.get(), name.get()) ||
 	    !X509_set_issuer_name(x509.get(), name.get()))
-		throw std::runtime_error("Unable to set certificate properties");
+		RTC_THROW RTC_RUNTIME_ERROR("Unable to set certificate properties");
 
 	if (!X509_sign(x509.get(), pkey.get(), EVP_sha256()))
-		throw std::runtime_error("Unable to auto-sign certificate");
+		RTC_THROW RTC_RUNTIME_ERROR("Unable to auto-sign certificate");
 
 	return Certificate(x509, pkey);
 }
@@ -470,12 +472,12 @@ std::tuple<X509 *, EVP_PKEY *> Certificate::credentials() const {
 	return {mX509.get(), mPKey.get()};
 }
 
-string make_fingerprint(X509 *x509) {
+RTC_WRAPPED(string) make_fingerprint(X509 *x509) {
 	const size_t size = 32;
 	unsigned char buffer[size];
 	unsigned int len = size;
 	if (!X509_digest(x509, EVP_sha256(), buffer, &len))
-		throw std::runtime_error("X509 fingerprint error");
+		RTC_THROW RTC_RUNTIME_ERROR("X509 fingerprint error");
 
 	std::ostringstream oss;
 	oss << std::hex << std::uppercase << std::setfill('0');
@@ -492,8 +494,10 @@ string make_fingerprint(X509 *x509) {
 // Common for GnuTLS, Mbed TLS, and OpenSSL
 
 future_certificate_ptr make_certificate(CertificateType type) {
-	return ThreadPool::Instance().enqueue([type, token = Init::Instance().token()]() {
-		return std::make_shared<Certificate>(Certificate::Generate(type, "libdatachannel"));
+	return ThreadPool::Instance().enqueue([type, token = Init::Instance().token()]() -> RTC_WRAPPED(certificate_ptr) {
+		RTC_BEGIN;
+		RTC_UNWRAP_RETHROW_DECL(auto, tmp, Certificate::Generate(type, "libdatachannel"));
+		return std::make_shared<Certificate>(tmp);
 	});
 }
 
diff --git a/thirdparty/libdatachannel/src/impl/certificate.hpp b/thirdparty/libdatachannel/src/impl/certificate.hpp
index 800bcd2d9d..c25093a275 100644
--- a/thirdparty/libdatachannel/src/impl/certificate.hpp
+++ b/thirdparty/libdatachannel/src/impl/certificate.hpp
@@ -20,11 +20,13 @@
 namespace rtc::impl {
 
 class Certificate {
+	RTC_WRAPPED_DEFAULT_CONSTRUCTABLE(Certificate);
+	Certificate() {}
 public:
-	static Certificate FromString(string crt_pem, string key_pem);
-	static Certificate FromFile(const string &crt_pem_file, const string &key_pem_file,
+	static RTC_WRAPPED(Certificate) FromString(string crt_pem, string key_pem);
+	static RTC_WRAPPED(Certificate) FromFile(const string &crt_pem_file, const string &key_pem_file,
 	                            const string &pass = "");
-	static Certificate Generate(CertificateType type, const string &commonName);
+	static RTC_WRAPPED(Certificate) Generate(CertificateType type, const string &commonName);
 
 #if USE_GNUTLS
 	Certificate(gnutls_x509_crt_t crt, gnutls_x509_privkey_t privkey);
@@ -66,7 +68,7 @@ string make_fingerprint(X509 *x509);
 #endif
 
 using certificate_ptr = shared_ptr<Certificate>;
-using future_certificate_ptr = std::shared_future<certificate_ptr>;
+using future_certificate_ptr = std::shared_future<RTC_WRAPPED(certificate_ptr)>;
 
 future_certificate_ptr make_certificate(CertificateType type = CertificateType::Default);
 
diff --git a/thirdparty/libdatachannel/src/impl/channel.cpp b/thirdparty/libdatachannel/src/impl/channel.cpp
index e545f8ede4..061d1cf1ec 100644
--- a/thirdparty/libdatachannel/src/impl/channel.cpp
+++ b/thirdparty/libdatachannel/src/impl/channel.cpp
@@ -13,36 +13,36 @@ namespace rtc::impl {
 
 void Channel::triggerOpen() {
 	mOpenTriggered = true;
-	try {
+	RTC_TRY {
 		openCallback();
-	} catch (const std::exception &e) {
-		PLOG_WARNING << "Uncaught exception in callback: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << "Uncaught exception in callback: " << e.RTC_WHAT();
 	}
 	flushPendingMessages();
 }
 
 void Channel::triggerClosed() {
-	try {
+	RTC_TRY {
 		closedCallback();
-	} catch (const std::exception &e) {
-		PLOG_WARNING << "Uncaught exception in callback: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << "Uncaught exception in callback: " << e.RTC_WHAT();
 	}
 }
 
 void Channel::triggerError(string error) {
-	try {
+	RTC_TRY {
 		errorCallback(std::move(error));
-	} catch (const std::exception &e) {
-		PLOG_WARNING << "Uncaught exception in callback: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << "Uncaught exception in callback: " << e.RTC_WHAT();
 	}
 }
 
 void Channel::triggerAvailable(size_t count) {
 	if (count == 1) {
-		try {
+		RTC_TRY {
 			availableCallback();
-		} catch (const std::exception &e) {
-			PLOG_WARNING << "Uncaught exception in callback: " << e.what();
+		} RTC_CATCH (const RTC_EXCEPTION &e) {
+			PLOG_WARNING << "Uncaught exception in callback: " << e.RTC_WHAT();
 		}
 	}
 
@@ -53,10 +53,10 @@ void Channel::triggerBufferedAmount(size_t amount) {
 	size_t previous = bufferedAmount.exchange(amount);
 	size_t threshold = bufferedAmountLowThreshold.load();
 	if (previous > threshold && amount <= threshold) {
-		try {
+		RTC_TRY {
 			bufferedAmountLowCallback();
-		} catch (const std::exception &e) {
-			PLOG_WARNING << "Uncaught exception in callback: " << e.what();
+		} RTC_CATCH (const RTC_EXCEPTION &e) {
+			PLOG_WARNING << "Uncaught exception in callback: " << e.RTC_WHAT();
 		}
 	}
 }
@@ -70,10 +70,10 @@ void Channel::flushPendingMessages() {
 		if (!next)
 			break;
 
-		try {
+		RTC_TRY {
 			messageCallback(*next);
-		} catch (const std::exception &e) {
-			PLOG_WARNING << "Uncaught exception in callback: " << e.what();
+		} RTC_CATCH (const RTC_EXCEPTION &e) {
+			PLOG_WARNING << "Uncaught exception in callback: " << e.RTC_WHAT();
 		}
 	}
 }
diff --git a/thirdparty/libdatachannel/src/impl/datachannel.cpp b/thirdparty/libdatachannel/src/impl/datachannel.cpp
index c1ce337442..46fef55330 100644
--- a/thirdparty/libdatachannel/src/impl/datachannel.cpp
+++ b/thirdparty/libdatachannel/src/impl/datachannel.cpp
@@ -79,10 +79,10 @@ DataChannel::DataChannel(weak_ptr<PeerConnection> pc, string label, string proto
 
 DataChannel::~DataChannel() {
 	PLOG_VERBOSE << "Destroying DataChannel";
-	try {
+	RTC_TRY {
 		close();
-	} catch (const std::exception &e) {
-		PLOG_ERROR << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << e.RTC_WHAT();
 	}
 }
 
@@ -148,16 +148,17 @@ size_t DataChannel::maxMessageSize() const {
 	return pc ? pc->remoteMaxMessageSize() : DEFAULT_MAX_MESSAGE_SIZE;
 }
 
-void DataChannel::assignStream(uint16_t stream) {
+RTC_WRAPPED(void) DataChannel::assignStream(uint16_t stream) {
 	std::unique_lock lock(mMutex);
 
 	if (mStream.has_value())
-		throw std::logic_error("DataChannel already has a stream assigned");
+		RTC_THROW RTC_LOGIC_ERROR("DataChannel already has a stream assigned");
 
 	mStream = stream;
+	RTC_RET;
 }
 
-void DataChannel::open(shared_ptr<SctpTransport> transport) {
+RTC_WRAPPED(void) DataChannel::open(shared_ptr<SctpTransport> transport) {
 	{
 		std::unique_lock lock(mMutex);
 		mSctpTransport = transport;
@@ -165,26 +166,28 @@ void DataChannel::open(shared_ptr<SctpTransport> transport) {
 
 	if (!mIsClosed && !mIsOpen.exchange(true))
 		triggerOpen();
+	RTC_RET;
 }
 
-void DataChannel::processOpenMessage(message_ptr) {
+RTC_WRAPPED(void) DataChannel::processOpenMessage(message_ptr) {
 	PLOG_WARNING << "Received an open message for a user-negotiated DataChannel, ignoring";
+	RTC_RET;
 }
 
-bool DataChannel::outgoing(message_ptr message) {
+RTC_WRAPPED(bool) DataChannel::outgoing(message_ptr message) {
 	shared_ptr<SctpTransport> transport;
 	{
 		std::shared_lock lock(mMutex);
 		transport = mSctpTransport.lock();
 
 		if (!transport || mIsClosed)
-			throw std::runtime_error("DataChannel is closed");
+			RTC_THROW RTC_RUNTIME_ERROR("DataChannel is closed");
 
 		if (!mStream.has_value())
-			throw std::logic_error("DataChannel has no stream assigned");
+			RTC_THROW RTC_LOGIC_ERROR("DataChannel has no stream assigned");
 
 		if (message->size() > maxMessageSize())
-			throw std::invalid_argument("Message size exceeds limit");
+			RTC_THROW RTC_INVALID_ARGUMENT("Message size exceeds limit");
 
 		// Before the ACK has been received on a DataChannel, all messages must be sent ordered
 		message->reliability = mIsOpen ? mReliability : nullptr;
@@ -194,9 +197,10 @@ bool DataChannel::outgoing(message_ptr message) {
 	return transport->send(message);
 }
 
-void DataChannel::incoming(message_ptr message) {
+RTC_WRAPPED(void) DataChannel::incoming(message_ptr message) {
+	RTC_BEGIN;
 	if (!message || mIsClosed)
-		return;
+		RTC_RET;
 
 	switch (message->type) {
 	case Message::Control: {
@@ -205,7 +209,7 @@ void DataChannel::incoming(message_ptr message) {
 		auto raw = reinterpret_cast<const uint8_t *>(message->data());
 		switch (raw[0]) {
 		case MESSAGE_OPEN:
-			processOpenMessage(message);
+			RTC_UNWRAP_RETHROW(processOpenMessage(message));
 			break;
 		case MESSAGE_ACK:
 			if (!mIsOpen.exchange(true)) {
@@ -230,6 +234,7 @@ void DataChannel::incoming(message_ptr message) {
 		// Ignore
 		break;
 	}
+	RTC_RET;
 }
 
 OutgoingDataChannel::OutgoingDataChannel(weak_ptr<PeerConnection> pc, string label, string protocol,
@@ -238,12 +243,13 @@ OutgoingDataChannel::OutgoingDataChannel(weak_ptr<PeerConnection> pc, string lab
 
 OutgoingDataChannel::~OutgoingDataChannel() {}
 
-void OutgoingDataChannel::open(shared_ptr<SctpTransport> transport) {
+RTC_WRAPPED(void) OutgoingDataChannel::open(shared_ptr<SctpTransport> transport) {
+	RTC_BEGIN;
 	std::unique_lock lock(mMutex);
 	mSctpTransport = transport;
 
 	if (!mStream.has_value())
-		throw std::runtime_error("DataChannel has no stream assigned");
+		RTC_THROW RTC_RUNTIME_ERROR("DataChannel has no stream assigned");
 
 	uint8_t channelType;
 	uint32_t reliabilityParameter;
@@ -283,11 +289,13 @@ void OutgoingDataChannel::open(shared_ptr<SctpTransport> transport) {
 
 	lock.unlock();
 
-	transport->send(make_message(buffer.begin(), buffer.end(), Message::Control, mStream.value()));
+	RTC_UNWRAP_RETHROW(transport->send(make_message(buffer.begin(), buffer.end(), Message::Control, mStream.value())));
+	RTC_RET;
 }
 
-void OutgoingDataChannel::processOpenMessage(message_ptr) {
+RTC_WRAPPED(void) OutgoingDataChannel::processOpenMessage(message_ptr) {
 	PLOG_WARNING << "Received an open message for a locally-created DataChannel, ignoring";
+	RTC_RET;
 }
 
 IncomingDataChannel::IncomingDataChannel(weak_ptr<PeerConnection> pc,
@@ -299,21 +307,23 @@ IncomingDataChannel::IncomingDataChannel(weak_ptr<PeerConnection> pc,
 
 IncomingDataChannel::~IncomingDataChannel() {}
 
-void IncomingDataChannel::open(shared_ptr<SctpTransport>) {
+RTC_WRAPPED(void) IncomingDataChannel::open(shared_ptr<SctpTransport>) {
 	// Ignore
+	RTC_RET;
 }
 
-void IncomingDataChannel::processOpenMessage(message_ptr message) {
+RTC_WRAPPED(void) IncomingDataChannel::processOpenMessage(message_ptr message) {
+	RTC_BEGIN;
 	std::unique_lock lock(mMutex);
 	auto transport = mSctpTransport.lock();
 	if (!transport)
-		throw std::logic_error("DataChannel has no transport");
+		RTC_THROW RTC_LOGIC_ERROR("DataChannel has no transport");
 
 	if (!mStream.has_value())
-		throw std::logic_error("DataChannel has no stream assigned");
+		RTC_THROW RTC_LOGIC_ERROR("DataChannel has no stream assigned");
 
 	if (message->size() < sizeof(OpenMessage))
-		throw std::invalid_argument("DataChannel open message too small");
+		RTC_THROW RTC_INVALID_ARGUMENT("DataChannel open message too small");
 
 	OpenMessage open = *reinterpret_cast<const OpenMessage *>(message->data());
 	open.priority = ntohs(open.priority);
@@ -322,7 +332,7 @@ void IncomingDataChannel::processOpenMessage(message_ptr message) {
 	open.protocolLength = ntohs(open.protocolLength);
 
 	if (message->size() < sizeof(OpenMessage) + size_t(open.labelLength + open.protocolLength))
-		throw std::invalid_argument("DataChannel open message truncated");
+		RTC_THROW RTC_INVALID_ARGUMENT("DataChannel open message truncated");
 
 	auto end = reinterpret_cast<const char *>(message->data() + sizeof(OpenMessage));
 	mLabel.assign(end, open.labelLength);
@@ -349,10 +359,11 @@ void IncomingDataChannel::processOpenMessage(message_ptr message) {
 	auto &ack = *reinterpret_cast<AckMessage *>(buffer.data());
 	ack.type = MESSAGE_ACK;
 
-	transport->send(make_message(buffer.begin(), buffer.end(), Message::Control, mStream.value()));
+	RTC_UNWRAP_RETHROW(transport->send(make_message(buffer.begin(), buffer.end(), Message::Control, mStream.value())));
 
 	if (!mIsOpen.exchange(true))
 		triggerOpen();
+	RTC_RET;
 }
 
 } // namespace rtc::impl
diff --git a/thirdparty/libdatachannel/src/impl/datachannel.hpp b/thirdparty/libdatachannel/src/impl/datachannel.hpp
index cd501bff2f..0080bb2454 100644
--- a/thirdparty/libdatachannel/src/impl/datachannel.hpp
+++ b/thirdparty/libdatachannel/src/impl/datachannel.hpp
@@ -33,8 +33,8 @@ struct DataChannel : Channel, std::enable_shared_from_this<DataChannel> {
 
 	void close();
 	void remoteClose();
-	bool outgoing(message_ptr message);
-	void incoming(message_ptr message);
+	RTC_WRAPPED(bool) outgoing(message_ptr message);
+	RTC_WRAPPED(void) incoming(message_ptr message);
 
 	optional<message_variant> receive() override;
 	optional<message_variant> peek() override;
@@ -49,9 +49,9 @@ struct DataChannel : Channel, std::enable_shared_from_this<DataChannel> {
 	bool isClosed(void) const;
 	size_t maxMessageSize() const;
 
-	virtual void assignStream(uint16_t stream);
-	virtual void open(shared_ptr<SctpTransport> transport);
-	virtual void processOpenMessage(message_ptr);
+	virtual RTC_WRAPPED(void) assignStream(uint16_t stream);
+	virtual RTC_WRAPPED(void) open(shared_ptr<SctpTransport> transport);
+	virtual RTC_WRAPPED(void) processOpenMessage(message_ptr);
 
 protected:
 	const weak_ptr<impl::PeerConnection> mPeerConnection;
@@ -76,16 +76,16 @@ struct OutgoingDataChannel final : public DataChannel {
 	                    Reliability reliability);
 	~OutgoingDataChannel();
 
-	void open(shared_ptr<SctpTransport> transport) override;
-	void processOpenMessage(message_ptr message) override;
+	RTC_WRAPPED(void) open(shared_ptr<SctpTransport> transport) override;
+	RTC_WRAPPED(void) processOpenMessage(message_ptr message) override;
 };
 
 struct IncomingDataChannel final : public DataChannel {
 	IncomingDataChannel(weak_ptr<PeerConnection> pc, weak_ptr<SctpTransport> transport);
 	~IncomingDataChannel();
 
-	void open(shared_ptr<SctpTransport> transport) override;
-	void processOpenMessage(message_ptr message) override;
+	RTC_WRAPPED(void) open(shared_ptr<SctpTransport> transport) override;
+	RTC_WRAPPED(void) processOpenMessage(message_ptr message) override;
 };
 
 } // namespace rtc::impl
diff --git a/thirdparty/libdatachannel/src/impl/dtlstransport.cpp b/thirdparty/libdatachannel/src/impl/dtlstransport.cpp
index 3779c5671e..07453a9d72 100644
--- a/thirdparty/libdatachannel/src/impl/dtlstransport.cpp
+++ b/thirdparty/libdatachannel/src/impl/dtlstransport.cpp
@@ -46,17 +46,19 @@ void DtlsTransport::Init() {
 
 void DtlsTransport::Cleanup() { gnutls_global_deinit(); }
 
-DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr certificate,
+DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr certificate
                              optional<size_t> mtu, verifier_callback verifierCallback,
                              state_callback stateChangeCallback)
     : Transport(lower, std::move(stateChangeCallback)), mMtu(mtu), mCertificate(certificate),
       mVerifierCallback(std::move(verifierCallback)),
       mIsClient(lower->role() == Description::Role::Active) {
+}
 
+RTC_WRAPPED(void) DtlsTransport::construct() {
 	PLOG_DEBUG << "Initializing DTLS transport (GnuTLS)";
 
 	if (!mCertificate)
-		throw std::invalid_argument("DTLS certificate is null");
+		RTC_THROW RTC_INVALID_ARGUMENT("DTLS certificate is null");
 
 	gnutls_certificate_credentials_t creds = mCertificate->credentials();
 	gnutls_certificate_set_verify_function(creds, CertificateCallback);
@@ -65,7 +67,7 @@ DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr cer
 	    GNUTLS_DATAGRAM | GNUTLS_NONBLOCK | (mIsClient ? GNUTLS_CLIENT : GNUTLS_SERVER);
 	gnutls::check(gnutls_init(&mSession, flags));
 
-	try {
+	RTC_TRY {
 		// RFC 8261: SCTP performs segmentation and reassembly based on the path MTU.
 		// Therefore, the DTLS layer MUST NOT use any compression algorithm.
 		// See https://www.rfc-editor.org/rfc/rfc8261.html#section-5
@@ -92,14 +94,15 @@ DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr cer
 		gnutls_transport_set_pull_function(mSession, ReadCallback);
 		gnutls_transport_set_pull_timeout_function(mSession, TimeoutCallback);
 
-	} catch (...) {
+	} RTC_CATCH (...) {
 		gnutls_deinit(mSession);
-		throw;
+		RTC_RETHROW;
 	}
 
 	// Set recommended medium-priority DSCP value for handshake
 	// See https://www.rfc-editor.org/rfc/rfc8837.html#section-5
 	mCurrentDscp = 10; // AF11: Assured Forwarding class 1, low drop probability
+	RTC_RET;
 }
 
 DtlsTransport::~DtlsTransport() {
@@ -109,7 +112,7 @@ DtlsTransport::~DtlsTransport() {
 	gnutls_deinit(mSession);
 }
 
-void DtlsTransport::start() {
+RTC_WRAPPED(void) DtlsTransport::start() {
 	PLOG_DEBUG << "Starting DTLS transport";
 	registerIncoming();
 	changeState(State::Connecting);
@@ -185,7 +188,7 @@ void DtlsTransport::doRecv() {
 	if (state() != State::Connecting && state() != State::Connected)
 		return;
 
-	try {
+	RTC_TRY {
 		const size_t bufferSize = 4096;
 		char buffer[bufferSize];
 
@@ -206,7 +209,7 @@ void DtlsTransport::doRecv() {
 				}
 
 				if (ret == GNUTLS_E_LARGE_PACKET) {
-					throw std::runtime_error("MTU is too low");
+					RTC_THROW_WITHIN(RTC_RUNTIME_ERROR("MTU is too low"));
 				}
 
 			} while (!gnutls::check(ret, "Handshake failed")); // Re-call on non-fatal error
@@ -257,8 +260,8 @@ void DtlsTransport::doRecv() {
 				}
 			}
 		}
-	} catch (const std::exception &e) {
-		PLOG_ERROR << "DTLS recv: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << "DTLS recv: " << e.RTC_WHAT();
 	}
 
 	gnutls_bye(mSession, GNUTLS_SHUT_WR);
@@ -275,7 +278,7 @@ void DtlsTransport::doRecv() {
 
 int DtlsTransport::CertificateCallback(gnutls_session_t session) {
 	DtlsTransport *t = static_cast<DtlsTransport *>(gnutls_session_get_ptr(session));
-	try {
+	RTC_TRY {
 		if (gnutls_certificate_type_get(session) != GNUTLS_CRT_X509) {
 			return GNUTLS_E_CERTIFICATE_ERROR;
 		}
@@ -300,15 +303,15 @@ int DtlsTransport::CertificateCallback(gnutls_session_t session) {
 		bool success = t->mVerifierCallback(fingerprint);
 		return success ? GNUTLS_E_SUCCESS : GNUTLS_E_CERTIFICATE_ERROR;
 
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 		return GNUTLS_E_CERTIFICATE_ERROR;
 	}
 }
 
 ssize_t DtlsTransport::WriteCallback(gnutls_transport_ptr_t ptr, const void *data, size_t len) {
 	DtlsTransport *t = static_cast<DtlsTransport *>(ptr);
-	try {
+	RTC_TRY {
 		if (len > 0) {
 			auto b = reinterpret_cast<const byte *>(data);
 			t->outgoing(make_message(b, b + len));
@@ -316,8 +319,8 @@ ssize_t DtlsTransport::WriteCallback(gnutls_transport_ptr_t ptr, const void *dat
 		gnutls_transport_set_errno(t->mSession, 0);
 		return ssize_t(len);
 
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 		gnutls_transport_set_errno(t->mSession, ECONNRESET);
 		return -1;
 	}
@@ -325,7 +328,7 @@ ssize_t DtlsTransport::WriteCallback(gnutls_transport_ptr_t ptr, const void *dat
 
 ssize_t DtlsTransport::ReadCallback(gnutls_transport_ptr_t ptr, void *data, size_t maxlen) {
 	DtlsTransport *t = static_cast<DtlsTransport *>(ptr);
-	try {
+	RTC_TRY {
 		while (t->mIncomingQueue.running()) {
 			auto next = t->mIncomingQueue.pop();
 			if (!next) {
@@ -347,8 +350,8 @@ ssize_t DtlsTransport::ReadCallback(gnutls_transport_ptr_t ptr, void *data, size
 		gnutls_transport_set_errno(t->mSession, 0);
 		return 0;
 
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 		gnutls_transport_set_errno(t->mSession, ECONNRESET);
 		return -1;
 	}
@@ -356,11 +359,11 @@ ssize_t DtlsTransport::ReadCallback(gnutls_transport_ptr_t ptr, void *data, size
 
 int DtlsTransport::TimeoutCallback(gnutls_transport_ptr_t ptr, unsigned int /* ms */) {
 	DtlsTransport *t = static_cast<DtlsTransport *>(ptr);
-	try {
+	RTC_TRY {
 		return !t->mIncomingQueue.empty() ? 1 : 0;
 
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 		return 1;
 	}
 }
@@ -376,14 +379,16 @@ int DtlsTransport::TimeoutCallback(gnutls_transport_ptr_t ptr, unsigned int /* m
 DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr certificate,
                              optional<size_t> mtu, verifier_callback verifierCallback,
                              state_callback stateChangeCallback)
-    : Transport(lower, std::move(stateChangeCallback)), mMtu(mtu), mCertificate(certificate),
+    : Transport(lower, std::move(stateChangeCallback)), mMtu(mtu),
       mVerifierCallback(std::move(verifierCallback)),
       mIsClient(lower->role() == Description::Role::Active) {
+}
 
+RTC_WRAPPED(void) DtlsTransport::construct() {
 	PLOG_DEBUG << "Initializing DTLS transport (MbedTLS)";
 
 	if (!mCertificate)
-		throw std::invalid_argument("DTLS certificate is null");
+		RTC_THROW RTC_INVALID_ARGUMENT("DTLS certificate is null");
 
 	mbedtls_entropy_init(&mEntropy);
 	mbedtls_ctr_drbg_init(&mDrbg);
@@ -391,14 +396,14 @@ DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr cer
 	mbedtls_ssl_config_init(&mConf);
 	mbedtls_ctr_drbg_set_prediction_resistance(&mDrbg, MBEDTLS_CTR_DRBG_PR_ON);
 
-	try {
-		mbedtls::check(mbedtls_ctr_drbg_seed(&mDrbg, mbedtls_entropy_func, &mEntropy, NULL, 0),
-		               "Failed creating Mbed TLS Context");
+	RTC_TRY {
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_ctr_drbg_seed(&mDrbg, mbedtls_entropy_func, &mEntropy, NULL, 0),
+		               "Failed creating Mbed TLS Context"));
 
-		mbedtls::check(mbedtls_ssl_config_defaults(
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_ssl_config_defaults(
 		                   &mConf, mIsClient ? MBEDTLS_SSL_IS_CLIENT : MBEDTLS_SSL_IS_SERVER,
 		                   MBEDTLS_SSL_TRANSPORT_DATAGRAM, MBEDTLS_SSL_PRESET_DEFAULT),
-		               "Failed creating Mbed TLS Context");
+		               "Failed creating Mbed TLS Context"));
 
 		mbedtls_ssl_conf_authmode(&mConf, MBEDTLS_SSL_VERIFY_OPTIONAL);
 		mbedtls_ssl_conf_verify(&mConf, DtlsTransport::CertificateCallback, this);
@@ -406,29 +411,30 @@ DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr cer
 		mbedtls_ssl_conf_rng(&mConf, mbedtls_ctr_drbg_random, &mDrbg);
 
 		auto [crt, pk] = mCertificate->credentials();
-		mbedtls::check(mbedtls_ssl_conf_own_cert(&mConf, crt.get(), pk.get()),
-		               "Failed creating Mbed TLS Context");
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_ssl_conf_own_cert(&mConf, crt.get(), pk.get()),
+		               "Failed creating Mbed TLS Context"));
 
 		mbedtls_ssl_conf_dtls_cookies(&mConf, NULL, NULL, NULL);
 		// GODOT Deleted // mbedtls_ssl_conf_dtls_srtp_protection_profiles(&mConf, srtpSupportedProtectionProfiles);
 
-		mbedtls::check(mbedtls_ssl_setup(&mSsl, &mConf), "Failed creating Mbed TLS Context");
+		RTC_UNWRAP_CATCH(mbedtls::check(mbedtls_ssl_setup(&mSsl, &mConf), "Failed creating Mbed TLS Context"));
 
 		mbedtls_ssl_set_export_keys_cb(&mSsl, DtlsTransport::ExportKeysCallback, this);
 		mbedtls_ssl_set_bio(&mSsl, this, WriteCallback, ReadCallback, NULL);
 		mbedtls_ssl_set_timer_cb(&mSsl, this, SetTimerCallback, GetTimerCallback);
 
-	} catch (...) {
+	} RTC_CATCH (...) {
 		mbedtls_entropy_free(&mEntropy);
 		mbedtls_ctr_drbg_free(&mDrbg);
 		mbedtls_ssl_free(&mSsl);
 		mbedtls_ssl_config_free(&mConf);
-		throw;
+		RTC_RETHROW;
 	}
 
 	// Set recommended medium-priority DSCP value for handshake
 	// See https://www.rfc-editor.org/rfc/rfc8837.html#section-5
 	mCurrentDscp = 10; // AF11: Assured Forwarding class 1, low drop probability
+	RTC_RET;
 }
 
 DtlsTransport::~DtlsTransport() {
@@ -449,7 +455,7 @@ void DtlsTransport::Cleanup() {
 	// Nothing to do
 }
 
-void DtlsTransport::start() {
+RTC_WRAPPED(void) DtlsTransport::start() {
 	PLOG_DEBUG << "Starting DTLS transport";
 	registerIncoming();
 	changeState(State::Connecting);
@@ -462,6 +468,7 @@ void DtlsTransport::start() {
 	}
 
 	enqueueRecv(); // to initiate the handshake
+	RTC_RET;
 }
 
 void DtlsTransport::stop() {
@@ -471,7 +478,7 @@ void DtlsTransport::stop() {
 	enqueueRecv();
 }
 
-bool DtlsTransport::send(message_ptr message) {
+RTC_WRAPPED(bool) DtlsTransport::send(message_ptr message) {
 	if (!message || state() != State::Connected)
 		return false;
 
@@ -486,7 +493,12 @@ bool DtlsTransport::send(message_ptr message) {
 		mCurrentDscp = message->dscp;
 		ret = mbedtls_ssl_write(&mSsl, reinterpret_cast<const unsigned char *>(message->data()),
 		                        message->size());
-	} while (!mbedtls::check(ret));
+		RTC_BEGIN;
+		RTC_UNWRAP_RETHROW_DECL(bool, cond, mbedtls::check(ret));
+		if (cond) {
+			break;
+		}
+	} while (1);
 
 	return mOutgoingResult;
 }
@@ -502,10 +514,11 @@ void DtlsTransport::incoming(message_ptr message) {
 	enqueueRecv();
 }
 
-bool DtlsTransport::outgoing(message_ptr message) {
+RTC_WRAPPED(bool) DtlsTransport::outgoing(message_ptr message) {
+	RTC_BEGIN;
 	message->dscp = mCurrentDscp;
 
-	bool result = Transport::outgoing(std::move(message));
+	RTC_UNWRAP_RETHROW_DECL(bool, result, Transport::outgoing(std::move(message)));
 	mOutgoingResult = result;
 	return result;
 }
@@ -526,7 +539,7 @@ void DtlsTransport::doRecv() {
 	if (state() != State::Connecting && state() != State::Connected)
 		return;
 
-	try {
+	RTC_TRY {
 		const size_t bufferSize = 4096;
 		char buffer[bufferSize];
 
@@ -548,7 +561,8 @@ void DtlsTransport::doRecv() {
 					return;
 				}
 
-				if (mbedtls::check(ret, "Handshake failed")) {
+				RTC_UNWRAP_CATCH_DECL(bool, res, mbedtls::check(ret, "Handshake failed"));
+				if (res) {
 					// RFC 8261: DTLS MUST support sending messages larger than the current path MTU
 					// See https://www.rfc-editor.org/rfc/rfc8261.html#section-5
 					{
@@ -582,7 +596,8 @@ void DtlsTransport::doRecv() {
 					break;
 				}
 
-				if (mbedtls::check(ret)) {
+				RTC_UNWRAP_CATCH_DECL(bool, res, mbedtls::check(ret, "Handshake failed"));
+				if (res) {
 					if (ret == 0) {
 						PLOG_DEBUG << "DTLS connection terminated";
 						break;
@@ -592,8 +607,8 @@ void DtlsTransport::doRecv() {
 				}
 			}
 		}
-	} catch (const std::exception &e) {
-		PLOG_ERROR << "DTLS recv: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << "DTLS recv: " << e.RTC_WHAT();
 	}
 
 	if (state() == State::Connected) {
@@ -629,22 +644,22 @@ void DtlsTransport::ExportKeysCallback(void *ctx, mbedtls_ssl_key_export_type /*
 
 int DtlsTransport::WriteCallback(void *ctx, const unsigned char *buf, size_t len) {
 	auto *t = static_cast<DtlsTransport *>(ctx);
-	try {
+	RTC_TRY {
 		if (len > 0) {
 			auto b = reinterpret_cast<const byte *>(buf);
-			t->outgoing(make_message(b, b + len));
+			RTC_UNWRAP_CATCH(t->outgoing(make_message(b, b + len)));
 		}
 		return int(len);
 
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 		return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
 	}
 }
 
 int DtlsTransport::ReadCallback(void *ctx, unsigned char *buf, size_t len) {
 	auto *t = static_cast<DtlsTransport *>(ctx);
-	try {
+	RTC_TRY {
 		while (t->mIncomingQueue.running()) {
 			auto next = t->mIncomingQueue.pop();
 			if (!next) {
@@ -663,8 +678,8 @@ int DtlsTransport::ReadCallback(void *ctx, unsigned char *buf, size_t len) {
 		// Closed
 		return 0;
 
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 		return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
 		;
 	}
@@ -709,7 +724,7 @@ void DtlsTransport::Init() {
 	if (!BioMethods) {
 		BioMethods = BIO_meth_new(BIO_TYPE_BIO, "DTLS writer");
 		if (!BioMethods)
-			throw std::runtime_error("Failed to create BIO methods for DTLS writer");
+			PLOG_ERROR << "Failed to create BIO methods for DTLS writer";
 		BIO_meth_set_create(BioMethods, BioMethodNew);
 		BIO_meth_set_destroy(BioMethods, BioMethodFree);
 		BIO_meth_set_write(BioMethods, BioMethodWrite);
@@ -730,15 +745,18 @@ DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr cer
     : Transport(lower, std::move(stateChangeCallback)), mMtu(mtu), mCertificate(certificate),
       mVerifierCallback(std::move(verifierCallback)),
       mIsClient(lower->role() == Description::Role::Active) {
+}
+
+RTC_WRAPPED(void) DtlsTransport::construct() {
 	PLOG_DEBUG << "Initializing DTLS transport (OpenSSL)";
 
 	if (!mCertificate)
-		throw std::invalid_argument("DTLS certificate is null");
+		RTC_THROW RTC_INVALID_ARGUMENT("DTLS certificate is null");
 
-	try {
+	RTC_TRY {
 		mCtx = SSL_CTX_new(DTLS_method());
 		if (!mCtx)
-			throw std::runtime_error("Failed to create SSL context");
+			RTC_THROW_WITHIN(RTC_RUNTIME_ERROR("Failed to create SSL context"));
 
 		// RFC 8261: SCTP performs segmentation and reassembly based on the path MTU.
 		// Therefore, the DTLS layer MUST NOT use any compression algorithm.
@@ -776,7 +794,7 @@ DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr cer
 
 		mSsl = SSL_new(mCtx);
 		if (!mSsl)
-			throw std::runtime_error("Failed to create SSL instance");
+			RTC_THROW_WITHIN(RTC_RUNTIME_ERROR("Failed to create SSL instance"));
 
 		SSL_set_ex_data(mSsl, TransportExIndex, this);
 
@@ -788,7 +806,7 @@ DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr cer
 		mInBio = BIO_new(BIO_s_mem());
 		mOutBio = BIO_new(BioMethods);
 		if (!mInBio || !mOutBio)
-			throw std::runtime_error("Failed to create BIO");
+			RTC_THROW_WITHIN(RTC_RUNTIME_ERROR("Failed to create BIO"));
 
 		BIO_set_mem_eof_return(mInBio, BIO_EOF);
 		BIO_set_data(mOutBio, this);
@@ -801,21 +819,22 @@ DtlsTransport::DtlsTransport(shared_ptr<IceTransport> lower, certificate_ptr cer
 		if (SSL_set_tlsext_use_srtp(
 		        mSsl, "SRTP_AEAD_AES_256_GCM:SRTP_AEAD_AES_128_GCM:SRTP_AES128_CM_SHA1_80")) {
 			if (SSL_set_tlsext_use_srtp(mSsl, "SRTP_AES128_CM_SHA1_80"))
-				throw std::runtime_error("Failed to set SRTP profile: " +
-				                         openssl::error_string(ERR_get_error()));
+				RTC_THROW_WITHIN(RTC_RUNTIME_ERROR("Failed to set SRTP profile: " +
+				                         openssl::error_string(ERR_get_error())));
 		}
 
-	} catch (...) {
+	} RTC_CATCH (...) {
 		if (mSsl)
 			SSL_free(mSsl);
 		if (mCtx)
 			SSL_CTX_free(mCtx);
-		throw;
+		RTC_RETHROW;
 	}
 
 	// Set recommended medium-priority DSCP value for handshake
 	// See https://www.rfc-editor.org/rfc/rfc8837.html#section-5
 	mCurrentDscp = 10; // AF11: Assured Forwarding class 1, low drop probability
+	RTC_RET;
 }
 
 DtlsTransport::~DtlsTransport() {
@@ -912,7 +931,7 @@ void DtlsTransport::doRecv() {
 	if (state() != State::Connecting && state() != State::Connected)
 		return;
 
-	try {
+	RTC_TRY {
 		const size_t bufferSize = 4096;
 		byte buffer[bufferSize];
 
@@ -977,8 +996,8 @@ void DtlsTransport::doRecv() {
 		std::lock_guard lock(mSslMutex);
 		SSL_shutdown(mSsl);
 
-	} catch (const std::exception &e) {
-		PLOG_ERROR << "DTLS recv: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << "DTLS recv: " << e.RTC_WHAT();
 	}
 
 	if (state() == State::Connected) {
@@ -991,13 +1010,13 @@ void DtlsTransport::doRecv() {
 	}
 }
 
-void DtlsTransport::handleTimeout() {
+RTC_WRAPPED(void) DtlsTransport::handleTimeout() {
 	std::lock_guard lock(mSslMutex);
 
 	// Warning: This function breaks the usual return value convention
 	int ret = DTLSv1_handle_timeout(mSsl);
 	if (ret < 0) {
-		throw std::runtime_error("Handshake timeout"); // write BIO can't fail
+		RTC_THROW RTC_RUNTIME_ERROR("Handshake timeout"); // write BIO can't fail
 	} else if (ret > 0) {
 		LOG_VERBOSE << "DTLS retransmit done";
 	}
@@ -1010,7 +1029,7 @@ void DtlsTransport::handleTimeout() {
 		// recommended 1s so this allows for 5 retransmissions and fails after
 		// roughly 30s.
 		if (timeout > 30s)
-			throw std::runtime_error("Handshake timeout");
+			RTC_THROW RTC_RUNTIME_ERROR("Handshake timeout");
 
 		LOG_VERBOSE << "DTLS retransmit timeout is " << timeout.count() << "ms";
 		ThreadPool::Instance().schedule(timeout, [weak_this = weak_from_this()]() {
diff --git a/thirdparty/libdatachannel/src/impl/dtlstransport.hpp b/thirdparty/libdatachannel/src/impl/dtlstransport.hpp
index d84b312e80..3e70de01b7 100644
--- a/thirdparty/libdatachannel/src/impl/dtlstransport.hpp
+++ b/thirdparty/libdatachannel/src/impl/dtlstransport.hpp
@@ -35,15 +35,16 @@ public:
 	              verifier_callback verifierCallback, state_callback stateChangeCallback);
 	~DtlsTransport();
 
-	virtual void start() override;
+	RTC_WRAPPED(void) construct();
+	virtual RTC_WRAPPED(void) start() override;
 	virtual void stop() override;
-	virtual bool send(message_ptr message) override; // false if dropped
+	virtual RTC_WRAPPED(bool) send(message_ptr message) override; // false if dropped
 
 	bool isClient() const { return mIsClient; }
 
 protected:
 	virtual void incoming(message_ptr message) override;
-	virtual bool outgoing(message_ptr message) override;
+	virtual RTC_WRAPPED(bool) outgoing(message_ptr message) override;
 	virtual bool demuxMessage(message_ptr message);
 	virtual void postHandshake();
 
diff --git a/thirdparty/libdatachannel/src/impl/icetransport.cpp b/thirdparty/libdatachannel/src/impl/icetransport.cpp
index 3a19e92ac6..d9f725998b 100644
--- a/thirdparty/libdatachannel/src/impl/icetransport.cpp
+++ b/thirdparty/libdatachannel/src/impl/icetransport.cpp
@@ -45,7 +45,7 @@ void IceTransport::Cleanup() {
 	// Dummy
 }
 
-IceTransport::IceTransport(const Configuration &config, candidate_callback candidateCallback,
+IceTransport::IceTransport(candidate_callback candidateCallback,
                            state_callback stateChangeCallback,
                            gathering_state_callback gatheringStateChangeCallback)
     : Transport(nullptr, std::move(stateChangeCallback)), mRole(Description::Role::ActPass),
@@ -53,7 +53,9 @@ IceTransport::IceTransport(const Configuration &config, candidate_callback candi
       mCandidateCallback(std::move(candidateCallback)),
       mGatheringStateChangeCallback(std::move(gatheringStateChangeCallback)),
       mAgent(nullptr, nullptr) {
+}
 
+RTC_WRAPPED(void) IceTransport::construct(const Configuration &config) {
 	PLOG_DEBUG << "Initializing ICE transport (libjuice)";
 
 	juice_log_level_t level;
@@ -152,7 +154,8 @@ IceTransport::IceTransport(const Configuration &config, candidate_callback candi
 	// Create agent
 	mAgent = decltype(mAgent)(juice_create(&jconfig), juice_destroy);
 	if (!mAgent)
-		throw std::runtime_error("Failed to create the ICE agent");
+		RTC_THROW RTC_RUNTIME_ERROR("Failed to create the ICE agent");
+	RTC_RET;
 }
 
 IceTransport::~IceTransport() {
@@ -162,27 +165,28 @@ IceTransport::~IceTransport() {
 
 Description::Role IceTransport::role() const { return mRole; }
 
-Description IceTransport::getLocalDescription(Description::Type type) const {
+RTC_WRAPPED(Description) IceTransport::getLocalDescription(Description::Type type) const {
+	RTC_BEGIN;
 	char sdp[JUICE_MAX_SDP_STRING_LEN];
 	if (juice_get_local_description(mAgent.get(), sdp, JUICE_MAX_SDP_STRING_LEN) < 0)
-		throw std::runtime_error("Failed to generate local SDP");
+		RTC_THROW RTC_RUNTIME_ERROR("Failed to generate local SDP");
 
 	// RFC 5763: The endpoint that is the offerer MUST use the setup attribute value of
 	// setup:actpass.
 	// See https://www.rfc-editor.org/rfc/rfc5763.html#section-5
-	Description desc(string(sdp), type,
-	                 type == Description::Type::Offer ? Description::Role::ActPass : mRole);
+	RTC_UNWRAP_RETHROW_DECL(Description, desc, Description::create(string(sdp), type,
+	                 type == Description::Type::Offer ? Description::Role::ActPass : mRole));
 	desc.addIceOption("trickle");
 	return desc;
 }
 
-void IceTransport::setRemoteDescription(const Description &description) {
+RTC_WRAPPED(void) IceTransport::setRemoteDescription(const Description &description) {
 	// RFC 5763: The answerer MUST use either a setup attribute value of setup:active or
 	// setup:passive.
 	// See https://www.rfc-editor.org/rfc/rfc5763.html#section-5
 	if (description.type() == Description::Type::Answer &&
 	    description.role() == Description::Role::ActPass)
-		throw std::invalid_argument("Illegal role actpass in remote answer description");
+		RTC_THROW RTC_INVALID_ARGUMENT("Illegal role actpass in remote answer description");
 
 	// RFC 5763: Note that if the answerer uses setup:passive, then the DTLS handshake
 	// will not begin until the answerer is received, which adds additional latency.
@@ -193,31 +197,33 @@ void IceTransport::setRemoteDescription(const Description &description) {
 		                                                        : Description::Role::Active;
 
 	if (mRole == description.role())
-		throw std::invalid_argument("Incompatible roles with remote description");
+		RTC_THROW RTC_INVALID_ARGUMENT("Incompatible roles with remote description");
 
 	mMid = description.bundleMid();
 	if (juice_set_remote_description(mAgent.get(),
 	                                 description.generateApplicationSdp("\r\n").c_str()) < 0)
-		throw std::invalid_argument("Invalid ICE settings from remote SDP");
+		RTC_THROW RTC_INVALID_ARGUMENT("Invalid ICE settings from remote SDP");
+	RTC_RET;
 }
 
 bool IceTransport::addRemoteCandidate(const Candidate &candidate) {
-	// Don't try to pass unresolved candidates for more safety
+	// Don't RTC_TRY to pass unresolved candidates for more safety
 	if (!candidate.isResolved())
 		return false;
 
 	return juice_add_remote_candidate(mAgent.get(), string(candidate).c_str()) >= 0;
 }
 
-void IceTransport::gatherLocalCandidates(string mid) {
+RTC_WRAPPED(void) IceTransport::gatherLocalCandidates(string mid) {
 	mMid = std::move(mid);
 
 	// Change state now as candidates calls can be synchronous
 	changeGatheringState(GatheringState::InProgress);
 
 	if (juice_gather_candidates(mAgent.get()) < 0) {
-		throw std::runtime_error("Failed to gather local ICE candidates");
+		RTC_THROW RTC_RUNTIME_ERROR("Failed to gather local ICE candidates");
 	}
+	RTC_RET;
 }
 
 optional<string> IceTransport::getLocalAddress() const {
@@ -237,17 +243,18 @@ optional<string> IceTransport::getRemoteAddress() const {
 	return nullopt;
 }
 
-bool IceTransport::getSelectedCandidatePair(Candidate *local, Candidate *remote) {
+RTC_WRAPPED(bool) IceTransport::getSelectedCandidatePair(Candidate *local, Candidate *remote) {
+	RTC_BEGIN;
 	char sdpLocal[JUICE_MAX_CANDIDATE_SDP_STRING_LEN];
 	char sdpRemote[JUICE_MAX_CANDIDATE_SDP_STRING_LEN];
 	if (juice_get_selected_candidates(mAgent.get(), sdpLocal, JUICE_MAX_CANDIDATE_SDP_STRING_LEN,
 	                                  sdpRemote, JUICE_MAX_CANDIDATE_SDP_STRING_LEN) == 0) {
 		if (local) {
-			*local = Candidate(sdpLocal, mMid);
+			RTC_UNWRAP_RETHROW_VAR(*local, Candidate::create(sdpLocal, mMid));
 			local->resolve(Candidate::ResolveMode::Simple);
 		}
 		if (remote) {
-			*remote = Candidate(sdpRemote, mMid);
+			RTC_UNWRAP_RETHROW_VAR(*remote, Candidate::create(sdpRemote, mMid));
 			remote->resolve(Candidate::ResolveMode::Simple);
 		}
 		return true;
@@ -255,7 +262,7 @@ bool IceTransport::getSelectedCandidatePair(Candidate *local, Candidate *remote)
 	return false;
 }
 
-bool IceTransport::send(message_ptr message) {
+RTC_WRAPPED(bool) IceTransport::send(message_ptr message) {
 	auto s = state();
 	if (!message || (s != State::Connected && s != State::Completed))
 		return false;
@@ -264,7 +271,7 @@ bool IceTransport::send(message_ptr message) {
 	return outgoing(message);
 }
 
-bool IceTransport::outgoing(message_ptr message) {
+RTC_WRAPPED(bool) IceTransport::outgoing(message_ptr message) {
 	// Explicit Congestion Notification takes the least-significant 2 bits of the DS field
 	int ds = int(message->dscp << 2);
 	return juice_send_diffserv(mAgent.get(), reinterpret_cast<const char *>(message->data()),
@@ -296,47 +303,50 @@ void IceTransport::processStateChange(unsigned int state) {
 	};
 }
 
-void IceTransport::processCandidate(const string &candidate) {
-	mCandidateCallback(Candidate(candidate, mMid));
+RTC_WRAPPED(void) IceTransport::processCandidate(const string &candidate) {
+	RTC_BEGIN;
+	RTC_UNWRAP_RETHROW_DECL(Candidate, tmp, Candidate::create(candidate, mMid));
+	RTC_UNWRAP_RETHROW(mCandidateCallback(tmp));
+	RTC_RET;
 }
 
 void IceTransport::processGatheringDone() { changeGatheringState(GatheringState::Complete); }
 
 void IceTransport::StateChangeCallback(juice_agent_t *, juice_state_t state, void *user_ptr) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(user_ptr);
-	try {
+	RTC_TRY {
 		iceTransport->processStateChange(static_cast<unsigned int>(state));
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 void IceTransport::CandidateCallback(juice_agent_t *, const char *sdp, void *user_ptr) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(user_ptr);
-	try {
-		iceTransport->processCandidate(sdp);
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	RTC_TRY {
+		RTC_UNWRAP_CATCH(iceTransport->processCandidate(sdp));
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 void IceTransport::GatheringDoneCallback(juice_agent_t *, void *user_ptr) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(user_ptr);
-	try {
+	RTC_TRY {
 		iceTransport->processGatheringDone();
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 void IceTransport::RecvCallback(juice_agent_t *, const char *data, size_t size, void *user_ptr) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(user_ptr);
-	try {
+	RTC_TRY {
 		PLOG_VERBOSE << "Incoming size=" << size;
 		auto b = reinterpret_cast<const byte *>(data);
 		iceTransport->incoming(make_message(b, b + size));
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
@@ -376,7 +386,7 @@ void IceTransport::Init() {
 
 	MainLoop = decltype(MainLoop)(g_main_loop_new(nullptr, FALSE), g_main_loop_unref);
 	if (!MainLoop)
-		throw std::runtime_error("Failed to create the main loop");
+		PLOG_ERROR << "Failed to create the main loop";
 
 	MainLoopThread = std::thread(g_main_loop_run, MainLoop.get());
 }
@@ -396,7 +406,7 @@ static void closeNiceAgent(NiceAgent *niceAgent) {
 	nice_agent_close_async(niceAgent, closeNiceAgentCallback, nullptr);
 }
 
-IceTransport::IceTransport(const Configuration &config, candidate_callback candidateCallback,
+IceTransport::IceTransport(candidate_callback candidateCallback,
                            state_callback stateChangeCallback,
                            gathering_state_callback gatheringStateChangeCallback)
     : Transport(nullptr, std::move(stateChangeCallback)), mRole(Description::Role::ActPass),
@@ -404,11 +414,13 @@ IceTransport::IceTransport(const Configuration &config, candidate_callback candi
       mCandidateCallback(std::move(candidateCallback)),
       mGatheringStateChangeCallback(std::move(gatheringStateChangeCallback)),
       mNiceAgent(nullptr, nullptr), mOutgoingDscp(0) {
+}
 
+RTC_WRAPPED(void) IceTransport::construct(const Configuration &config) {
 	PLOG_DEBUG << "Initializing ICE transport (libnice)";
 
 	if (!MainLoop)
-		throw std::logic_error("Main loop for nice agent is not created");
+		RTC_THROW RTC_LOGIC_ERROR("Main loop for nice agent is not created");
 
 	// RFC 8445: The nomination process that was referred to as "aggressive nomination" in RFC 5245
 	// has been deprecated in this specification.
@@ -425,11 +437,11 @@ IceTransport::IceTransport(const Configuration &config, candidate_callback candi
 	    closeNiceAgent);
 
 	if (!mNiceAgent)
-		throw std::runtime_error("Failed to create the nice agent");
+		RTC_THROW RTC_RUNTIME_ERROR("Failed to create the nice agent");
 
 	mStreamId = nice_agent_add_stream(mNiceAgent.get(), 1);
 	if (!mStreamId)
-		throw std::runtime_error("Failed to add a stream");
+		RTC_THROW RTC_RUNTIME_ERROR("Failed to add a stream");
 
 	g_object_set(G_OBJECT(mNiceAgent.get()), "controlling-mode", TRUE, nullptr); // decided later
 	g_object_set(G_OBJECT(mNiceAgent.get()), "ice-udp", TRUE, nullptr);
@@ -617,7 +629,7 @@ IceTransport::~IceTransport() {
 
 Description::Role IceTransport::role() const { return mRole; }
 
-Description IceTransport::getLocalDescription(Description::Type type) const {
+RTC_WRAPPED(Description) IceTransport::getLocalDescription(Description::Type type) const {
 	// RFC 8445: The initiating agent that started the ICE processing MUST take the controlling
 	// role, and the other MUST take the controlled role.
 	g_object_set(G_OBJECT(mNiceAgent.get()), "controlling-mode",
@@ -635,13 +647,13 @@ Description IceTransport::getLocalDescription(Description::Type type) const {
 	return desc;
 }
 
-void IceTransport::setRemoteDescription(const Description &description) {
+RTC_WRAPPED(void) IceTransport::setRemoteDescription(const Description &description) {
 	// RFC 5763: The answerer MUST use either a setup attribute value of setup:active or
 	// setup:passive.
 	// See https://www.rfc-editor.org/rfc/rfc5763.html#section-5
 	if (description.type() == Description::Type::Answer &&
 	    description.role() == Description::Role::ActPass)
-		throw std::invalid_argument("Illegal role actpass in remote answer description");
+		RTC_THROW RTC_INVALID_ARGUMENT("Illegal role actpass in remote answer description");
 
 	// RFC 5763: Note that if the answerer uses setup:passive, then the DTLS handshake
 	// will not begin until the answerer is received, which adds additional latency.
@@ -652,7 +664,8 @@ void IceTransport::setRemoteDescription(const Description &description) {
 		                                                        : Description::Role::Active;
 
 	if (mRole == description.role())
-		throw std::invalid_argument("Incompatible roles with remote description");
+		RTC_THROW RTC_INVALID_ARGUMENT("Incompatible roles with remote description");
+		RTC_THROW RTC_INVALID_ARGUMENT("Incompatible roles with remote description");
 
 	mMid = description.bundleMid();
 	mTrickleTimeout = !description.ended() ? 30s : 0s;
@@ -660,11 +673,11 @@ void IceTransport::setRemoteDescription(const Description &description) {
 	// Warning: libnice expects "\n" as end of line
 	if (nice_agent_parse_remote_sdp(mNiceAgent.get(),
 	                                description.generateApplicationSdp("\n").c_str()) < 0)
-		throw std::invalid_argument("Invalid ICE settings from remote SDP");
+		RTC_THROW RTC_INVALID_ARGUMENT("Invalid ICE settings from remote SDP");
 }
 
 bool IceTransport::addRemoteCandidate(const Candidate &candidate) {
-	// Don't try to pass unresolved candidates to libnice for more safety
+	// Don't RTC_TRY to pass unresolved candidates to libnice for more safety
 	if (!candidate.isResolved())
 		return false;
 
@@ -685,14 +698,14 @@ bool IceTransport::addRemoteCandidate(const Candidate &candidate) {
 	return ret > 0;
 }
 
-void IceTransport::gatherLocalCandidates(string mid) {
+RTC_WRAPPED(void) IceTransport::gatherLocalCandidates(string mid) {
 	mMid = std::move(mid);
 
 	// Change state now as candidates calls can be synchronous
 	changeGatheringState(GatheringState::InProgress);
 
 	if (!nice_agent_gather_candidates(mNiceAgent.get(), mStreamId)) {
-		throw std::runtime_error("Failed to gather local ICE candidates");
+		RTC_THROW RTC_RUNTIME_ERROR("Failed to gather local ICE candidates");
 	}
 }
 
@@ -797,10 +810,10 @@ void IceTransport::CandidateCallback(NiceAgent *agent, NiceCandidate *candidate,
                                      gpointer userData) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(userData);
 	gchar *cand = nice_agent_generate_local_candidate_sdp(agent, candidate);
-	try {
+	RTC_TRY {
 		iceTransport->processCandidate(cand);
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 	g_free(cand);
 }
@@ -808,41 +821,41 @@ void IceTransport::CandidateCallback(NiceAgent *agent, NiceCandidate *candidate,
 void IceTransport::GatheringDoneCallback(NiceAgent * /*agent*/, guint /*streamId*/,
                                          gpointer userData) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(userData);
-	try {
+	RTC_TRY {
 		iceTransport->processGatheringDone();
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 void IceTransport::StateChangeCallback(NiceAgent * /*agent*/, guint /*streamId*/,
                                        guint /*componentId*/, guint state, gpointer userData) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(userData);
-	try {
+	RTC_TRY {
 		iceTransport->processStateChange(state);
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 void IceTransport::RecvCallback(NiceAgent * /*agent*/, guint /*streamId*/, guint /*componentId*/,
                                 guint len, gchar *buf, gpointer userData) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(userData);
-	try {
+	RTC_TRY {
 		PLOG_VERBOSE << "Incoming size=" << len;
 		auto b = reinterpret_cast<byte *>(buf);
 		iceTransport->incoming(make_message(b, b + len));
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 gboolean IceTransport::TimeoutCallback(gpointer userData) {
 	auto iceTransport = static_cast<rtc::impl::IceTransport *>(userData);
-	try {
+	RTC_TRY {
 		iceTransport->processTimeout();
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 	return FALSE;
 }
diff --git a/thirdparty/libdatachannel/src/impl/icetransport.hpp b/thirdparty/libdatachannel/src/impl/icetransport.hpp
index 7724e2bdad..8f590cc415 100644
--- a/thirdparty/libdatachannel/src/impl/icetransport.hpp
+++ b/thirdparty/libdatachannel/src/impl/icetransport.hpp
@@ -37,35 +37,36 @@ public:
 
 	enum class GatheringState { New = 0, InProgress = 1, Complete = 2 };
 
-	using candidate_callback = std::function<void(const Candidate &candidate)>;
+	using candidate_callback = std::function<RTC_WRAPPED(void)(const Candidate &candidate)>;
 	using gathering_state_callback = std::function<void(GatheringState state)>;
 
-	IceTransport(const Configuration &config, candidate_callback candidateCallback,
+	IceTransport(candidate_callback candidateCallback,
 	             state_callback stateChangeCallback,
 	             gathering_state_callback gatheringStateChangeCallback);
 	~IceTransport();
 
+	RTC_WRAPPED(void) construct(const Configuration &config);
 	Description::Role role() const;
 	GatheringState gatheringState() const;
-	Description getLocalDescription(Description::Type type) const;
-	void setRemoteDescription(const Description &description);
+	RTC_WRAPPED(Description) getLocalDescription(Description::Type type) const;
+	RTC_WRAPPED(void) setRemoteDescription(const Description &description);
 	bool addRemoteCandidate(const Candidate &candidate);
-	void gatherLocalCandidates(string mid);
+	RTC_WRAPPED(void) gatherLocalCandidates(string mid);
 
 	optional<string> getLocalAddress() const;
 	optional<string> getRemoteAddress() const;
 
-	bool send(message_ptr message) override; // false if dropped
+	RTC_WRAPPED(bool) send(message_ptr message) override; // false if dropped
 
-	bool getSelectedCandidatePair(Candidate *local, Candidate *remote);
+	RTC_WRAPPED(bool) getSelectedCandidatePair(Candidate *local, Candidate *remote);
 
 private:
-	bool outgoing(message_ptr message) override;
+	RTC_WRAPPED(bool) outgoing(message_ptr message) override;
 
 	void changeGatheringState(GatheringState state);
 
 	void processStateChange(unsigned int state);
-	void processCandidate(const string &candidate);
+	RTC_WRAPPED(void) processCandidate(const string &candidate);
 	void processGatheringDone();
 	void processTimeout();
 
diff --git a/thirdparty/libdatachannel/src/impl/init.cpp b/thirdparty/libdatachannel/src/impl/init.cpp
index aad72dd386..609bb536b6 100644
--- a/thirdparty/libdatachannel/src/impl/init.cpp
+++ b/thirdparty/libdatachannel/src/impl/init.cpp
@@ -44,11 +44,11 @@ struct Init::TokenPayload {
 		std::thread t(
 		    [](std::promise<void> promise) {
 			    utils::this_thread::set_name("RTC cleanup");
-			    try {
+			    RTC_TRY {
 				    Init::Instance().doCleanup();
 				    promise.set_value();
-			    } catch (const std::exception &e) {
-				    PLOG_WARNING << e.what();
+			    } RTC_CATCH (const RTC_EXCEPTION &e) {
+				    PLOG_WARNING << e.RTC_WHAT();
 				    promise.set_exception(std::make_exception_ptr(e));
 			    }
 		    },
@@ -96,12 +96,14 @@ std::shared_future<void> Init::cleanup() {
 	return mCleanupFuture;
 }
 
-void Init::setSctpSettings(SctpSettings s) {
+RTC_WRAPPED(void) Init::setSctpSettings(SctpSettings s) {
+	RTC_BEGIN;
 	std::lock_guard lock(mMutex);
 	if (mGlobal)
-		SctpTransport::SetSettings(s);
+		RTC_UNWRAP_RETHROW(SctpTransport::SetSettings(s));
 
 	mCurrentSctpSettings = std::move(s); // store for next init
+	RTC_RET;
 }
 
 void Init::doInit() {
@@ -115,7 +117,7 @@ void Init::doInit() {
 #ifdef _WIN32
 	WSADATA wsaData;
 	if (WSAStartup(MAKEWORD(2, 2), &wsaData))
-		throw std::runtime_error("WSAStartup failed, error=" + std::to_string(WSAGetLastError()));
+		PLOG_ERROR << ("WSAStartup failed, error=" + std::to_string(WSAGetLastError()));
 #endif
 
 	int concurrency = std::thread::hardware_concurrency();
@@ -136,7 +138,11 @@ void Init::doInit() {
 #endif
 
 	SctpTransport::Init();
-	SctpTransport::SetSettings(mCurrentSctpSettings);
+	RTC_TRY {
+		RTC_UNWRAP_CATCH(SctpTransport::SetSettings(mCurrentSctpSettings));
+	} RTC_CATCH(RTC_EXCEPTION e) {
+		PLOG_ERROR << e.RTC_WHAT();
+	}
 	DtlsTransport::Init();
 #if RTC_ENABLE_WEBSOCKET
 	TlsTransport::Init();
diff --git a/thirdparty/libdatachannel/src/impl/init.hpp b/thirdparty/libdatachannel/src/impl/init.hpp
index cd42711ba9..17419713f3 100644
--- a/thirdparty/libdatachannel/src/impl/init.hpp
+++ b/thirdparty/libdatachannel/src/impl/init.hpp
@@ -32,7 +32,7 @@ public:
 	init_token token();
 	void preload();
 	std::shared_future<void> cleanup();
-	void setSctpSettings(SctpSettings s);
+	RTC_WRAPPED(void) setSctpSettings(SctpSettings s);
 
 private:
 	Init();
diff --git a/thirdparty/libdatachannel/src/impl/peerconnection.cpp b/thirdparty/libdatachannel/src/impl/peerconnection.cpp
index 3bd9f9fcc4..4bfd7fba54 100644
--- a/thirdparty/libdatachannel/src/impl/peerconnection.cpp
+++ b/thirdparty/libdatachannel/src/impl/peerconnection.cpp
@@ -49,11 +49,11 @@ PeerConnection::PeerConnection(Configuration config_)
 	PLOG_VERBOSE << "Creating PeerConnection";
 
 	if (config.portRangeEnd && config.portRangeBegin > config.portRangeEnd)
-		throw std::invalid_argument("Invalid port range");
+		PLOG_ERROR << "Invalid port range";
 
 	if (config.mtu) {
 		if (*config.mtu < 576) // Min MTU for IPv4
-			throw std::invalid_argument("Invalid MTU value");
+			PLOG_ERROR << "Invalid MTU value";
 
 		if (*config.mtu > 1500) { // Standard Ethernet
 			PLOG_WARNING << "MTU set to " << *config.mtu;
@@ -121,13 +121,13 @@ size_t PeerConnection::remoteMaxMessageSize() const {
 
 // Helper for PeerConnection::initXTransport methods: start and emplace the transport
 template <typename T>
-shared_ptr<T> emplaceTransport(PeerConnection *pc, shared_ptr<T> *member, shared_ptr<T> transport) {
+static RTC_WRAPPED(shared_ptr<T>) emplaceTransport(PeerConnection *pc, shared_ptr<T> *member, shared_ptr<T> transport) {
 	std::atomic_store(member, transport);
-	try {
-		transport->start();
-	} catch (...) {
+	RTC_TRY {
+		RTC_UNWRAP_CATCH(transport->start());
+	} RTC_CATCH (...) {
 		std::atomic_store(member, decltype(transport)(nullptr));
-		throw;
+		RTC_RETHROW;
 	}
 
 	if (pc->closing.load() || pc->state.load() == PeerConnection::State::Closed) {
@@ -139,15 +139,17 @@ shared_ptr<T> emplaceTransport(PeerConnection *pc, shared_ptr<T> *member, shared
 	return transport;
 }
 
-shared_ptr<IceTransport> PeerConnection::initIceTransport() {
-	try {
+RTC_WRAPPED(shared_ptr<IceTransport>) PeerConnection::initIceTransport() {
+	RTC_TRY {
 		if (auto transport = std::atomic_load(&mIceTransport))
 			return transport;
 
 		PLOG_VERBOSE << "Starting ICE transport";
 
 		auto transport = std::make_shared<IceTransport>(
-		    config, weak_bind(&PeerConnection::processLocalCandidate, this, _1),
+		    [this, weak_this = weak_from_this()](Candidate candidate) -> RTC_WRAPPED(void) {
+				return PeerConnection::processLocalCandidate(candidate);
+			},
 		    [this, weak_this = weak_from_this()](IceTransport::State transportState) {
 			    auto shared_this = weak_this.lock();
 			    if (!shared_this)
@@ -159,7 +161,10 @@ shared_ptr<IceTransport> PeerConnection::initIceTransport() {
 				    break;
 			    case IceTransport::State::Connected:
 				    changeIceState(IceState::Connected);
-				    initDtlsTransport();
+					{ RTC_TRY {
+						RTC_UNWRAP_CATCH(initDtlsTransport());
+					} RTC_CATCH(...) {
+					} }
 				    break;
 			    case IceTransport::State::Completed:
 				    changeIceState(IceState::Completed);
@@ -178,6 +183,7 @@ shared_ptr<IceTransport> PeerConnection::initIceTransport() {
 				    // Ignore
 				    break;
 			    }
+				return;
 		    },
 		    [this, weak_this = weak_from_this()](IceTransport::GatheringState gatheringState) {
 			    auto shared_this = weak_this.lock();
@@ -196,18 +202,19 @@ shared_ptr<IceTransport> PeerConnection::initIceTransport() {
 				    break;
 			    }
 		    });
+		RTC_UNWRAP_CATCH(transport->construct(config));
 
 		return emplaceTransport(this, &mIceTransport, std::move(transport));
 
-	} catch (const std::exception &e) {
-		PLOG_ERROR << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << e.RTC_WHAT();
 		changeState(State::Failed);
-		throw std::runtime_error("ICE transport initialization failed");
+		RTC_THROW RTC_RUNTIME_ERROR("ICE transport initialization failed");
 	}
 }
 
-shared_ptr<DtlsTransport> PeerConnection::initDtlsTransport() {
-	try {
+RTC_WRAPPED(shared_ptr<DtlsTransport>) PeerConnection::initDtlsTransport() {
+	RTC_TRY {
 		if (auto transport = std::atomic_load(&mDtlsTransport))
 			return transport;
 
@@ -215,21 +222,25 @@ shared_ptr<DtlsTransport> PeerConnection::initDtlsTransport() {
 
 		auto lower = std::atomic_load(&mIceTransport);
 		if (!lower)
-			throw std::logic_error("No underlying ICE transport for DTLS transport");
+			RTC_THROW RTC_LOGIC_ERROR("No underlying ICE transport for DTLS transport");
 
-		auto certificate = mCertificate.get();
+		RTC_UNWRAP_CATCH_DECL(certificate_ptr, certificate, mCertificate.get());
 		auto verifierCallback = weak_bind(&PeerConnection::checkFingerprint, this, _1);
 		auto dtlsStateChangeCallback =
-		    [this, weak_this = weak_from_this()](DtlsTransport::State transportState) {
+		    [this, weak_this = weak_from_this()](DtlsTransport::State transportState) -> void {
 			    auto shared_this = weak_this.lock();
 			    if (!shared_this)
 				    return;
 
 			    switch (transportState) {
 			    case DtlsTransport::State::Connected:
-				    if (auto remote = remoteDescription(); remote && remote->hasApplication())
-					    initSctpTransport();
-				    else
+				    if (auto remote = remoteDescription(); remote && remote->hasApplication()) {
+						RTC_TRY {
+							RTC_UNWRAP_CATCH(initSctpTransport());
+						} RTC_CATCH(RTC_EXCEPTION e) {
+							PLOG_ERROR << e.RTC_WHAT();
+						}
+				    } else
 					    changeState(State::Connected);
 
 #if RTC_ENABLE_MEDIA
@@ -248,6 +259,7 @@ shared_ptr<DtlsTransport> PeerConnection::initDtlsTransport() {
 				    // Ignore
 				    break;
 			    }
+			    return;
 		    };
 
 		shared_ptr<DtlsTransport> transport;
@@ -269,19 +281,20 @@ shared_ptr<DtlsTransport> PeerConnection::initDtlsTransport() {
 			// DTLS only
 			transport = std::make_shared<DtlsTransport>(lower, certificate, config.mtu,
 			                                            verifierCallback, dtlsStateChangeCallback);
+			RTC_UNWRAP_CATCH(transport->construct());
 		}
 
 		return emplaceTransport(this, &mDtlsTransport, std::move(transport));
 
-	} catch (const std::exception &e) {
-		PLOG_ERROR << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << e.RTC_WHAT();
 		changeState(State::Failed);
-		throw std::runtime_error("DTLS transport initialization failed");
+		RTC_THROW RTC_RUNTIME_ERROR("DTLS transport initialization failed");
 	}
 }
 
-shared_ptr<SctpTransport> PeerConnection::initSctpTransport() {
-	try {
+RTC_WRAPPED(shared_ptr<SctpTransport>) PeerConnection::initSctpTransport() {
+	RTC_TRY {
 		if (auto transport = std::atomic_load(&mSctpTransport))
 			return transport;
 
@@ -289,15 +302,15 @@ shared_ptr<SctpTransport> PeerConnection::initSctpTransport() {
 
 		auto lower = std::atomic_load(&mDtlsTransport);
 		if (!lower)
-			throw std::logic_error("No underlying DTLS transport for SCTP transport");
+			RTC_THROW RTC_LOGIC_ERROR("No underlying DTLS transport for SCTP transport");
 
 		auto local = localDescription();
 		if (!local || !local->application())
-			throw std::logic_error("Starting SCTP transport without local application description");
+			RTC_THROW RTC_LOGIC_ERROR("Starting SCTP transport without local application description");
 
 		auto remote = remoteDescription();
 		if (!remote || !remote->application())
-			throw std::logic_error(
+			RTC_THROW RTC_LOGIC_ERROR(
 			    "Starting SCTP transport without remote application description");
 
 		SctpTransport::Ports ports = {};
@@ -305,7 +318,17 @@ shared_ptr<SctpTransport> PeerConnection::initSctpTransport() {
 		ports.remote = remote->application()->sctpPort().value_or(DEFAULT_SCTP_PORT);
 
 		auto transport = std::make_shared<SctpTransport>(
-		    lower, config, std::move(ports), weak_bind(&PeerConnection::forwardMessage, this, _1),
+		    lower, std::move(ports),
+			[this, weak_this = weak_from_this()](message_ptr message) {
+			    auto shared_this = weak_this.lock();
+			    if (!shared_this)
+				    return;
+				RTC_TRY {
+					RTC_UNWRAP_CATCH(shared_this->forwardMessage(message));
+				} RTC_CATCH(RTC_EXCEPTION e) {
+					PLOG_WARNING << e.RTC_WHAT(); // FIXME
+				}
+			},
 		    weak_bind(&PeerConnection::forwardBufferedAmount, this, _1, _2),
 		    [this, weak_this = weak_from_this()](SctpTransport::State transportState) {
 			    auto shared_this = weak_this.lock();
@@ -315,7 +338,10 @@ shared_ptr<SctpTransport> PeerConnection::initSctpTransport() {
 			    switch (transportState) {
 			    case SctpTransport::State::Connected:
 				    changeState(State::Connected);
-				    assignDataChannels();
+					{ RTC_TRY {
+						RTC_UNWRAP_CATCH(assignDataChannels());
+					} RTC_CATCH(...) {
+					} }
 				    mProcessor.enqueue(&PeerConnection::openDataChannels, shared_from_this());
 				    break;
 			    case SctpTransport::State::Failed:
@@ -331,13 +357,13 @@ shared_ptr<SctpTransport> PeerConnection::initSctpTransport() {
 				    break;
 			    }
 		    });
-
+		RTC_UNWRAP_CATCH(transport->construct(config));
 		return emplaceTransport(this, &mSctpTransport, std::move(transport));
 
-	} catch (const std::exception &e) {
-		PLOG_ERROR << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << e.RTC_WHAT();
 		changeState(State::Failed);
-		throw std::runtime_error("SCTP transport initialization failed");
+		RTC_THROW RTC_RUNTIME_ERROR("SCTP transport initialization failed");
 	}
 }
 
@@ -434,16 +460,17 @@ bool PeerConnection::checkFingerprint(const std::string &fingerprint) const {
 	return false;
 }
 
-void PeerConnection::forwardMessage(message_ptr message) {
+RTC_WRAPPED(void) PeerConnection::forwardMessage(message_ptr message) {
+	RTC_BEGIN;
 	if (!message) {
 		remoteCloseDataChannels();
-		return;
+		RTC_RET;
 	}
 
 	auto iceTransport = std::atomic_load(&mIceTransport);
 	auto sctpTransport = std::atomic_load(&mSctpTransport);
 	if (!iceTransport || !sctpTransport)
-		return;
+		RTC_RET;
 
 	const uint16_t stream = uint16_t(message->stream);
 	auto [channel, found] = findDataChannel(stream);
@@ -457,7 +484,7 @@ void PeerConnection::forwardMessage(message_ptr message) {
 			else
 				sctpTransport->closeStream(message->stream);
 
-			return;
+			RTC_RET;
 		}
 
 		const uint16_t remoteParity = (iceTransport->role() == Description::Role::Active) ? 1 : 0;
@@ -465,11 +492,11 @@ void PeerConnection::forwardMessage(message_ptr message) {
 			// The odd/even rule is violated, the receiver must close the DataChannel
 			PLOG_WARNING << "Got open message violating the odd/even rule on stream " << stream;
 			sctpTransport->closeStream(message->stream);
-			return;
+			RTC_RET;
 		}
 
 		channel = std::make_shared<IncomingDataChannel>(weak_from_this(), sctpTransport);
-		channel->assignStream(stream);
+		RTC_UNWRAP_RETHROW(channel->assignStream(stream));
 		channel->openCallback =
 		    weak_bind(&PeerConnection::triggerDataChannel, this, weak_ptr<DataChannel>{channel});
 
@@ -477,12 +504,12 @@ void PeerConnection::forwardMessage(message_ptr message) {
 		mDataChannels.emplace(stream, channel);
 	} else if (!found) {
 		if (message->type == Message::Reset)
-			return; // ignore
+			RTC_RET; // ignore
 
 		// Invalid, close the DataChannel
 		PLOG_WARNING << "Got unexpected message on stream " << stream;
 		sctpTransport->closeStream(message->stream);
-		return;
+		RTC_RET;
 	}
 
 	if (message->type == Message::Reset) {
@@ -492,11 +519,12 @@ void PeerConnection::forwardMessage(message_ptr message) {
 
 	if (channel) {
 		// Forward the message
-		channel->incoming(message);
+		RTC_UNWRAP_RETHROW(channel->incoming(message));
 	} else {
 		// DataChannel was destroyed, ignore
 		PLOG_DEBUG << "Ignored message on stream " << stream << ", DataChannel is destroyed";
 	}
+	RTC_RET;
 }
 
 void PeerConnection::forwardMedia(message_ptr message) {
@@ -597,7 +625,8 @@ void PeerConnection::forwardBufferedAmount(uint16_t stream, size_t amount) {
 		channel->triggerBufferedAmount(amount);
 }
 
-shared_ptr<DataChannel> PeerConnection::emplaceDataChannel(string label, DataChannelInit init) {
+RTC_WRAPPED(shared_ptr<DataChannel>) PeerConnection::emplaceDataChannel(string label, DataChannelInit init) {
+	RTC_BEGIN;
 	std::unique_lock lock(mDataChannelsMutex); // we are going to emplace
 
 	// If the DataChannel is user-negotiated, do not negotiate it in-band
@@ -613,9 +642,9 @@ shared_ptr<DataChannel> PeerConnection::emplaceDataChannel(string label, DataCha
 	if (init.id) {
 		uint16_t stream = *init.id;
 		if (stream > maxDataChannelStream())
-			throw std::invalid_argument("DataChannel stream id is too high");
+			RTC_THROW RTC_INVALID_ARGUMENT("DataChannel stream id is too high");
 
-		channel->assignStream(stream);
+		RTC_UNWRAP_RETHROW(channel->assignStream(stream));
 		mDataChannels.emplace(std::make_pair(stream, channel));
 
 	} else {
@@ -627,8 +656,8 @@ shared_ptr<DataChannel> PeerConnection::emplaceDataChannel(string label, DataCha
 	// If SCTP is connected, assign and open now
 	auto sctpTransport = std::atomic_load(&mSctpTransport);
 	if (sctpTransport && sctpTransport->state() == SctpTransport::State::Connected) {
-		assignDataChannels();
-		channel->open(sctpTransport);
+		RTC_UNWRAP_RETHROW(assignDataChannels());
+		RTC_UNWRAP_RETHROW(channel->open(sctpTransport));
 	}
 
 	return channel;
@@ -652,12 +681,13 @@ uint16_t PeerConnection::maxDataChannelStream() const {
 	return sctpTransport ? sctpTransport->maxStream() : (MAX_SCTP_STREAMS_COUNT - 1);
 }
 
-void PeerConnection::assignDataChannels() {
+RTC_WRAPPED(void) PeerConnection::assignDataChannels() {
+	RTC_BEGIN;
 	std::unique_lock lock(mDataChannelsMutex); // we are going to emplace
 
 	auto iceTransport = std::atomic_load(&mIceTransport);
 	if (!iceTransport)
-		throw std::logic_error("Attempted to assign DataChannels without ICE transport");
+		RTC_THROW RTC_LOGIC_ERROR("Attempted to assign DataChannels without ICE transport");
 
 	const uint16_t maxStream = maxDataChannelStream();
 	for (auto it = mUnassignedDataChannels.begin(); it != mUnassignedDataChannels.end(); ++it) {
@@ -673,7 +703,7 @@ void PeerConnection::assignDataChannels() {
 		uint16_t stream = (iceTransport->role() == Description::Role::Active) ? 0 : 1;
 		while (true) {
 			if (stream > maxStream)
-				throw std::runtime_error("Too many DataChannels");
+				RTC_THROW RTC_RUNTIME_ERROR("Too many DataChannels");
 
 			if (mDataChannels.find(stream) == mDataChannels.end())
 				break;
@@ -683,15 +713,16 @@ void PeerConnection::assignDataChannels() {
 
 		PLOG_DEBUG << "Assigning stream " << stream << " to DataChannel";
 
-		channel->assignStream(stream);
+		RTC_UNWRAP_RETHROW(channel->assignStream(stream));
 		mDataChannels.emplace(std::make_pair(stream, channel));
 	}
 
 	mUnassignedDataChannels.clear();
+	RTC_RET;
 }
 
 void PeerConnection::iterateDataChannels(
-    std::function<void(shared_ptr<DataChannel> channel)> func) {
+    std::function<RTC_WRAPPED(void)(shared_ptr<DataChannel> channel)> func) {
 	std::vector<shared_ptr<DataChannel>> locked;
 	{
 		std::shared_lock lock(mDataChannelsMutex); // read-only
@@ -707,10 +738,10 @@ void PeerConnection::iterateDataChannels(
 	}
 
 	for (auto &channel : locked) {
-		try {
-			func(std::move(channel));
-		} catch (const std::exception &e) {
-			PLOG_WARNING << e.what();
+		RTC_TRY {
+			RTC_UNWRAP_CATCH(func(std::move(channel)));
+		} RTC_CATCH (const RTC_EXCEPTION &e) {
+			PLOG_WARNING << e.RTC_WHAT();
 		}
 	}
 }
@@ -719,16 +750,17 @@ void PeerConnection::openDataChannels() {
 	if (auto transport = std::atomic_load(&mSctpTransport))
 		iterateDataChannels([&](shared_ptr<DataChannel> channel) {
 			if (!channel->isOpen())
-				channel->open(transport);
+				return channel->open(transport);
+			RTC_RET;
 		});
 }
 
 void PeerConnection::closeDataChannels() {
-	iterateDataChannels([&](shared_ptr<DataChannel> channel) { channel->close(); });
+	iterateDataChannels([&](shared_ptr<DataChannel> channel) { channel->close(); RTC_RET; });
 }
 
 void PeerConnection::remoteCloseDataChannels() {
-	iterateDataChannels([&](shared_ptr<DataChannel> channel) { channel->remoteClose(); });
+	iterateDataChannels([&](shared_ptr<DataChannel> channel) { channel->remoteClose(); RTC_RET; });
 }
 
 #if RTC_ENABLE_MEDIA
@@ -761,10 +793,10 @@ void PeerConnection::iterateTracks(std::function<void(shared_ptr<Track> track)>
 	for (auto it = mTrackLines.begin(); it != mTrackLines.end(); ++it) {
 		auto track = it->lock();
 		if (track && !track->isClosed()) {
-			try {
+			RTC_TRY {
 				func(std::move(track));
-			} catch (const std::exception &e) {
-				PLOG_WARNING << e.what();
+			} RTC_CATCH (const RTC_EXCEPTION &e) {
+				PLOG_WARNING << e.RTC_WHAT();
 			}
 		}
 	}
@@ -798,21 +830,23 @@ void PeerConnection::closeTracks() {
 }
 #endif
 
-void PeerConnection::validateRemoteDescription(const Description &description) {
+RTC_WRAPPED(void) PeerConnection::validateRemoteDescription(const Description &description) {
+	RTC_BEGIN;
 	if (!description.iceUfrag())
-		throw std::invalid_argument("Remote description has no ICE user fragment");
+		RTC_THROW RTC_INVALID_ARGUMENT("Remote description has no ICE user fragment");
 
 	if (!description.icePwd())
-		throw std::invalid_argument("Remote description has no ICE password");
+		RTC_THROW RTC_INVALID_ARGUMENT("Remote description has no ICE password");
 
 	if (!description.fingerprint())
-		throw std::invalid_argument("Remote description has no valid fingerprint");
+		RTC_THROW RTC_INVALID_ARGUMENT("Remote description has no valid fingerprint");
 
 	if (description.mediaCount() == 0)
-		throw std::invalid_argument("Remote description has no media line");
+		RTC_THROW RTC_INVALID_ARGUMENT("Remote description has no media line");
 
 	int activeMediaCount = 0;
-	for (unsigned int i = 0; i < description.mediaCount(); ++i)
+	for (unsigned int i = 0; i < description.mediaCount(); ++i) {
+		RTC_UNWRAP_RETHROW_DECL(auto, media, description.media(i));
 		std::visit(rtc::overloaded{[&](const Description::Application *application) {
 			                           if (!application->isRemoved())
 				                           ++activeMediaCount;
@@ -822,20 +856,23 @@ void PeerConnection::validateRemoteDescription(const Description &description) {
 			                               media->direction() != Description::Direction::Inactive)
 				                           ++activeMediaCount;
 		                           }},
-		           description.media(i));
+					media);
+	}
 
 	if (activeMediaCount == 0)
-		throw std::invalid_argument("Remote description has no active media");
+		RTC_THROW RTC_INVALID_ARGUMENT("Remote description has no active media");
 
 	if (auto local = localDescription(); local && local->iceUfrag() && local->icePwd())
 		if (*description.iceUfrag() == *local->iceUfrag() &&
 		    *description.icePwd() == *local->icePwd())
-			throw std::logic_error("Got the local description as remote description");
+			RTC_THROW RTC_LOGIC_ERROR("Got the local description as remote description");
 
 	PLOG_VERBOSE << "Remote description looks valid";
+	RTC_RET;
 }
 
-void PeerConnection::processLocalDescription(Description description) {
+RTC_WRAPPED(void) PeerConnection::processLocalDescription(Description description) {
+	RTC_BEGIN;
 	const uint16_t localSctpPort = DEFAULT_SCTP_PORT;
 	const size_t localMaxMessageSize =
 	    config.maxMessageSize.value_or(DEFAULT_LOCAL_MAX_MESSAGE_SIZE);
@@ -845,7 +882,8 @@ void PeerConnection::processLocalDescription(Description description) {
 
 	if (auto remote = remoteDescription()) {
 		// Reciprocate remote description
-		for (unsigned int i = 0; i < remote->mediaCount(); ++i)
+		for (unsigned int i = 0; i < remote->mediaCount(); ++i) {
+			RTC_UNWRAP_RETHROW_DECL(auto, remote_media, remote->media(i));
 			std::visit( // reciprocate each media
 			    rtc::overloaded{
 			        [&](Description::Application *remoteApp) {
@@ -926,7 +964,8 @@ void PeerConnection::processLocalDescription(Description description) {
 #endif
 			        },
 			    },
-			    remote->media(i));
+			    remote_media);
+		}
 
 		// We need to update the SSRC cache for newly-created incoming tracks
 		updateTrackSsrcCache(*remote);
@@ -975,16 +1014,17 @@ void PeerConnection::processLocalDescription(Description description) {
 		// There might be no media at this point if the user created a Track, deleted it,
 		// then called setLocalDescription().
 		if (description.mediaCount() == 0)
-			throw std::runtime_error("No DataChannel or Track to negotiate");
+			RTC_THROW RTC_RUNTIME_ERROR("No DataChannel or Track to negotiate");
 	}
 
 	// Set local fingerprint (wait for certificate if necessary)
-	description.setFingerprint(mCertificate.get()->fingerprint());
+	RTC_UNWRAP_RETHROW_DECL(certificate_ptr, certificate, mCertificate.get());
+	RTC_UNWRAP_RETHROW(description.setFingerprint(certificate->fingerprint()));
 
 	PLOG_VERBOSE << "Issuing local description: " << description;
 
 	if (description.mediaCount() == 0)
-		throw std::logic_error("Local description has no media line");
+		RTC_THROW RTC_LOGIC_ERROR("Local description has no media line");
 
 	updateTrackSsrcCache(description);
 
@@ -1011,17 +1051,18 @@ void PeerConnection::processLocalDescription(Description description) {
 	    dtlsTransport && dtlsTransport->state() == Transport::State::Connected)
 		mProcessor.enqueue(&PeerConnection::openTracks, shared_from_this());
 #endif
+	RTC_RET;
 }
 
-void PeerConnection::processLocalCandidate(Candidate candidate) {
+RTC_WRAPPED(void) PeerConnection::processLocalCandidate(Candidate candidate) {
 	std::lock_guard lock(mLocalDescriptionMutex);
 	if (!mLocalDescription)
-		throw std::logic_error("Got a local candidate without local description");
+		RTC_THROW RTC_LOGIC_ERROR("Got a local candidate without local description");
 
 	if (config.iceTransportPolicy == TransportPolicy::Relay &&
 	    candidate.type() != Candidate::Type::Relayed) {
 		PLOG_VERBOSE << "Not issuing local candidate because of transport policy: " << candidate;
-		return;
+		RTC_RET;
 	}
 
 	PLOG_VERBOSE << "Issuing local candidate: " << candidate;
@@ -1031,9 +1072,11 @@ void PeerConnection::processLocalCandidate(Candidate candidate) {
 
 	mProcessor.enqueue(&PeerConnection::trigger<Candidate>, shared_from_this(),
 	                   &localCandidateCallback, std::move(candidate));
+	RTC_RET;
 }
 
-void PeerConnection::processRemoteDescription(Description description) {
+RTC_WRAPPED(void) PeerConnection::processRemoteDescription(Description description) {
+	RTC_BEGIN;
 	// Update the SSRC cache for existing tracks
 	updateTrackSsrcCache(description);
 
@@ -1054,27 +1097,28 @@ void PeerConnection::processRemoteDescription(Description description) {
 		auto sctpTransport = std::atomic_load(&mSctpTransport);
 		if (!sctpTransport && dtlsTransport &&
 		    dtlsTransport->state() == Transport::State::Connected)
-			initSctpTransport();
+			RTC_UNWRAP_RETHROW(initSctpTransport());
 	} else {
 		mProcessor.enqueue(&PeerConnection::remoteCloseDataChannels, shared_from_this());
 	}
+	RTC_RET;
 }
 
-void PeerConnection::processRemoteCandidate(Candidate candidate) {
+RTC_WRAPPED(void) PeerConnection::processRemoteCandidate(Candidate candidate) {
 	auto iceTransport = std::atomic_load(&mIceTransport);
 	{
 		// Set as remote candidate
 		std::lock_guard lock(mRemoteDescriptionMutex);
 		if (!mRemoteDescription)
-			throw std::logic_error("Got a remote candidate without remote description");
+			RTC_THROW RTC_LOGIC_ERROR("Got a remote candidate without remote description");
 
 		if (!iceTransport)
-			throw std::logic_error("Got a remote candidate without ICE transport");
+			RTC_THROW RTC_LOGIC_ERROR("Got a remote candidate without ICE transport");
 
 		candidate.hintMid(mRemoteDescription->bundleMid());
 
 		if (mRemoteDescription->hasCandidate(candidate))
-			return; // already in description, ignore
+			RTC_RET; // already in description, ignore
 
 		candidate.resolve(Candidate::ResolveMode::Simple);
 		mRemoteDescription->addCandidate(candidate);
@@ -1096,6 +1140,7 @@ void PeerConnection::processRemoteCandidate(Candidate candidate) {
 			t.detach();
 		}
 	}
+	RTC_RET;
 }
 
 string PeerConnection::localBundleMid() const {
@@ -1145,10 +1190,10 @@ void PeerConnection::triggerPendingDataChannels() {
 
 		auto impl = std::move(*next);
 
-		try {
+		RTC_TRY {
 			dataChannelCallback(std::make_shared<rtc::DataChannel>(impl));
-		} catch (const std::exception &e) {
-			PLOG_WARNING << "Uncaught exception in callback: " << e.what();
+		} RTC_CATCH (const RTC_EXCEPTION &e) {
+			PLOG_WARNING << "Uncaught exception in callback: " << e.RTC_WHAT();
 		}
 
 		impl->triggerOpen();
@@ -1164,10 +1209,10 @@ void PeerConnection::triggerPendingTracks() {
 
 		auto impl = std::move(*next);
 
-		try {
+		RTC_TRY {
 			trackCallback(std::make_shared<rtc::Track>(impl));
-		} catch (const std::exception &e) {
-			PLOG_WARNING << "Uncaught exception in callback: " << e.what();
+		} RTC_CATCH (const RTC_EXCEPTION &e) {
+			PLOG_WARNING << "Uncaught exception in callback: " << e.RTC_WHAT();
 		}
 
 		// Do not trigger open immediately for tracks as it'll be done later
diff --git a/thirdparty/libdatachannel/src/impl/peerconnection.hpp b/thirdparty/libdatachannel/src/impl/peerconnection.hpp
index 47fd4dc071..facf07d744 100644
--- a/thirdparty/libdatachannel/src/impl/peerconnection.hpp
+++ b/thirdparty/libdatachannel/src/impl/peerconnection.hpp
@@ -43,9 +43,9 @@ struct PeerConnection : std::enable_shared_from_this<PeerConnection> {
 	optional<Description> remoteDescription() const;
 	size_t remoteMaxMessageSize() const;
 
-	shared_ptr<IceTransport> initIceTransport();
-	shared_ptr<DtlsTransport> initDtlsTransport();
-	shared_ptr<SctpTransport> initSctpTransport();
+	RTC_WRAPPED(shared_ptr<IceTransport>) initIceTransport();
+	RTC_WRAPPED(shared_ptr<DtlsTransport>) initDtlsTransport();
+	RTC_WRAPPED(shared_ptr<SctpTransport>) initSctpTransport();
 	shared_ptr<IceTransport> getIceTransport() const;
 	shared_ptr<DtlsTransport> getDtlsTransport() const;
 	shared_ptr<SctpTransport> getSctpTransport() const;
@@ -54,16 +54,16 @@ struct PeerConnection : std::enable_shared_from_this<PeerConnection> {
 	void endLocalCandidates();
 	void rollbackLocalDescription();
 	bool checkFingerprint(const std::string &fingerprint) const;
-	void forwardMessage(message_ptr message);
+	RTC_WRAPPED(void) forwardMessage(message_ptr message);
 	void forwardMedia(message_ptr message);
 	void forwardBufferedAmount(uint16_t stream, size_t amount);
 
-	shared_ptr<DataChannel> emplaceDataChannel(string label, DataChannelInit init);
+	RTC_WRAPPED(shared_ptr<DataChannel>) emplaceDataChannel(string label, DataChannelInit init);
 	std::pair<shared_ptr<DataChannel>, bool> findDataChannel(uint16_t stream);
 	bool removeDataChannel(uint16_t stream);
 	uint16_t maxDataChannelStream() const;
-	void assignDataChannels();
-	void iterateDataChannels(std::function<void(shared_ptr<DataChannel> channel)> func);
+	RTC_WRAPPED(void) assignDataChannels();
+	void iterateDataChannels(std::function<RTC_WRAPPED(void)(shared_ptr<DataChannel> channel)> func);
 	void openDataChannels();
 	void closeDataChannels();
 	void remoteCloseDataChannels();
@@ -75,11 +75,11 @@ struct PeerConnection : std::enable_shared_from_this<PeerConnection> {
 	void closeTracks();
 #endif
 
-	void validateRemoteDescription(const Description &description);
-	void processLocalDescription(Description description);
-	void processLocalCandidate(Candidate candidate);
-	void processRemoteDescription(Description description);
-	void processRemoteCandidate(Candidate candidate);
+	RTC_WRAPPED(void) validateRemoteDescription(const Description &description);
+	RTC_WRAPPED(void) processLocalDescription(Description description);
+	RTC_WRAPPED(void) processLocalCandidate(Candidate candidate);
+	RTC_WRAPPED(void) processRemoteDescription(Description description);
+	RTC_WRAPPED(void) processRemoteCandidate(Candidate candidate);
 	string localBundleMid() const;
 
 #if RTC_ENABLE_MEDIA
diff --git a/thirdparty/libdatachannel/src/impl/sctptransport.cpp b/thirdparty/libdatachannel/src/impl/sctptransport.cpp
index 5071c89f0b..424218f123 100644
--- a/thirdparty/libdatachannel/src/impl/sctptransport.cpp
+++ b/thirdparty/libdatachannel/src/impl/sctptransport.cpp
@@ -52,20 +52,20 @@ using namespace std::chrono;
 
 namespace {
 
-template <typename T> uint16_t to_uint16(T i) {
+template <typename T> RTC_WRAPPED(uint16_t) to_uint16(T i) {
 	if (i >= 0 && static_cast<typename std::make_unsigned<T>::type>(i) <=
 	                  std::numeric_limits<uint16_t>::max())
 		return static_cast<uint16_t>(i);
 	else
-		throw std::invalid_argument("Integer out of range");
+		RTC_THROW RTC_INVALID_ARGUMENT("Integer out of range");
 }
 
-template <typename T> uint32_t to_uint32(T i) {
+template <typename T> RTC_WRAPPED(uint32_t) to_uint32(T i) {
 	if (i >= 0 && static_cast<typename std::make_unsigned<T>::type>(i) <=
 	                  std::numeric_limits<uint32_t>::max())
 		return static_cast<uint32_t>(i);
 	else
-		throw std::invalid_argument("Integer out of range");
+		RTC_THROW RTC_INVALID_ARGUMENT("Integer out of range");
 }
 
 } // namespace
@@ -110,53 +110,55 @@ void SctpTransport::Init() {
 #endif
 }
 
-void SctpTransport::SetSettings(const SctpSettings &s) {
+RTC_WRAPPED(void) SctpTransport::SetSettings(const SctpSettings &s) {
+	RTC_BEGIN;
 	// The send and receive window size of usrsctp is 256KiB, which is too small for realistic RTTs,
 	// therefore we increase it to 1MiB by default for better performance.
 	// See https://bugzilla.mozilla.org/show_bug.cgi?id=1051685
-	usrsctp_sysctl_set_sctp_recvspace(to_uint32(s.recvBufferSize.value_or(1024 * 1024)));
-	usrsctp_sysctl_set_sctp_sendspace(to_uint32(s.sendBufferSize.value_or(1024 * 1024)));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_recvspace, to_uint32(s.recvBufferSize.value_or(1024 * 1024)));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_sendspace, to_uint32(s.sendBufferSize.value_or(1024 * 1024)));
 
 	// Increase maximum chunks number on queue to 10K by default
-	usrsctp_sysctl_set_sctp_max_chunks_on_queue(to_uint32(s.maxChunksOnQueue.value_or(10 * 1024)));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_max_chunks_on_queue, to_uint32(s.maxChunksOnQueue.value_or(10 * 1024)));
 
 	// Increase initial congestion window size to 10 MTUs (RFC 6928) by default
-	usrsctp_sysctl_set_sctp_initial_cwnd(to_uint32(s.initialCongestionWindow.value_or(10)));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_initial_cwnd, to_uint32(s.initialCongestionWindow.value_or(10)));
 
 	// Set max burst to 10 MTUs by default (max burst is initially 0, meaning disabled)
-	usrsctp_sysctl_set_sctp_max_burst_default(to_uint32(s.maxBurst.value_or(10)));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_max_burst_default, to_uint32(s.maxBurst.value_or(10)));
 
 	// Use standard SCTP congestion control (RFC 4960) by default
 	// See https://github.com/paullouisageneau/libdatachannel/issues/354
-	usrsctp_sysctl_set_sctp_default_cc_module(to_uint32(s.congestionControlModule.value_or(0)));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_default_cc_module, to_uint32(s.congestionControlModule.value_or(0)));
 
 	// Reduce SACK delay to 20ms by default (the recommended default value from RFC 4960 is 200ms)
-	usrsctp_sysctl_set_sctp_delayed_sack_time_default(
-	    to_uint32(s.delayedSackTime.value_or(20ms).count()));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_delayed_sack_time_default,
+			to_uint32(s.delayedSackTime.value_or(20ms).count()));
 
 	// RTO settings
 	// RFC 2988 recommends a 1s min RTO, which is very high, but TCP on Linux has a 200ms min RTO
-	usrsctp_sysctl_set_sctp_rto_min_default(
-	    to_uint32(s.minRetransmitTimeout.value_or(200ms).count()));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_rto_min_default,
+			to_uint32(s.minRetransmitTimeout.value_or(200ms).count()));
 	// Set only 10s as max RTO instead of 60s for shorter connection timeout
-	usrsctp_sysctl_set_sctp_rto_max_default(
-	    to_uint32(s.maxRetransmitTimeout.value_or(10000ms).count()));
-	usrsctp_sysctl_set_sctp_init_rto_max_default(
-	    to_uint32(s.maxRetransmitTimeout.value_or(10000ms).count()));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_rto_max_default,
+			to_uint32(s.maxRetransmitTimeout.value_or(10000ms).count()));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_init_rto_max_default,
+			to_uint32(s.maxRetransmitTimeout.value_or(10000ms).count()));
 	// Still set 1s as initial RTO
-	usrsctp_sysctl_set_sctp_rto_initial_default(
-	    to_uint32(s.initialRetransmitTimeout.value_or(1000ms).count()));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_rto_initial_default,
+			to_uint32(s.initialRetransmitTimeout.value_or(1000ms).count()));
 
 	// RTX settings
 	// 5 retransmissions instead of 8 to shorten the backoff for shorter connection timeout
-	auto maxRtx = to_uint32(s.maxRetransmitAttempts.value_or(5));
+	RTC_UNWRAP_RETHROW_DECL(auto, maxRtx, to_uint32(s.maxRetransmitAttempts.value_or(5)));
 	usrsctp_sysctl_set_sctp_init_rtx_max_default(maxRtx);
 	usrsctp_sysctl_set_sctp_assoc_rtx_max_default(maxRtx);
 	usrsctp_sysctl_set_sctp_path_rtx_max_default(maxRtx); // single path
 
 	// Heartbeat interval
-	usrsctp_sysctl_set_sctp_heartbeat_interval_default(
-	    to_uint32(s.heartbeatInterval.value_or(10000ms).count()));
+	RTC_UNWRAP_RETHROW_ARG(usrsctp_sysctl_set_sctp_heartbeat_interval_default,
+			to_uint32(s.heartbeatInterval.value_or(10000ms).count()));
+	RTC_RET;
 }
 
 void SctpTransport::Cleanup() {
@@ -164,41 +166,44 @@ void SctpTransport::Cleanup() {
 		std::this_thread::sleep_for(100ms);
 }
 
-SctpTransport::SctpTransport(shared_ptr<Transport> lower, const Configuration &config, Ports ports,
+SctpTransport::SctpTransport(shared_ptr<Transport> lower, Ports ports,
                              message_callback recvCallback, amount_callback bufferedAmountCallback,
                              state_callback stateChangeCallback)
     : Transport(lower, std::move(stateChangeCallback)), mPorts(std::move(ports)),
       mSendQueue(0, message_size_func), mBufferedAmountCallback(std::move(bufferedAmountCallback)) {
 	onRecv(std::move(recvCallback));
+}
 
+RTC_WRAPPED(void) SctpTransport::construct(const Configuration &config) {
+	RTC_BEGIN;
 	PLOG_DEBUG << "Initializing SCTP transport";
 
 	mSock = usrsctp_socket(AF_CONN, SOCK_STREAM, IPPROTO_SCTP, nullptr, nullptr, 0, nullptr);
 	if (!mSock)
-		throw std::runtime_error("Could not create SCTP socket, errno=" + std::to_string(errno));
+		RTC_THROW RTC_RUNTIME_ERROR("Could not create SCTP socket, errno=" + std::to_string(errno));
 
 	usrsctp_set_upcall(mSock, &SctpTransport::UpcallCallback, this);
 
 	if (usrsctp_set_non_blocking(mSock, 1))
-		throw std::runtime_error("Unable to set non-blocking mode, errno=" + std::to_string(errno));
+		RTC_THROW RTC_RUNTIME_ERROR("Unable to set non-blocking mode, errno=" + std::to_string(errno));
 
 	// SCTP must stop sending after the lower layer is shut down, so disable linger
 	struct linger sol = {};
 	sol.l_onoff = 1;
 	sol.l_linger = 0;
 	if (usrsctp_setsockopt(mSock, SOL_SOCKET, SO_LINGER, &sol, sizeof(sol)))
-		throw std::runtime_error("Could not set socket option SO_LINGER, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not set socket option SO_LINGER, errno=" +
 		                         std::to_string(errno));
 
 	struct sctp_assoc_value av = {};
 	av.assoc_id = SCTP_ALL_ASSOC;
 	av.assoc_value = 1;
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_ENABLE_STREAM_RESET, &av, sizeof(av)))
-		throw std::runtime_error("Could not set socket option SCTP_ENABLE_STREAM_RESET, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not set socket option SCTP_ENABLE_STREAM_RESET, errno=" +
 		                         std::to_string(errno));
 	int on = 1;
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_RECVRCVINFO, &on, sizeof(on)))
-		throw std::runtime_error("Could set socket option SCTP_RECVRCVINFO, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could set socket option SCTP_RECVRCVINFO, errno=" +
 		                         std::to_string(errno));
 
 	struct sctp_event se = {};
@@ -206,15 +211,15 @@ SctpTransport::SctpTransport(shared_ptr<Transport> lower, const Configuration &c
 	se.se_on = 1;
 	se.se_type = SCTP_ASSOC_CHANGE;
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_EVENT, &se, sizeof(se)))
-		throw std::runtime_error("Could not subscribe to event SCTP_ASSOC_CHANGE, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not subscribe to event SCTP_ASSOC_CHANGE, errno=" +
 		                         std::to_string(errno));
 	se.se_type = SCTP_SENDER_DRY_EVENT;
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_EVENT, &se, sizeof(se)))
-		throw std::runtime_error("Could not subscribe to event SCTP_SENDER_DRY_EVENT, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not subscribe to event SCTP_SENDER_DRY_EVENT, errno=" +
 		                         std::to_string(errno));
 	se.se_type = SCTP_STREAM_RESET_EVENT;
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_EVENT, &se, sizeof(se)))
-		throw std::runtime_error("Could not subscribe to event SCTP_STREAM_RESET_EVENT, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not subscribe to event SCTP_STREAM_RESET_EVENT, errno=" +
 		                         std::to_string(errno));
 
 	// RFC 8831 6.6. Transferring User Data on a Data Channel
@@ -222,7 +227,7 @@ SctpTransport::SctpTransport(shared_ptr<Transport> lower, const Configuration &c
 	// See https://www.rfc-editor.org/rfc/rfc8831.html#section-6.6
 	int nodelay = 1;
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_NODELAY, &nodelay, sizeof(nodelay)))
-		throw std::runtime_error("Could not set socket option SCTP_NODELAY, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not set socket option SCTP_NODELAY, errno=" +
 		                         std::to_string(errno));
 
 	struct sctp_paddrparams spp = {};
@@ -252,12 +257,12 @@ SctpTransport::SctpTransport(shared_ptr<Transport> lower, const Configuration &c
 		// The MTU value provided specifies the space available for chunks in the
 		// packet, so we also subtract the SCTP header size.
 		size_t pmtu = config.mtu.value_or(DEFAULT_MTU) - 12 - 48 - 8 - 40; // SCTP/DTLS/UDP/IPv6
-		spp.spp_pathmtu = to_uint32(pmtu);
+		RTC_UNWRAP_RETHROW_VAR(spp.spp_pathmtu, to_uint32(pmtu));
 		PLOG_VERBOSE << "Path MTU discovery disabled, SCTP MTU set to " << pmtu;
 	}
 
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_PEER_ADDR_PARAMS, &spp, sizeof(spp)))
-		throw std::runtime_error("Could not set socket option SCTP_PEER_ADDR_PARAMS, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not set socket option SCTP_PEER_ADDR_PARAMS, errno=" +
 		                         std::to_string(errno));
 
 	// RFC 8831 6.2. SCTP Association Management
@@ -271,7 +276,7 @@ SctpTransport::SctpTransport(shared_ptr<Transport> lower, const Configuration &c
 	sinit.sinit_num_ostreams = MAX_SCTP_STREAMS_COUNT;
 	sinit.sinit_max_instreams = MAX_SCTP_STREAMS_COUNT;
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_INITMSG, &sinit, sizeof(sinit)))
-		throw std::runtime_error("Could not set socket option SCTP_INITMSG, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not set socket option SCTP_INITMSG, errno=" +
 		                         std::to_string(errno));
 
 	// Prevent fragmented interleave of messages (i.e. level 0), see RFC 6458 section 8.1.20.
@@ -279,18 +284,18 @@ SctpTransport::SctpTransport(shared_ptr<Transport> lower, const Configuration &c
 	// may also be interleaved with partially delivered messages.
 	int level = 0;
 	if (usrsctp_setsockopt(mSock, IPPROTO_SCTP, SCTP_FRAGMENT_INTERLEAVE, &level, sizeof(level)))
-		throw std::runtime_error("Could not disable SCTP fragmented interleave, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not disable SCTP fragmented interleave, errno=" +
 		                         std::to_string(errno));
 
 	int rcvBuf = 0;
 	socklen_t rcvBufLen = sizeof(rcvBuf);
 	if (usrsctp_getsockopt(mSock, SOL_SOCKET, SO_RCVBUF, &rcvBuf, &rcvBufLen))
-		throw std::runtime_error("Could not get SCTP recv buffer size, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not get SCTP recv buffer size, errno=" +
 		                         std::to_string(errno));
 	int sndBuf = 0;
 	socklen_t sndBufLen = sizeof(sndBuf);
 	if (usrsctp_getsockopt(mSock, SOL_SOCKET, SO_SNDBUF, &sndBuf, &sndBufLen))
-		throw std::runtime_error("Could not get SCTP send buffer size, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not get SCTP send buffer size, errno=" +
 		                         std::to_string(errno));
 
 	// Ensure the buffer is also large enough to accomodate the largest messages
@@ -300,15 +305,16 @@ SctpTransport::SctpTransport(shared_ptr<Transport> lower, const Configuration &c
 	sndBuf = std::max(sndBuf, minBuf);
 
 	if (usrsctp_setsockopt(mSock, SOL_SOCKET, SO_RCVBUF, &rcvBuf, sizeof(rcvBuf)))
-		throw std::runtime_error("Could not set SCTP recv buffer size, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not set SCTP recv buffer size, errno=" +
 		                         std::to_string(errno));
 
 	if (usrsctp_setsockopt(mSock, SOL_SOCKET, SO_SNDBUF, &sndBuf, sizeof(sndBuf)))
-		throw std::runtime_error("Could not set SCTP send buffer size, errno=" +
+		RTC_THROW RTC_RUNTIME_ERROR("Could not set SCTP send buffer size, errno=" +
 		                         std::to_string(errno));
 
 	usrsctp_register_address(this);
 	Instances->insert(this);
+	RTC_RET;
 }
 
 SctpTransport::~SctpTransport() {
@@ -333,9 +339,9 @@ void SctpTransport::onBufferedAmount(amount_callback callback) {
 	mBufferedAmountCallback = std::move(callback);
 }
 
-void SctpTransport::start() {
+RTC_WRAPPED(void) SctpTransport::start() {
 	registerIncoming();
-	connect();
+	return connect();
 }
 
 void SctpTransport::stop() { close(); }
@@ -351,14 +357,14 @@ struct sockaddr_conn SctpTransport::getSockAddrConn(uint16_t port) {
 	return sconn;
 }
 
-void SctpTransport::connect() {
+RTC_WRAPPED(void) SctpTransport::connect() {
 	PLOG_DEBUG << "SCTP connecting (local port=" << mPorts.local
 	           << ", remote port=" << mPorts.remote << ")";
 	changeState(State::Connecting);
 
 	auto local = getSockAddrConn(mPorts.local);
 	if (usrsctp_bind(mSock, reinterpret_cast<struct sockaddr *>(&local), sizeof(local)))
-		throw std::runtime_error("Could not bind usrsctp socket, errno=" + std::to_string(errno));
+		RTC_THROW RTC_RUNTIME_ERROR("Could not bind usrsctp socket, errno=" + std::to_string(errno));
 
 	// According to RFC 8841, both endpoints must initiate the SCTP association, in a
 	// simultaneous-open manner, irrelevent to the SDP setup role.
@@ -366,10 +372,12 @@ void SctpTransport::connect() {
 	auto remote = getSockAddrConn(mPorts.remote);
 	int ret = usrsctp_connect(mSock, reinterpret_cast<struct sockaddr *>(&remote), sizeof(remote));
 	if (ret && errno != EINPROGRESS)
-		throw std::runtime_error("Connection attempt failed, errno=" + std::to_string(errno));
+		RTC_THROW RTC_RUNTIME_ERROR("Connection attempt failed, errno=" + std::to_string(errno));
+	RTC_RET;
 }
 
-bool SctpTransport::send(message_ptr message) {
+RTC_WRAPPED(bool) SctpTransport::send(message_ptr message) {
+	RTC_BEGIN;
 	std::lock_guard lock(mSendMutex);
 	if (state() != State::Connected)
 		return false;
@@ -380,25 +388,31 @@ bool SctpTransport::send(message_ptr message) {
 	PLOG_VERBOSE << "Send size=" << message->size();
 
 	// Flush the queue, and if nothing is pending, try to send directly
-	if (trySendQueue() && trySendMessage(message))
-		return true;
+	RTC_UNWRAP_RETHROW_DECL(bool, res1, trySendQueue());
+	if (res1) {
+		RTC_UNWRAP_RETHROW_DECL(bool, res2, trySendMessage(message));
+		if (res2) {
+			return true;
+		}
+	}
 
 	mSendQueue.push(message);
-	updateBufferedAmount(to_uint16(message->stream), ptrdiff_t(message_size_func(message)));
+	RTC_UNWRAP_RETHROW_DECL(uint16_t, tmp, to_uint16(message->stream));
+	updateBufferedAmount(tmp, ptrdiff_t(message_size_func(message)));
 	return false;
 }
 
 bool SctpTransport::flush() {
-	try {
+	RTC_TRY {
 		std::lock_guard lock(mSendMutex);
 		if (state() != State::Connected)
 			return false;
 
-		trySendQueue();
+		RTC_UNWRAP_CATCH(trySendQueue());
 		return true;
 
-	} catch (const std::exception &e) {
-		PLOG_WARNING << "SCTP flush: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << "SCTP flush: " << e.RTC_WHAT();
 		return false;
 	}
 }
@@ -409,7 +423,11 @@ void SctpTransport::closeStream(unsigned int stream) {
 	// RFC 8831 6.7. Closing a Data Channel
 	// Closing of a data channel MUST be signaled by resetting the corresponding outgoing streams
 	// See https://www.rfc-editor.org/rfc/rfc8831.html#section-6.7
-	mSendQueue.push(make_message(0, Message::Reset, to_uint16(stream)));
+	RTC_TRY {
+		RTC_UNWRAP_CATCH_DECL(uint16_t, sid, to_uint16(stream));
+		mSendQueue.push(make_message(0, Message::Reset, sid));
+	} RTC_CATCH(...) {
+	}
 
 	// This method must not call the buffered callback synchronously
 	mProcessor.enqueue(&SctpTransport::flush, shared_from_this());
@@ -462,7 +480,7 @@ void SctpTransport::incoming(message_ptr message) {
 	usrsctp_conninput(this, message->data(), message->size(), 0);
 }
 
-bool SctpTransport::outgoing(message_ptr message) {
+RTC_WRAPPED(bool) SctpTransport::outgoing(message_ptr message) {
 	// Set recommended medium-priority DSCP value
 	// See https://www.rfc-editor.org/rfc/rfc8837.html#section-5
 	message->dscp = 10; // AF11: Assured Forwarding class 1, low drop probability
@@ -472,7 +490,7 @@ bool SctpTransport::outgoing(message_ptr message) {
 void SctpTransport::doRecv() {
 	std::lock_guard lock(mRecvMutex);
 	--mPendingRecvCount;
-	try {
+	RTC_TRY {
 		while (state() != State::Disconnected && state() != State::Failed) {
 			const size_t bufferSize = 65536;
 			byte buffer[bufferSize];
@@ -487,7 +505,7 @@ void SctpTransport::doRecv() {
 				if (errno == EWOULDBLOCK || errno == EAGAIN || errno == ECONNRESET)
 					break;
 				else
-					throw std::runtime_error("SCTP recv failed, errno=" + std::to_string(errno));
+					RTC_THROW_WITHIN(RTC_RUNTIME_ERROR("SCTP recv failed, errno=" + std::to_string(errno)));
 			} else if (len == 0) {
 				break;
 			}
@@ -512,7 +530,7 @@ void SctpTransport::doRecv() {
 				if (flags & MSG_EOR) {
 					// Message is complete, process it
 					if (infotype != SCTP_RECVV_RCVINFO)
-						throw std::runtime_error("Missing SCTP recv info");
+						RTC_THROW_WITHIN(RTC_RUNTIME_ERROR("Missing SCTP recv info"));
 
 					processData(std::move(mPartialMessage), info.rcv_sid,
 					            PayloadId(ntohl(info.rcv_ppid)));
@@ -520,18 +538,18 @@ void SctpTransport::doRecv() {
 				}
 			}
 		}
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 void SctpTransport::doFlush() {
 	std::lock_guard lock(mSendMutex);
 	--mPendingFlushCount;
-	try {
-		trySendQueue();
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	RTC_TRY {
+		RTC_UNWRAP_CATCH(trySendQueue());
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
@@ -557,15 +575,18 @@ void SctpTransport::enqueueFlush() {
 	}
 }
 
-bool SctpTransport::trySendQueue() {
+RTC_WRAPPED(bool) SctpTransport::trySendQueue() {
+	RTC_BEGIN;
 	// Requires mSendMutex to be locked
 	while (auto next = mSendQueue.peek()) {
 		message_ptr message = std::move(*next);
-		if (!trySendMessage(message))
+		RTC_UNWRAP_RETHROW_DECL(bool, res, trySendMessage(message));
+		if (!res)
 			return false;
 
 		mSendQueue.pop();
-		updateBufferedAmount(to_uint16(message->stream), -ptrdiff_t(message_size_func(message)));
+		RTC_UNWRAP_RETHROW_DECL(uint16_t, tmp, to_uint16(message->stream));
+		updateBufferedAmount(tmp, -ptrdiff_t(message_size_func(message)));
 	}
 
 	if (!mSendQueue.running() && !std::exchange(mSendShutdown, true)) {
@@ -584,7 +605,8 @@ bool SctpTransport::trySendQueue() {
 	return true;
 }
 
-bool SctpTransport::trySendMessage(message_ptr message) {
+RTC_WRAPPED(bool) SctpTransport::trySendMessage(message_ptr message) {
+	RTC_BEGIN;
 	// Requires mSendMutex to be locked
 	if (state() != State::Connected)
 		return false;
@@ -632,12 +654,12 @@ bool SctpTransport::trySendMessage(message_ptr message) {
 	case Reliability::Type::Rexmit:
 		spa.sendv_flags |= SCTP_SEND_PRINFO_VALID;
 		spa.sendv_prinfo.pr_policy = SCTP_PR_SCTP_RTX;
-		spa.sendv_prinfo.pr_value = to_uint32(std::get<int>(reliability.rexmit));
+		RTC_UNWRAP_RETHROW_VAR(spa.sendv_prinfo.pr_value, to_uint32(std::get<int>(reliability.rexmit)));
 		break;
 	case Reliability::Type::Timed:
 		spa.sendv_flags |= SCTP_SEND_PRINFO_VALID;
 		spa.sendv_prinfo.pr_policy = SCTP_PR_SCTP_TTL;
-		spa.sendv_prinfo.pr_value = to_uint32(std::get<milliseconds>(reliability.rexmit).count());
+		RTC_UNWRAP_RETHROW_VAR(spa.sendv_prinfo.pr_value, to_uint32(std::get<milliseconds>(reliability.rexmit).count()));
 		break;
 	default:
 		spa.sendv_prinfo.pr_policy = SCTP_PR_SCTP_NONE;
@@ -660,7 +682,7 @@ bool SctpTransport::trySendMessage(message_ptr message) {
 		}
 
 		PLOG_ERROR << "SCTP sending failed, errno=" << errno;
-		throw std::runtime_error("Sending failed, errno=" + std::to_string(errno));
+		RTC_THROW RTC_RUNTIME_ERROR("Sending failed, errno=" + std::to_string(errno));
 	}
 
 	PLOG_VERBOSE << "SCTP sent size=" << message->size();
@@ -687,10 +709,10 @@ void SctpTransport::updateBufferedAmount(uint16_t streamId, ptrdiff_t delta) {
 }
 
 void SctpTransport::triggerBufferedAmount(uint16_t streamId, size_t amount) {
-	try {
+	RTC_TRY {
 		mBufferedAmountCallback(streamId, amount);
-	} catch (const std::exception &e) {
-		PLOG_WARNING << "SCTP buffered amount callback: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << "SCTP buffered amount callback: " << e.RTC_WHAT();
 	}
 }
 
@@ -722,7 +744,7 @@ void SctpTransport::sendReset(uint16_t streamId) {
 }
 
 void SctpTransport::handleUpcall() noexcept {
-	try {
+	RTC_TRY {
 		PLOG_VERBOSE << "Handle upcall";
 
 		int events = usrsctp_get_events(mSock);
@@ -733,26 +755,27 @@ void SctpTransport::handleUpcall() noexcept {
 		if (events & SCTP_EVENT_WRITE)
 			enqueueFlush();
 
-	} catch (const std::exception &e) {
-		PLOG_ERROR << "SCTP upcall: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << "SCTP upcall: " << e.RTC_WHAT();
 	}
 }
 
 int SctpTransport::handleWrite(byte *data, size_t len, uint8_t /*tos*/,
                                uint8_t /*set_df*/) noexcept {
-	try {
+	RTC_TRY {
 		std::unique_lock lock(mWriteMutex);
 		PLOG_VERBOSE << "Handle write, len=" << len;
 
-		if (!outgoing(make_message(data, data + len)))
+		RTC_UNWRAP_CATCH_DECL(bool, res, outgoing(make_message(data, data + len)));
+		if (!res)
 			return -1;
 
 		mWritten = true;
 		mWrittenOnce = true;
 		mWrittenCondition.notify_all();
 
-	} catch (const std::exception &e) {
-		PLOG_ERROR << "SCTP write: " << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_ERROR << "SCTP write: " << e.RTC_WHAT();
 		return -1;
 	}
 	return 0; // success
diff --git a/thirdparty/libdatachannel/src/impl/sctptransport.hpp b/thirdparty/libdatachannel/src/impl/sctptransport.hpp
index 0ef4b8f725..3d65487a15 100644
--- a/thirdparty/libdatachannel/src/impl/sctptransport.hpp
+++ b/thirdparty/libdatachannel/src/impl/sctptransport.hpp
@@ -28,7 +28,7 @@ namespace rtc::impl {
 class SctpTransport final : public Transport, public std::enable_shared_from_this<SctpTransport> {
 public:
 	static void Init();
-	static void SetSettings(const SctpSettings &s);
+	static RTC_WRAPPED(void) SetSettings(const SctpSettings &s);
 	static void Cleanup();
 
 	using amount_callback = std::function<void(uint16_t streamId, size_t amount)>;
@@ -38,16 +38,17 @@ public:
 		uint16_t remote = DEFAULT_SCTP_PORT;
 	};
 
-	SctpTransport(shared_ptr<Transport> lower, const Configuration &config, Ports ports,
+	SctpTransport(shared_ptr<Transport> lower, Ports ports,
 	              message_callback recvCallback, amount_callback bufferedAmountCallback,
 	              state_callback stateChangeCallback);
 	~SctpTransport();
+	RTC_WRAPPED(void) construct(const Configuration &config);
 
 	void onBufferedAmount(amount_callback callback);
 
-	void start() override;
+	RTC_WRAPPED(void) start() override;
 	void stop() override;
-	bool send(message_ptr message) override; // false if buffered
+	RTC_WRAPPED(bool) send(message_ptr message) override; // false if buffered
 	bool flush();
 	void closeStream(unsigned int stream);
 	void close();
@@ -75,17 +76,17 @@ private:
 
 	struct sockaddr_conn getSockAddrConn(uint16_t port);
 
-	void connect();
+	RTC_WRAPPED(void) connect();
 	void shutdown();
 	void incoming(message_ptr message) override;
-	bool outgoing(message_ptr message) override;
+	RTC_WRAPPED(bool) outgoing(message_ptr message) override;
 
 	void doRecv();
 	void doFlush();
 	void enqueueRecv();
 	void enqueueFlush();
-	bool trySendQueue();
-	bool trySendMessage(message_ptr message);
+	RTC_WRAPPED(bool) trySendQueue();
+	RTC_WRAPPED(bool) trySendMessage(message_ptr message);
 	void updateBufferedAmount(uint16_t streamId, ptrdiff_t delta);
 	void triggerBufferedAmount(uint16_t streamId, size_t amount);
 	void sendReset(uint16_t streamId);
diff --git a/thirdparty/libdatachannel/src/impl/tls.cpp b/thirdparty/libdatachannel/src/impl/tls.cpp
index 4ea7d89cc0..fc096d68fb 100644
--- a/thirdparty/libdatachannel/src/impl/tls.cpp
+++ b/thirdparty/libdatachannel/src/impl/tls.cpp
@@ -16,12 +16,12 @@
 namespace rtc::gnutls {
 
 // Return false on non-fatal error
-bool check(int ret, const string &message) {
+RTC_WRAPPED(bool) check(int ret, const string &message) {
 	if (ret < 0) {
 		if (!gnutls_error_is_fatal(ret)) {
 			return false;
 		}
-		throw std::runtime_error(message + ": " + gnutls_strerror(ret));
+		RTC_THROW RTC_RUNTIME_ERROR(message + ": " + gnutls_strerror(ret));
 	}
 	return true;
 }
@@ -97,7 +97,7 @@ size_t my_strftme(char *buf, size_t size, const char *format, const time_t *t) {
 namespace rtc::mbedtls {
 
 // Return false on non-fatal error
-bool check(int ret, const string &message) {
+RTC_WRAPPED(bool) check(int ret, const string &message) {
 	if (ret < 0) {
 		if (ret == MBEDTLS_ERR_SSL_WANT_READ || ret == MBEDTLS_ERR_SSL_WANT_WRITE ||
 		    ret == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS || ret == MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS ||
@@ -107,17 +107,17 @@ bool check(int ret, const string &message) {
 		// const size_t bufferSize = 1024;
 		// char buffer[bufferSize];
 		// mbedtls_strerror(ret, reinterpret_cast<char *>(buffer), bufferSize);
-		throw std::runtime_error(message + ": Error " + std::to_string(ret));
+		RTC_THROW RTC_RUNTIME_ERROR(message + ": Error " + std::to_string(ret));
 	}
 	return true;
 }
 
-string format_time(const std::chrono::system_clock::time_point &tp) {
+RTC_WRAPPED(string) format_time(const std::chrono::system_clock::time_point &tp) {
 	time_t t = std::chrono::system_clock::to_time_t(tp);
 	const size_t bufferSize = 256;
 	char buffer[bufferSize];
 	if (my_strftme(buffer, bufferSize, "%Y%m%d%H%M%S", &t) == 0)
-		throw std::runtime_error("Time conversion failed");
+		RTC_THROW RTC_RUNTIME_ERROR("Time conversion failed");
 
 	return string(buffer);
 };
@@ -170,18 +170,18 @@ string error_string(unsigned long error) {
 	return string(buffer);
 }
 
-bool check(int success, const string &message) {
+RTC_WRAPPED(bool) check(int success, const string &message) {
 	unsigned long last_error = ERR_peek_last_error();
 	ERR_clear_error();
 
 	if (success > 0)
 		return true;
 
-	throw std::runtime_error(message + (last_error != 0 ? ": " + error_string(last_error) : ""));
+	RTC_THROW RTC_RUNTIME_ERROR(message + (last_error != 0 ? ": " + error_string(last_error) : ""));
 }
 
 // Return false on recoverable error
-bool check_error(int err, const string &message) {
+RTC_WRAPPED(bool) check_error(int err, const string &message) {
 	unsigned long last_error = ERR_peek_last_error();
 	ERR_clear_error();
 
@@ -189,13 +189,13 @@ bool check_error(int err, const string &message) {
 		return true;
 
 	if (err == SSL_ERROR_ZERO_RETURN)
-		throw std::runtime_error(message + ": peer closed connection");
+		RTC_THROW RTC_RUNTIME_ERROR(message + ": peer closed connection");
 
 	if (err == SSL_ERROR_SYSCALL)
-		throw std::runtime_error(message + ": fatal I/O error");
+		RTC_THROW RTC_RUNTIME_ERROR(message + ": fatal I/O error");
 
 	if (err == SSL_ERROR_SSL)
-		throw std::runtime_error(message +
+		RTC_THROW RTC_RUNTIME_ERROR(message +
 		                         (last_error != 0 ? ": " + error_string(last_error) : ""));
 
 	// SSL_ERROR_WANT_READ and SSL_ERROR_WANT_WRITE end up here
@@ -204,7 +204,7 @@ bool check_error(int err, const string &message) {
 
 BIO *BIO_new_from_file(const string &filename) {
 	BIO *bio = nullptr;
-	try {
+	RTC_TRY {
 		std::ifstream ifs(filename, std::ifstream::in | std::ifstream::binary);
 		if (!ifs.is_open())
 			return nullptr;
@@ -220,7 +220,7 @@ BIO *BIO_new_from_file(const string &filename) {
 		ifs.close();
 		return bio;
 
-	} catch (const std::exception &) {
+	} RTC_CATCH (const RTC_EXCEPTION &) {
 		BIO_free(bio);
 		return nullptr;
 	}
diff --git a/thirdparty/libdatachannel/src/impl/tls.hpp b/thirdparty/libdatachannel/src/impl/tls.hpp
index 36ad6155ff..61c2f08fd7 100644
--- a/thirdparty/libdatachannel/src/impl/tls.hpp
+++ b/thirdparty/libdatachannel/src/impl/tls.hpp
@@ -23,7 +23,7 @@
 
 namespace rtc::gnutls {
 
-bool check(int ret, const string &message = "GnuTLS error");
+RTC_WRAPPED(bool) check(int ret, const string &message = "GnuTLS error");
 
 gnutls_certificate_credentials_t *new_credentials();
 void free_credentials(gnutls_certificate_credentials_t *creds);
@@ -52,9 +52,9 @@ gnutls_datum_t make_datum(char *data, size_t size);
 
 namespace rtc::mbedtls {
 
-bool check(int ret, const string &message = "MbedTLS error");
+RTC_WRAPPED(bool) check(int ret, const string &message = "MbedTLS error");
 
-string format_time(const std::chrono::system_clock::time_point &tp);
+RTC_WRAPPED(string) format_time(const std::chrono::system_clock::time_point &tp);
 
 std::shared_ptr<mbedtls_pk_context> new_pk_context();
 std::shared_ptr<mbedtls_x509_crt> new_x509_crt();
@@ -84,8 +84,8 @@ namespace rtc::openssl {
 void init();
 string error_string(unsigned long error);
 
-bool check(int success, const string &message = "OpenSSL error");
-bool check_error(int err, const string &message = "OpenSSL error");
+RTC_WRAPPED(bool) check(int success, const string &message = "OpenSSL error");
+RTC_WRAPPED(bool) check_error(int err, const string &message = "OpenSSL error");
 
 BIO *BIO_new_from_file(const string &filename);
 
diff --git a/thirdparty/libdatachannel/src/impl/transport.cpp b/thirdparty/libdatachannel/src/impl/transport.cpp
index 1c28e4f365..3da1dd488f 100644
--- a/thirdparty/libdatachannel/src/impl/transport.cpp
+++ b/thirdparty/libdatachannel/src/impl/transport.cpp
@@ -25,7 +25,13 @@ Transport::~Transport() {
 void Transport::registerIncoming() {
 	if (mLower) {
 		PLOG_VERBOSE << "Registering incoming callback";
-		mLower->onRecv(std::bind(&Transport::incoming, this, std::placeholders::_1));
+		mLower->onRecv([this](message_ptr message) -> void {
+			RTC_TRY {
+				Transport::incoming(message);
+			} RTC_CATCH(RTC_EXCEPTION e) {
+				PLOG_WARNING << e.RTC_WHAT(); // FIXME
+			}
+		});
 	}
 }
 
@@ -44,32 +50,32 @@ void Transport::onStateChange(state_callback callback) {
 	mStateChangeCallback = std::move(callback);
 }
 
-void Transport::start() { registerIncoming(); }
+RTC_WRAPPED(void) Transport::start() { registerIncoming(); RTC_RET; }
 
 void Transport::stop() { unregisterIncoming(); }
 
-bool Transport::send(message_ptr message) { return outgoing(message); }
+RTC_WRAPPED(bool) Transport::send(message_ptr message) { return outgoing(message); }
 
 void Transport::recv(message_ptr message) {
-	try {
+	RTC_TRY {
 		mRecvCallback(message);
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 void Transport::changeState(State state) {
-	try {
+	RTC_TRY {
 		if (mState.exchange(state) != state)
 			mStateChangeCallback(state);
-	} catch (const std::exception &e) {
-		PLOG_WARNING << e.what();
+	} RTC_CATCH (const RTC_EXCEPTION &e) {
+		PLOG_WARNING << e.RTC_WHAT();
 	}
 }
 
 void Transport::incoming(message_ptr message) { recv(message); }
 
-bool Transport::outgoing(message_ptr message) {
+RTC_WRAPPED(bool) Transport::outgoing(message_ptr message) {
 	if (mLower)
 		return mLower->send(message);
 	else
diff --git a/thirdparty/libdatachannel/src/impl/transport.hpp b/thirdparty/libdatachannel/src/impl/transport.hpp
index fc879df2b6..5d8ed725a1 100644
--- a/thirdparty/libdatachannel/src/impl/transport.hpp
+++ b/thirdparty/libdatachannel/src/impl/transport.hpp
@@ -35,15 +35,15 @@ public:
 	void onRecv(message_callback callback);
 	void onStateChange(state_callback callback);
 
-	virtual void start();
+	virtual RTC_WRAPPED(void) start();
 	virtual void stop();
-	virtual bool send(message_ptr message);
+	virtual RTC_WRAPPED(bool) send(message_ptr message);
 
 protected:
 	void recv(message_ptr message);
 	void changeState(State state);
 	virtual void incoming(message_ptr message);
-	virtual bool outgoing(message_ptr message);
+	virtual RTC_WRAPPED(bool) outgoing(message_ptr message);
 
 private:
 	const init_token mInitToken = Init::Instance().token();
diff --git a/thirdparty/libdatachannel/src/impl/utils.cpp b/thirdparty/libdatachannel/src/impl/utils.cpp
index 262fdaed4a..16250158ef 100644
--- a/thirdparty/libdatachannel/src/impl/utils.cpp
+++ b/thirdparty/libdatachannel/src/impl/utils.cpp
@@ -62,15 +62,11 @@ string url_decode(const string &str) {
 		char c = str[i++];
 		if (c == '%') {
 			auto value = str.substr(i, 2);
-			try {
-				if (value.size() != 2 || !std::isxdigit(value[0]) || !std::isxdigit(value[1]))
-					throw std::exception();
-
+			if (value.size() != 2 || !std::isxdigit(value[0]) || !std::isxdigit(value[1])) {
+				PLOG_WARNING << "Invalid percent-encoded character in URL: \"%" + value + "\"";
+			} else {
 				c = static_cast<char>(std::stoi(value, nullptr, 16));
 				i += 2;
-
-			} catch (...) {
-				PLOG_WARNING << "Invalid percent-encoded character in URL: \"%" + value + "\"";
 			}
 		}
 
diff --git a/thirdparty/libdatachannel/src/peerconnection.cpp b/thirdparty/libdatachannel/src/peerconnection.cpp
index bde4fb013c..7c5e17d1fc 100644
--- a/thirdparty/libdatachannel/src/peerconnection.cpp
+++ b/thirdparty/libdatachannel/src/peerconnection.cpp
@@ -38,11 +38,7 @@ PeerConnection::PeerConnection(Configuration config)
     : CheshireCat<impl::PeerConnection>(std::move(config)) {}
 
 PeerConnection::~PeerConnection() {
-	try {
-		impl()->remoteClose();
-	} catch (const std::exception &e) {
-		PLOG_ERROR << e.what();
-	}
+	impl()->remoteClose();
 }
 
 void PeerConnection::close() { impl()->close(); }
@@ -74,7 +70,8 @@ bool PeerConnection::hasMedia() const {
 	return local && local->hasAudioOrVideo();
 }
 
-void PeerConnection::setLocalDescription(Description::Type type) {
+RTC_WRAPPED(void) PeerConnection::setLocalDescription(Description::Type type) {
+	RTC_BEGIN;
 	std::unique_lock signalingLock(impl()->signalingMutex);
 	PLOG_VERBOSE << "Setting local description, type=" << Description::typeToString(type);
 
@@ -85,7 +82,7 @@ void PeerConnection::setLocalDescription(Description::Type type) {
 			impl()->rollbackLocalDescription();
 			impl()->changeSignalingState(SignalingState::Stable);
 		}
-		return;
+		RTC_RET;
 	}
 
 	// Guess the description type if unspecified
@@ -99,7 +96,7 @@ void PeerConnection::setLocalDescription(Description::Type type) {
 	// Only a local offer resets the negotiation needed flag
 	if (type == Description::Type::Offer && !impl()->negotiationNeeded.exchange(false)) {
 		PLOG_DEBUG << "No negotiation needed";
-		return;
+		RTC_RET;
 	}
 
 	// Get the new signaling state
@@ -110,7 +107,7 @@ void PeerConnection::setLocalDescription(Description::Type type) {
 			std::ostringstream oss;
 			oss << "Unexpected local desciption type " << type << " in signaling state "
 			    << signalingState;
-			throw std::logic_error(oss.str());
+			RTC_THROW RTC_LOGIC_ERROR(oss.str());
 		}
 		newSignalingState = SignalingState::HaveLocalOffer;
 		break;
@@ -121,7 +118,7 @@ void PeerConnection::setLocalDescription(Description::Type type) {
 			std::ostringstream oss;
 			oss << "Unexpected local description type " << type
 			    << " description in signaling state " << signalingState;
-			throw std::logic_error(oss.str());
+			RTC_THROW RTC_LOGIC_ERROR(oss.str());
 		}
 		newSignalingState = SignalingState::Stable;
 		break;
@@ -130,26 +127,28 @@ void PeerConnection::setLocalDescription(Description::Type type) {
 		std::ostringstream oss;
 		oss << "Unexpected local description in signaling state " << signalingState << ", ignoring";
 		LOG_WARNING << oss.str();
-		return;
+		RTC_RET;
 	}
 	}
 
-	auto iceTransport = impl()->initIceTransport();
+	RTC_UNWRAP_RETHROW_DECL(auto, iceTransport, impl()->initIceTransport());
 	if (!iceTransport)
-		return; // closed
+		RTC_RET; // closed
 
-	Description local = iceTransport->getLocalDescription(type);
-	impl()->processLocalDescription(std::move(local));
+	RTC_UNWRAP_RETHROW_DECL(Description, local, iceTransport->getLocalDescription(type));
+	RTC_UNWRAP_RETHROW(impl()->processLocalDescription(std::move(local)));
 
 	impl()->changeSignalingState(newSignalingState);
 	signalingLock.unlock();
 
 	if (impl()->gatheringState == GatheringState::New) {
-		iceTransport->gatherLocalCandidates(impl()->localBundleMid());
+		RTC_UNWRAP_RETHROW(iceTransport->gatherLocalCandidates(impl()->localBundleMid()));
 	}
+	RTC_RET;
 }
 
-void PeerConnection::setRemoteDescription(Description description) {
+RTC_WRAPPED(void) PeerConnection::setRemoteDescription(Description description) {
+	RTC_BEGIN;
 	std::unique_lock signalingLock(impl()->signalingMutex);
 	PLOG_VERBOSE << "Setting remote description: " << string(description);
 
@@ -157,10 +156,10 @@ void PeerConnection::setRemoteDescription(Description description) {
 		// This is mostly useless because we accept any offer
 		PLOG_VERBOSE << "Rolling back pending remote description";
 		impl()->changeSignalingState(SignalingState::Stable);
-		return;
+		RTC_RET;
 	}
 
-	impl()->validateRemoteDescription(description);
+	RTC_UNWRAP_RETHROW(impl()->validateRemoteDescription(description));
 
 	// Get the new signaling state
 	SignalingState signalingState = impl()->signalingState.load();
@@ -172,7 +171,7 @@ void PeerConnection::setRemoteDescription(Description description) {
 			std::ostringstream oss;
 			oss << "Unexpected remote " << description.type() << " description in signaling state "
 			    << signalingState;
-			throw std::logic_error(oss.str());
+			RTC_THROW RTC_LOGIC_ERROR(oss.str());
 		}
 		newSignalingState = SignalingState::HaveRemoteOffer;
 		break;
@@ -193,7 +192,7 @@ void PeerConnection::setRemoteDescription(Description description) {
 			std::ostringstream oss;
 			oss << "Unexpected remote " << description.type() << " description in signaling state "
 			    << signalingState;
-			throw std::logic_error(oss.str());
+			RTC_THROW RTC_LOGIC_ERROR(oss.str());
 		}
 		newSignalingState = SignalingState::Stable;
 		break;
@@ -205,7 +204,7 @@ void PeerConnection::setRemoteDescription(Description description) {
 			std::ostringstream oss;
 			oss << "Unexpected remote " << description.type() << " description in signaling state "
 			    << signalingState;
-			throw std::logic_error(oss.str());
+			RTC_THROW RTC_LOGIC_ERROR(oss.str());
 		}
 		newSignalingState = SignalingState::Stable;
 		break;
@@ -213,7 +212,7 @@ void PeerConnection::setRemoteDescription(Description description) {
 	default: {
 		std::ostringstream oss;
 		oss << "Unexpected remote description in signaling state " << signalingState;
-		throw std::logic_error(oss.str());
+		RTC_THROW RTC_LOGIC_ERROR(oss.str());
 	}
 	}
 
@@ -221,30 +220,31 @@ void PeerConnection::setRemoteDescription(Description description) {
 	auto remoteCandidates = description.extractCandidates();
 	auto type = description.type();
 
-	auto iceTransport = impl()->initIceTransport();
+	RTC_UNWRAP_RETHROW_DECL(auto, iceTransport, impl()->initIceTransport());
 	if (!iceTransport)
-		return; // closed
+		RTC_RET; // closed
 
-	iceTransport->setRemoteDescription(description); // ICE transport might reject the description
+	RTC_UNWRAP_RETHROW(iceTransport->setRemoteDescription(description)); // ICE transport might reject the description
 
-	impl()->processRemoteDescription(std::move(description));
+	RTC_UNWRAP_RETHROW(impl()->processRemoteDescription(std::move(description)));
 	impl()->changeSignalingState(newSignalingState);
 	signalingLock.unlock();
 
 	if (type == Description::Type::Offer) {
 		// This is an offer, we need to answer
 		if (!impl()->config.disableAutoNegotiation)
-			setLocalDescription(Description::Type::Answer);
+			RTC_UNWRAP_RETHROW(setLocalDescription(Description::Type::Answer));
 	}
 
 	for (const auto &candidate : remoteCandidates)
-		addRemoteCandidate(candidate);
+		RTC_UNWRAP_RETHROW(addRemoteCandidate(candidate));
+	RTC_RET;
 }
 
-void PeerConnection::addRemoteCandidate(Candidate candidate) {
+RTC_WRAPPED(void) PeerConnection::addRemoteCandidate(Candidate candidate) {
 	std::unique_lock signalingLock(impl()->signalingMutex);
 	PLOG_VERBOSE << "Adding remote candidate: " << string(candidate);
-	impl()->processRemoteCandidate(std::move(candidate));
+	return impl()->processRemoteCandidate(std::move(candidate));
 }
 
 #if RTC_ENABLE_MEDIA
@@ -267,8 +267,9 @@ optional<string> PeerConnection::remoteAddress() const {
 
 uint16_t PeerConnection::maxDataChannelId() const { return impl()->maxDataChannelStream(); }
 
-shared_ptr<DataChannel> PeerConnection::createDataChannel(string label, DataChannelInit init) {
-	auto channelImpl = impl()->emplaceDataChannel(std::move(label), std::move(init));
+RTC_WRAPPED(shared_ptr<DataChannel>) PeerConnection::createDataChannel(string label, DataChannelInit init) {
+	RTC_BEGIN;
+	RTC_UNWRAP_RETHROW_DECL(auto, channelImpl, impl()->emplaceDataChannel(std::move(label), std::move(init)));
 	auto channel = std::make_shared<DataChannel>(channelImpl);
 
 	// Renegotiation is needed iff the current local description does not have application
@@ -277,7 +278,7 @@ shared_ptr<DataChannel> PeerConnection::createDataChannel(string label, DataChan
 		impl()->negotiationNeeded = true;
 
 	if (!impl()->config.disableAutoNegotiation)
-		setLocalDescription();
+		RTC_UNWRAP_RETHROW(setLocalDescription());
 
 	return channel;
 }
@@ -331,9 +332,13 @@ void PeerConnection::onSignalingStateChange(std::function<void(SignalingState st
 
 void PeerConnection::resetCallbacks() { impl()->resetCallbacks(); }
 
-bool PeerConnection::getSelectedCandidatePair(Candidate *local, Candidate *remote) {
+RTC_WRAPPED(bool) PeerConnection::getSelectedCandidatePair(Candidate *local, Candidate *remote) {
+	RTC_BEGIN;
 	auto iceTransport = impl()->getIceTransport();
-	return iceTransport ? iceTransport->getSelectedCandidatePair(local, remote) : false;
+	if (iceTransport) {
+		RTC_UNWRAP_RETHROW(iceTransport->getSelectedCandidatePair(local, remote));
+	}
+	return false;
 }
 
 void PeerConnection::clearStats() {
