diff --git a/thirdparty/libdatachannel/include/rtc/peerconnection.hpp b/thirdparty/libdatachannel/include/rtc/peerconnection.hpp
index 66238cb6bb..512bed3c83 100644
--- a/thirdparty/libdatachannel/include/rtc/peerconnection.hpp
+++ b/thirdparty/libdatachannel/include/rtc/peerconnection.hpp
@@ -93,15 +93,19 @@ public:
 	void setRemoteDescription(Description description);
 	void addRemoteCandidate(Candidate candidate);
 
+#if RTC_ENABLE_MEDIA
 	void setMediaHandler(shared_ptr<MediaHandler> handler);
 	shared_ptr<MediaHandler> getMediaHandler();
+#endif
 
 	[[nodiscard]] shared_ptr<DataChannel> createDataChannel(string label,
 	                                                        DataChannelInit init = {});
 	void onDataChannel(std::function<void(std::shared_ptr<DataChannel> dataChannel)> callback);
 
+#if RTC_ENABLE_MEDIA
 	[[nodiscard]] shared_ptr<Track> addTrack(Description::Media description);
 	void onTrack(std::function<void(std::shared_ptr<Track> track)> callback);
+#endif
 
 	void onLocalDescription(std::function<void(Description description)> callback);
 	void onLocalCandidate(std::function<void(Candidate candidate)> callback);
diff --git a/thirdparty/libdatachannel/src/impl/peerconnection.cpp b/thirdparty/libdatachannel/src/impl/peerconnection.cpp
index c53469d981..3bd9f9fcc4 100644
--- a/thirdparty/libdatachannel/src/impl/peerconnection.cpp
+++ b/thirdparty/libdatachannel/src/impl/peerconnection.cpp
@@ -84,7 +84,9 @@ void PeerConnection::remoteClose() {
 	if (state.load() != State::Closed) {
 		// Close data channels and tracks asynchronously
 		mProcessor.enqueue(&PeerConnection::closeDataChannels, shared_from_this());
+#if RTC_ENABLE_MEDIA
 		mProcessor.enqueue(&PeerConnection::closeTracks, shared_from_this());
+#endif
 
 		closeTransports();
 	}
@@ -230,7 +232,9 @@ shared_ptr<DtlsTransport> PeerConnection::initDtlsTransport() {
 				    else
 					    changeState(State::Connected);
 
+#if RTC_ENABLE_MEDIA
 				    mProcessor.enqueue(&PeerConnection::openTracks, shared_from_this());
+#endif
 				    break;
 			    case DtlsTransport::State::Failed:
 				    changeState(State::Failed);
@@ -360,7 +364,9 @@ void PeerConnection::closeTransports() {
 		return; // already closed
 
 	// Reset interceptor and callbacks now that state is changed
+#if RTC_ENABLE_MEDIA
 	setMediaHandler(nullptr);
+#endif
 	resetCallbacks();
 
 	// Pass the pointers to a thread, allowing to terminate a transport from its own thread
@@ -494,6 +500,7 @@ void PeerConnection::forwardMessage(message_ptr message) {
 }
 
 void PeerConnection::forwardMedia(message_ptr message) {
+#if RTC_ENABLE_MEDIA
 	if (!message)
 		return;
 
@@ -581,6 +588,7 @@ void PeerConnection::forwardMedia(message_ptr message) {
 		// PLOG_WARNING << "Track not found for SSRC " << ssrc << ", dropping";
 		return;
 	}
+#endif
 }
 
 void PeerConnection::forwardBufferedAmount(uint16_t stream, size_t amount) {
@@ -723,6 +731,7 @@ void PeerConnection::remoteCloseDataChannels() {
 	iterateDataChannels([&](shared_ptr<DataChannel> channel) { channel->remoteClose(); });
 }
 
+#if RTC_ENABLE_MEDIA
 shared_ptr<Track> PeerConnection::emplaceTrack(Description::Media description) {
 #if !RTC_ENABLE_MEDIA
 	// No media support, mark as removed
@@ -762,7 +771,6 @@ void PeerConnection::iterateTracks(std::function<void(shared_ptr<Track> track)>
 }
 
 void PeerConnection::openTracks() {
-#if RTC_ENABLE_MEDIA
 	if (auto transport = std::atomic_load(&mDtlsTransport)) {
 		auto srtpTransport = std::dynamic_pointer_cast<DtlsSrtpTransport>(transport);
 
@@ -782,13 +790,13 @@ void PeerConnection::openTracks() {
 			}
 		});
 	}
-#endif
 }
 
 void PeerConnection::closeTracks() {
 	std::shared_lock lock(mTracksMutex); // read-only
 	iterateTracks([&](shared_ptr<Track> track) { track->close(); });
 }
+#endif
 
 void PeerConnection::validateRemoteDescription(const Description &description) {
 	if (!description.iceUfrag())
@@ -865,6 +873,7 @@ void PeerConnection::processLocalDescription(Description description) {
 				        description.addMedia(std::move(reciprocated));
 			        },
 			        [&](Description::Media *remoteMedia) {
+#if RTC_ENABLE_MEDIA
 				        std::shared_lock lock(mTracksMutex);
 				        if (auto it = mTracks.find(remoteMedia->mid()); it != mTracks.end()) {
 					        // Prefer local description
@@ -889,7 +898,7 @@ void PeerConnection::processLocalDescription(Description description) {
 					        }
 					        return;
 				        }
-
+#endif
 				        auto reciprocated = remoteMedia->reciprocate();
 #if !RTC_ENABLE_MEDIA
 				        if (!reciprocated.isRemoved()) {
@@ -898,7 +907,7 @@ void PeerConnection::processLocalDescription(Description description) {
 					        reciprocated.markRemoved();
 				        }
 #endif
-
+#if RTC_ENABLE_MEDIA
 				        PLOG_DEBUG << "Reciprocating media in local description, mid=\""
 				                   << reciprocated.mid() << "\", removed=" << std::boolalpha
 				                   << reciprocated.isRemoved();
@@ -914,6 +923,7 @@ void PeerConnection::processLocalDescription(Description description) {
 					        track->close();
 
 				        description.addMedia(track->description());
+#endif
 			        },
 			    },
 			    remote->media(i));
@@ -924,6 +934,7 @@ void PeerConnection::processLocalDescription(Description description) {
 
 	if (description.type() == Description::Type::Offer) {
 		// This is an offer, add locally created data channels and tracks
+#if RTC_ENABLE_MEDIA
 		// Add media for local tracks
 		std::shared_lock lock(mTracksMutex);
 		for (auto it = mTrackLines.begin(); it != mTrackLines.end(); ++it) {
@@ -939,6 +950,7 @@ void PeerConnection::processLocalDescription(Description description) {
 				description.addMedia(std::move(media));
 			}
 		}
+#endif
 
 		// Add application for data channels
 		if (!description.hasApplication()) {
@@ -994,9 +1006,11 @@ void PeerConnection::processLocalDescription(Description description) {
 	                   &localDescriptionCallback, std::move(description));
 
 	// Reciprocated tracks might need to be open
+#if RTC_ENABLE_MEDIA
 	if (auto dtlsTransport = std::atomic_load(&mDtlsTransport);
 	    dtlsTransport && dtlsTransport->state() == Transport::State::Connected)
 		mProcessor.enqueue(&PeerConnection::openTracks, shared_from_this());
+#endif
 }
 
 void PeerConnection::processLocalCandidate(Candidate candidate) {
@@ -1089,6 +1103,7 @@ string PeerConnection::localBundleMid() const {
 	return mLocalDescription ? mLocalDescription->bundleMid() : "0";
 }
 
+#if RTC_ENABLE_MEDIA
 void PeerConnection::setMediaHandler(shared_ptr<MediaHandler> handler) {
 	std::unique_lock lock(mMediaHandlerMutex);
 	if (mMediaHandler)
@@ -1100,6 +1115,7 @@ shared_ptr<MediaHandler> PeerConnection::getMediaHandler() {
 	std::shared_lock lock(mMediaHandlerMutex);
 	return mMediaHandler;
 }
+#endif
 
 void PeerConnection::triggerDataChannel(weak_ptr<DataChannel> weakDataChannel) {
 	auto dataChannel = weakDataChannel.lock();
@@ -1110,6 +1126,7 @@ void PeerConnection::triggerDataChannel(weak_ptr<DataChannel> weakDataChannel) {
 	triggerPendingDataChannels();
 }
 
+#if RTC_ENABLE_MEDIA
 void PeerConnection::triggerTrack(weak_ptr<Track> weakTrack) {
 	auto track = weakTrack.lock();
 	if (track) {
@@ -1118,6 +1135,7 @@ void PeerConnection::triggerTrack(weak_ptr<Track> weakTrack) {
 	}
 	triggerPendingTracks();
 }
+#endif
 
 void PeerConnection::triggerPendingDataChannels() {
 	while (dataChannelCallback) {
@@ -1138,6 +1156,7 @@ void PeerConnection::triggerPendingDataChannels() {
 }
 
 void PeerConnection::triggerPendingTracks() {
+#if RTC_ENABLE_MEDIA
 	while (trackCallback) {
 		auto next = mPendingTracks.pop();
 		if (!next)
@@ -1153,6 +1172,7 @@ void PeerConnection::triggerPendingTracks() {
 
 		// Do not trigger open immediately for tracks as it'll be done later
 	}
+#endif
 }
 
 void PeerConnection::flushPendingDataChannels() {
@@ -1160,7 +1180,9 @@ void PeerConnection::flushPendingDataChannels() {
 }
 
 void PeerConnection::flushPendingTracks() {
+#if RTC_ENABLE_MEDIA
 	mProcessor.enqueue(&PeerConnection::triggerPendingTracks, shared_from_this());
+#endif
 }
 
 bool PeerConnection::changeState(State newState) {
@@ -1241,10 +1263,13 @@ void PeerConnection::resetCallbacks() {
 	iceStateChangeCallback = nullptr;
 	gatheringStateChangeCallback = nullptr;
 	signalingStateChangeCallback = nullptr;
+#if RTC_ENABLE_MEDIA
 	trackCallback = nullptr;
+#endif
 }
 
 void PeerConnection::updateTrackSsrcCache(const Description &description) {
+#if RTC_ENABLE_MEDIA
 	std::unique_lock lock(mTracksMutex); // for safely writing to mTracksBySsrc
 
 	// Setup SSRC -> Track mapping
@@ -1277,6 +1302,7 @@ void PeerConnection::updateTrackSsrcCache(const Description &description) {
 		        },
 		    },
 		    description.media(i));
+#endif
 }
 
 } // namespace rtc::impl
diff --git a/thirdparty/libdatachannel/src/impl/peerconnection.hpp b/thirdparty/libdatachannel/src/impl/peerconnection.hpp
index 79c6e5b42c..47fd4dc071 100644
--- a/thirdparty/libdatachannel/src/impl/peerconnection.hpp
+++ b/thirdparty/libdatachannel/src/impl/peerconnection.hpp
@@ -68,10 +68,12 @@ struct PeerConnection : std::enable_shared_from_this<PeerConnection> {
 	void closeDataChannels();
 	void remoteCloseDataChannels();
 
+#if RTC_ENABLE_MEDIA
 	shared_ptr<Track> emplaceTrack(Description::Media description);
 	void iterateTracks(std::function<void(shared_ptr<Track> track)> func);
 	void openTracks();
 	void closeTracks();
+#endif
 
 	void validateRemoteDescription(const Description &description);
 	void processLocalDescription(Description description);
@@ -80,11 +82,15 @@ struct PeerConnection : std::enable_shared_from_this<PeerConnection> {
 	void processRemoteCandidate(Candidate candidate);
 	string localBundleMid() const;
 
+#if RTC_ENABLE_MEDIA
 	void setMediaHandler(shared_ptr<MediaHandler> handler);
 	shared_ptr<MediaHandler> getMediaHandler();
+#endif
 
 	void triggerDataChannel(weak_ptr<DataChannel> weakDataChannel);
+#if RTC_ENABLE_MEDIA
 	void triggerTrack(weak_ptr<Track> weakTrack);
+#endif
 
 	void triggerPendingDataChannels();
 	void triggerPendingTracks();
@@ -124,7 +130,9 @@ struct PeerConnection : std::enable_shared_from_this<PeerConnection> {
 	synchronized_callback<IceState> iceStateChangeCallback;
 	synchronized_callback<GatheringState> gatheringStateChangeCallback;
 	synchronized_callback<SignalingState> signalingStateChangeCallback;
+#if RTC_ENABLE_MEDIA
 	synchronized_callback<shared_ptr<rtc::Track>> trackCallback;
+#endif
 
 private:
 	void updateTrackSsrcCache(const Description &description);
@@ -137,10 +145,11 @@ private:
 	optional<Description> mCurrentLocalDescription;
 	mutable std::mutex mLocalDescriptionMutex, mRemoteDescriptionMutex;
 
+#if RTC_ENABLE_MEDIA
 	shared_ptr<MediaHandler> mMediaHandler;
 
 	mutable std::shared_mutex mMediaHandlerMutex;
-
+#endif
 	shared_ptr<IceTransport> mIceTransport;
 	shared_ptr<DtlsTransport> mDtlsTransport;
 	shared_ptr<SctpTransport> mSctpTransport;
@@ -149,13 +158,18 @@ private:
 	std::vector<weak_ptr<DataChannel>> mUnassignedDataChannels;
 	std::shared_mutex mDataChannelsMutex;
 
+#if RTC_ENABLE_MEDIA
 	std::unordered_map<string, weak_ptr<Track>> mTracks;         // by mid
 	std::unordered_map<uint32_t, weak_ptr<Track>> mTracksBySsrc; // by SSRC
 	std::vector<weak_ptr<Track>> mTrackLines;                    // by SDP order
 	std::shared_mutex mTracksMutex;
+#endif
 
 	Queue<shared_ptr<DataChannel>> mPendingDataChannels;
+
+#if RTC_ENABLE_MEDIA
 	Queue<shared_ptr<Track>> mPendingTracks;
+#endif
 };
 
 } // namespace rtc::impl
diff --git a/thirdparty/libdatachannel/src/impl/track.cpp b/thirdparty/libdatachannel/src/impl/track.cpp
deleted file mode 100644
index 99cdd5acd9..0000000000
--- a/thirdparty/libdatachannel/src/impl/track.cpp
+++ /dev/null
@@ -1,225 +0,0 @@
-/**
- * Copyright (c) 2020 Paul-Louis Ageneau
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#include "track.hpp"
-#include "internals.hpp"
-#include "logcounter.hpp"
-#include "peerconnection.hpp"
-#include "rtp.hpp"
-
-namespace rtc::impl {
-
-static LogCounter COUNTER_MEDIA_BAD_DIRECTION(plog::warning,
-                                              "Number of media packets sent in invalid directions");
-static LogCounter COUNTER_QUEUE_FULL(plog::warning,
-                                     "Number of media packets dropped due to a full queue");
-
-Track::Track(weak_ptr<PeerConnection> pc, Description::Media description)
-    : mPeerConnection(pc), mMediaDescription(std::move(description)),
-      mRecvQueue(RECV_QUEUE_LIMIT, [](const message_ptr &m) { return m->size(); }) {
-
-	// Discard messages by default if track is send only
-	if (mMediaDescription.direction() == Description::Direction::SendOnly)
-		messageCallback = [](message_variant) {};
-}
-
-Track::~Track() {
-	PLOG_VERBOSE << "Destroying Track";
-	try {
-		close();
-	} catch (const std::exception &e) {
-		PLOG_ERROR << e.what();
-	}
-}
-
-string Track::mid() const {
-	std::shared_lock lock(mMutex);
-	return mMediaDescription.mid();
-}
-
-Description::Direction Track::direction() const {
-	std::shared_lock lock(mMutex);
-	return mMediaDescription.direction();
-}
-
-Description::Media Track::description() const {
-	std::shared_lock lock(mMutex);
-	return mMediaDescription;
-}
-
-void Track::setDescription(Description::Media description) {
-	std::unique_lock lock(mMutex);
-	if (description.mid() != mMediaDescription.mid())
-		throw std::logic_error("Media description mid does not match track mid");
-
-	mMediaDescription = std::move(description);
-}
-
-void Track::close() {
-	PLOG_VERBOSE << "Closing Track";
-
-	if (!mIsClosed.exchange(true))
-		triggerClosed();
-
-	setMediaHandler(nullptr);
-	resetCallbacks();
-}
-
-optional<message_variant> Track::receive() {
-	if (auto next = mRecvQueue.pop()) {
-		message_ptr message = *next;
-		if (message->type == Message::Control)
-			return to_variant(**next); // The same message may be frowarded into multiple Tracks
-		else
-			return to_variant(std::move(*message));
-	}
-	return nullopt;
-}
-
-optional<message_variant> Track::peek() {
-	if (auto next = mRecvQueue.peek()) {
-		message_ptr message = *next;
-		if (message->type == Message::Control)
-			return to_variant(**next); // The same message may be forwarded into multiple Tracks
-		else
-			return to_variant(std::move(*message));
-	}
-	return nullopt;
-}
-
-size_t Track::availableAmount() const { return mRecvQueue.amount(); }
-
-bool Track::isOpen(void) const {
-#if RTC_ENABLE_MEDIA
-	std::shared_lock lock(mMutex);
-	return !mIsClosed && mDtlsSrtpTransport.lock();
-#else
-	return false;
-#endif
-}
-
-bool Track::isClosed(void) const { return mIsClosed; }
-
-size_t Track::maxMessageSize() const {
-	optional<size_t> mtu;
-	if (auto pc = mPeerConnection.lock())
-		mtu = pc->config.mtu;
-
-	return mtu.value_or(DEFAULT_MTU) - 12 - 8 - 40; // SRTP/UDP/IPv6
-}
-
-#if RTC_ENABLE_MEDIA
-void Track::open(shared_ptr<DtlsSrtpTransport> transport) {
-	{
-		std::lock_guard lock(mMutex);
-		mDtlsSrtpTransport = transport;
-	}
-
-	if (!mIsClosed)
-		triggerOpen();
-}
-#endif
-
-void Track::incoming(message_ptr message) {
-	if (!message)
-		return;
-
-	auto handler = getMediaHandler();
-
-	auto dir = direction();
-	if ((dir == Description::Direction::SendOnly || dir == Description::Direction::Inactive) &&
-	    message->type != Message::Control) {
-		COUNTER_MEDIA_BAD_DIRECTION++;
-		return;
-	}
-
-	if (handler) {
-		message = handler->incoming(message);
-		if (!message)
-			return;
-	}
-
-	// Tail drop if queue is full
-	if (mRecvQueue.full()) {
-		COUNTER_QUEUE_FULL++;
-		return;
-	}
-
-	mRecvQueue.push(message);
-	triggerAvailable(mRecvQueue.size());
-}
-
-bool Track::outgoing(message_ptr message) {
-	if (mIsClosed)
-		throw std::runtime_error("Track is closed");
-
-	auto handler = getMediaHandler();
-
-	// If there is no handler, the track expects RTP or RTCP packets
-	if (!handler && IsRtcp(*message))
-		message->type = Message::Control; // to allow sending RTCP packets irrelevant of direction
-
-	auto dir = direction();
-	if ((dir == Description::Direction::RecvOnly || dir == Description::Direction::Inactive) &&
-	    message->type != Message::Control) {
-		COUNTER_MEDIA_BAD_DIRECTION++;
-		return false;
-	}
-
-	if (handler) {
-		message = handler->outgoing(message);
-		if (!message)
-			return false;
-	}
-
-	return transportSend(message);
-}
-
-bool Track::transportSend([[maybe_unused]] message_ptr message) {
-#if RTC_ENABLE_MEDIA
-	shared_ptr<DtlsSrtpTransport> transport;
-	{
-		std::shared_lock lock(mMutex);
-		transport = mDtlsSrtpTransport.lock();
-		if (!transport)
-			throw std::runtime_error("Track is closed");
-
-		// Set recommended medium-priority DSCP value
-		// See https://www.rfc-editor.org/rfc/rfc8837.html#section-5
-		if (mMediaDescription.type() == "audio")
-			message->dscp = 46; // EF: Expedited Forwarding
-		else
-			message->dscp = 36; // AF42: Assured Forwarding class 4, medium drop probability
-	}
-
-	return transport->sendMedia(message);
-#else
-	throw std::runtime_error("Track is disabled (not compiled with media support)");
-#endif
-}
-
-void Track::setMediaHandler(shared_ptr<MediaHandler> handler) {
-	auto currentHandler = getMediaHandler();
-	if (currentHandler)
-		currentHandler->onOutgoing(nullptr);
-
-	{
-		std::unique_lock lock(mMutex);
-		mMediaHandler = handler;
-	}
-
-	if (handler)
-		handler->onOutgoing(std::bind(&Track::transportSend, this, std::placeholders::_1));
-}
-
-shared_ptr<MediaHandler> Track::getMediaHandler() {
-	std::shared_lock lock(mMutex);
-	return mMediaHandler;
-}
-
-} // namespace rtc::impl
diff --git a/thirdparty/libdatachannel/src/mediachainablehandler.cpp b/thirdparty/libdatachannel/src/mediachainablehandler.cpp
deleted file mode 100644
index 5094b52a69..0000000000
--- a/thirdparty/libdatachannel/src/mediachainablehandler.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/**
- * Copyright (c) 2020 Filip Klembara (in2core)
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_MEDIA
-
-#include "mediachainablehandler.hpp"
-
-#include "impl/internals.hpp"
-
-#include <cassert>
-
-namespace rtc {
-
-MediaChainableHandler::MediaChainableHandler(shared_ptr<MediaHandlerRootElement> root)
-    : MediaHandler(), root(root), leaf(root) {}
-
-MediaChainableHandler::~MediaChainableHandler() { leaf->recursiveRemoveChain(); }
-
-bool MediaChainableHandler::sendProduct(ChainedOutgoingProduct product) {
-	bool result = true;
-	if (product.control) {
-		assert(product.control->type == Message::Control);
-		auto sendResult = send(product.control);
-		if (!sendResult) {
-			LOG_DEBUG << "Failed to send control message";
-		}
-		result = result && sendResult;
-	}
-	if (product.messages) {
-		auto messages = product.messages;
-		for (unsigned i = 0; i < messages->size(); i++) {
-			auto message = messages->at(i);
-			if (!message) {
-				LOG_DEBUG << "Invalid message to send " << i + 1 << "/" << messages->size();
-			}
-			auto sendResult = send(make_message(*message));
-			if (!sendResult) {
-				LOG_DEBUG << "Failed to send message " << i + 1 << "/" << messages->size();
-			}
-			result = result && sendResult;
-		}
-	}
-	return result;
-}
-
-message_ptr MediaChainableHandler::handleIncomingBinary(message_ptr msg) {
-	assert(msg->type == Message::Binary);
-	auto messages = root->split(msg);
-	auto incoming = getLeaf()->formIncomingBinaryMessage(
-	    messages, [this](ChainedOutgoingProduct outgoing) { return sendProduct(outgoing); });
-	if (incoming) {
-		return root->reduce(incoming);
-	} else {
-		return nullptr;
-	}
-}
-
-message_ptr MediaChainableHandler::handleIncomingControl(message_ptr msg) {
-	assert(msg->type == Message::Control);
-	auto incoming = getLeaf()->formIncomingControlMessage(
-	    msg, [this](ChainedOutgoingProduct outgoing) { return sendProduct(outgoing); });
-	assert(!incoming || incoming->type == Message::Control);
-	return incoming;
-}
-
-message_ptr MediaChainableHandler::handleOutgoingBinary(message_ptr msg) {
-	assert(msg->type == Message::Binary);
-	auto messages = make_chained_messages_product(msg);
-	auto optOutgoing = root->formOutgoingBinaryMessage(ChainedOutgoingProduct(messages));
-	if (!optOutgoing.has_value()) {
-		LOG_ERROR << "Generating outgoing message failed";
-		return nullptr;
-	}
-	auto outgoing = optOutgoing.value();
-	if (outgoing.control) {
-		if (!send(outgoing.control)) {
-			LOG_DEBUG << "Failed to send control message";
-		}
-	}
-	auto lastMessage = outgoing.messages->back();
-	if (!lastMessage) {
-		LOG_DEBUG << "Invalid message to send";
-		return nullptr;
-	}
-	for (unsigned i = 0; i < outgoing.messages->size() - 1; i++) {
-		auto message = outgoing.messages->at(i);
-		if (!message) {
-			LOG_DEBUG << "Invalid message to send " << i + 1 << "/" << outgoing.messages->size();
-		}
-		if (!send(make_message(*message))) {
-			LOG_DEBUG << "Failed to send message " << i + 1 << "/" << outgoing.messages->size();
-		}
-	}
-	return make_message(*lastMessage);
-}
-
-message_ptr MediaChainableHandler::handleOutgoingControl(message_ptr msg) {
-	assert(msg->type == Message::Control);
-	auto outgoing = root->formOutgoingControlMessage(msg);
-	assert(!outgoing || outgoing->type == Message::Control);
-	if (!outgoing) {
-		LOG_ERROR << "Generating outgoing control message failed";
-		return nullptr;
-	}
-	return outgoing;
-}
-
-message_ptr MediaChainableHandler::outgoing(message_ptr ptr) {
-	assert(ptr);
-	if (!ptr) {
-		LOG_ERROR << "Outgoing message is nullptr, ignoring";
-		return nullptr;
-	}
-	if (ptr->type == Message::Binary) {
-		return handleOutgoingBinary(ptr);
-	} else if (ptr->type == Message::Control) {
-		return handleOutgoingControl(ptr);
-	}
-	return ptr;
-}
-
-message_ptr MediaChainableHandler::incoming(message_ptr ptr) {
-	if (!ptr) {
-		LOG_ERROR << "Incoming message is nullptr, ignoring";
-		return nullptr;
-	}
-	if (ptr->type == Message::Binary) {
-		return handleIncomingBinary(ptr);
-	} else if (ptr->type == Message::Control) {
-		return handleIncomingControl(ptr);
-	}
-	return ptr;
-}
-
-bool MediaChainableHandler::send(message_ptr msg) {
-	try {
-		outgoingCallback(std::move(msg));
-		return true;
-	} catch (const std::exception &e) {
-		LOG_DEBUG << "Send in RTCP chain handler failed: " << e.what();
-	}
-	return false;
-}
-
-shared_ptr<MediaHandlerElement> MediaChainableHandler::getLeaf() const {
-	std::lock_guard lock(mutex);
-	return leaf;
-}
-
-void MediaChainableHandler::addToChain(shared_ptr<MediaHandlerElement> chainable) {
-	std::lock_guard lock(mutex);
-	assert(leaf);
-	leaf = leaf->chainWith(chainable);
-}
-
-} // namespace rtc
-
-#endif /* RTC_ENABLE_MEDIA */
diff --git a/thirdparty/libdatachannel/src/mediahandlerelement.cpp b/thirdparty/libdatachannel/src/mediahandlerelement.cpp
deleted file mode 100644
index 5ec13ce2e5..0000000000
--- a/thirdparty/libdatachannel/src/mediahandlerelement.cpp
+++ /dev/null
@@ -1,211 +0,0 @@
-/**
- * Copyright (c) 2020 Filip Klembara (in2core)
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_MEDIA
-
-#include "mediahandlerelement.hpp"
-
-#include "impl/internals.hpp"
-
-#include <cassert>
-
-namespace rtc {
-
-ChainedMessagesProduct make_chained_messages_product() {
-	return std::make_shared<std::vector<binary_ptr>>();
-}
-
-ChainedMessagesProduct make_chained_messages_product(message_ptr msg) {
-	std::vector<binary_ptr> msgs = {msg};
-	return std::make_shared<std::vector<binary_ptr>>(msgs);
-}
-
-ChainedOutgoingProduct::ChainedOutgoingProduct(ChainedMessagesProduct messages, message_ptr control)
-    : messages(messages), control(control) {}
-
-ChainedIncomingProduct::ChainedIncomingProduct(ChainedMessagesProduct incoming,
-                                               ChainedMessagesProduct outgoing)
-    : incoming(incoming), outgoing(outgoing) {}
-
-ChainedIncomingControlProduct::ChainedIncomingControlProduct(
-    message_ptr incoming, optional<ChainedOutgoingProduct> outgoing)
-    : incoming(incoming), outgoing(outgoing) {}
-
-MediaHandlerElement::MediaHandlerElement() {}
-
-void MediaHandlerElement::removeFromChain() {
-	if (upstream) {
-		upstream->downstream = downstream;
-	}
-	if (downstream) {
-		downstream->upstream = upstream;
-	}
-	upstream = nullptr;
-	downstream = nullptr;
-}
-
-void MediaHandlerElement::recursiveRemoveChain() {
-	if (downstream) {
-		// `recursiveRemoveChain` removes last strong reference to downstream element
-		// we need to keep strong reference to prevent deallocation of downstream element
-		// during `recursiveRemoveChain`
-		auto strongDownstreamPtr = downstream;
-		downstream->recursiveRemoveChain();
-	}
-	removeFromChain();
-}
-
-optional<ChainedOutgoingProduct>
-MediaHandlerElement::processOutgoingResponse(ChainedOutgoingProduct messages) {
-	if (messages.messages) {
-		if (upstream) {
-			auto msgs = upstream->formOutgoingBinaryMessage(
-			    ChainedOutgoingProduct(messages.messages, messages.control));
-			if (msgs.has_value()) {
-				return msgs.value();
-			} else {
-				LOG_ERROR << "Generating outgoing message failed";
-				return nullopt;
-			}
-		} else {
-			return messages;
-		}
-	} else if (messages.control) {
-		if (upstream) {
-			auto control = upstream->formOutgoingControlMessage(messages.control);
-			if (control) {
-				return ChainedOutgoingProduct(nullptr, control);
-			} else {
-				LOG_ERROR << "Generating outgoing control message failed";
-				return nullopt;
-			}
-		} else {
-			return messages;
-		}
-	} else {
-		return ChainedOutgoingProduct();
-	}
-}
-
-void MediaHandlerElement::prepareAndSendResponse(optional<ChainedOutgoingProduct> outgoing,
-                                                 std::function<bool(ChainedOutgoingProduct)> send) {
-	if (outgoing.has_value()) {
-		auto message = outgoing.value();
-		auto response = processOutgoingResponse(message);
-		if (response.has_value()) {
-			if (!send(response.value())) {
-				LOG_DEBUG << "Send failed";
-			}
-		} else {
-			LOG_DEBUG << "No response to send";
-		}
-	}
-}
-
-message_ptr
-MediaHandlerElement::formIncomingControlMessage(message_ptr message,
-                                                std::function<bool(ChainedOutgoingProduct)> send) {
-	assert(message);
-	auto product = processIncomingControlMessage(message);
-	prepareAndSendResponse(product.outgoing, send);
-	if (product.incoming) {
-		if (downstream) {
-			return downstream->formIncomingControlMessage(product.incoming, send);
-		} else {
-			return product.incoming;
-		}
-	} else {
-		return nullptr;
-	}
-}
-
-ChainedMessagesProduct
-MediaHandlerElement::formIncomingBinaryMessage(ChainedMessagesProduct messages,
-                                               std::function<bool(ChainedOutgoingProduct)> send) {
-	assert(messages);
-	auto product = processIncomingBinaryMessage(messages);
-	prepareAndSendResponse(product.outgoing, send);
-	if (product.incoming) {
-		if (downstream) {
-			return downstream->formIncomingBinaryMessage(product.incoming, send);
-		} else {
-			return product.incoming;
-		}
-	} else {
-		return nullptr;
-	}
-}
-
-message_ptr MediaHandlerElement::formOutgoingControlMessage(message_ptr message) {
-	assert(message);
-	auto newMessage = processOutgoingControlMessage(message);
-	assert(newMessage);
-	if (!newMessage) {
-		LOG_ERROR << "Failed to generate outgoing message";
-		return nullptr;
-	}
-	if (upstream) {
-		return upstream->formOutgoingControlMessage(newMessage);
-	} else {
-		return newMessage;
-	}
-}
-
-optional<ChainedOutgoingProduct>
-MediaHandlerElement::formOutgoingBinaryMessage(ChainedOutgoingProduct product) {
-	assert(product.messages && !product.messages->empty());
-	auto newProduct = processOutgoingBinaryMessage(product.messages, product.control);
-	assert(!product.control || newProduct.control);
-	assert(newProduct.messages && !newProduct.messages->empty());
-	if (product.control && !newProduct.control) {
-		LOG_ERROR << "Outgoing message must not remove control message";
-		return nullopt;
-	}
-	if (!newProduct.messages || newProduct.messages->empty()) {
-		LOG_ERROR << "Failed to generate message";
-		return nullopt;
-	}
-	if (upstream) {
-		return upstream->formOutgoingBinaryMessage(newProduct);
-	} else {
-		return newProduct;
-	}
-}
-
-ChainedIncomingControlProduct
-MediaHandlerElement::processIncomingControlMessage(message_ptr messages) {
-	return {messages};
-}
-
-message_ptr MediaHandlerElement::processOutgoingControlMessage(message_ptr messages) {
-	return messages;
-}
-
-ChainedIncomingProduct
-MediaHandlerElement::processIncomingBinaryMessage(ChainedMessagesProduct messages) {
-	return {messages};
-}
-
-ChainedOutgoingProduct
-MediaHandlerElement::processOutgoingBinaryMessage(ChainedMessagesProduct messages,
-                                                  message_ptr control) {
-	return {messages, control};
-}
-
-shared_ptr<MediaHandlerElement>
-MediaHandlerElement::chainWith(shared_ptr<MediaHandlerElement> upstream) {
-	assert(this->upstream == nullptr);
-	assert(upstream->downstream == nullptr);
-	this->upstream = upstream;
-	upstream->downstream = shared_from_this();
-	return upstream;
-}
-
-} // namespace rtc
-
-#endif /* RTC_ENABLE_MEDIA */
diff --git a/thirdparty/libdatachannel/src/mediahandlerrootelement.cpp b/thirdparty/libdatachannel/src/mediahandlerrootelement.cpp
deleted file mode 100644
index ccdfc5d090..0000000000
--- a/thirdparty/libdatachannel/src/mediahandlerrootelement.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Copyright (c) 2020 Filip Klembara (in2core)
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_MEDIA
-
-#include "mediahandlerrootelement.hpp"
-
-namespace rtc {
-
-message_ptr MediaHandlerRootElement::reduce(ChainedMessagesProduct messages) {
-	if (messages && !messages->empty()) {
-		auto msg_ptr = messages->front();
-		if (msg_ptr) {
-			return make_message(*msg_ptr);
-		} else {
-			return nullptr;
-		}
-	} else {
-		return nullptr;
-	}
-}
-
-ChainedMessagesProduct MediaHandlerRootElement::split(message_ptr message) {
-	return make_chained_messages_product(message);
-}
-
-} // namespace rtc
-
-#endif /* RTC_ENABLE_MEDIA */
diff --git a/thirdparty/libdatachannel/src/nalunit.cpp b/thirdparty/libdatachannel/src/nalunit.cpp
deleted file mode 100644
index a638beb202..0000000000
--- a/thirdparty/libdatachannel/src/nalunit.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Copyright (c) 2020 Filip Klembara (in2core)
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_MEDIA
-
-#include "nalunit.hpp"
-
-#include "impl/internals.hpp"
-
-#include <cmath>
-
-namespace rtc {
-
-NalUnitFragmentA::NalUnitFragmentA(FragmentType type, bool forbiddenBit, uint8_t nri,
-                                   uint8_t unitType, binary data)
-    : NalUnit(data.size() + 2) {
-	setForbiddenBit(forbiddenBit);
-	setNRI(nri);
-	fragmentIndicator()->setUnitType(NalUnitFragmentA::nal_type_fu_A);
-	setFragmentType(type);
-	setUnitType(unitType);
-	copy(data.begin(), data.end(), begin() + 2);
-}
-
-std::vector<shared_ptr<NalUnitFragmentA>>
-NalUnitFragmentA::fragmentsFrom(shared_ptr<NalUnit> nalu, uint16_t maximumFragmentSize) {
-	assert(nalu->size() > maximumFragmentSize);
-	auto fragments_count = ceil(double(nalu->size()) / maximumFragmentSize);
-	maximumFragmentSize = uint16_t(int(ceil(nalu->size() / fragments_count)));
-
-	// 2 bytes for FU indicator and FU header
-	maximumFragmentSize -= 2;
-	auto f = nalu->forbiddenBit();
-	uint8_t nri = nalu->nri() & 0x03;
-	uint8_t naluType = nalu->unitType() & 0x1F;
-	auto payload = nalu->payload();
-	vector<shared_ptr<NalUnitFragmentA>> result{};
-	uint64_t offset = 0;
-	while (offset < payload.size()) {
-		vector<byte> fragmentData;
-		FragmentType fragmentType;
-		if (offset == 0) {
-			fragmentType = FragmentType::Start;
-		} else if (offset + maximumFragmentSize < payload.size()) {
-			fragmentType = FragmentType::Middle;
-		} else {
-			if (offset + maximumFragmentSize > payload.size()) {
-				maximumFragmentSize = uint16_t(payload.size() - offset);
-			}
-			fragmentType = FragmentType::End;
-		}
-		fragmentData = {payload.begin() + offset, payload.begin() + offset + maximumFragmentSize};
-		auto fragment =
-		    std::make_shared<NalUnitFragmentA>(fragmentType, f, nri, naluType, fragmentData);
-		result.push_back(fragment);
-		offset += maximumFragmentSize;
-	}
-	return result;
-}
-
-void NalUnitFragmentA::setFragmentType(FragmentType type) {
-	fragmentHeader()->setReservedBit6(false);
-	switch (type) {
-	case FragmentType::Start:
-		fragmentHeader()->setStart(true);
-		fragmentHeader()->setEnd(false);
-		break;
-	case FragmentType::End:
-		fragmentHeader()->setStart(false);
-		fragmentHeader()->setEnd(true);
-		break;
-	default:
-		fragmentHeader()->setStart(false);
-		fragmentHeader()->setEnd(false);
-	}
-}
-
-std::vector<shared_ptr<binary>> NalUnits::generateFragments(uint16_t maximumFragmentSize) {
-	vector<shared_ptr<binary>> result{};
-	for (auto nalu : *this) {
-		if (nalu->size() > maximumFragmentSize) {
-			std::vector<shared_ptr<NalUnitFragmentA>> fragments =
-			    NalUnitFragmentA::fragmentsFrom(nalu, maximumFragmentSize);
-			result.insert(result.end(), fragments.begin(), fragments.end());
-		} else {
-			result.push_back(nalu);
-		}
-	}
-	return result;
-}
-
-} // namespace rtc
-
-#endif /* RTC_ENABLE_MEDIA */
diff --git a/thirdparty/libdatachannel/src/peerconnection.cpp b/thirdparty/libdatachannel/src/peerconnection.cpp
index 6395f909df..bde4fb013c 100644
--- a/thirdparty/libdatachannel/src/peerconnection.cpp
+++ b/thirdparty/libdatachannel/src/peerconnection.cpp
@@ -247,11 +247,13 @@ void PeerConnection::addRemoteCandidate(Candidate candidate) {
 	impl()->processRemoteCandidate(std::move(candidate));
 }
 
+#if RTC_ENABLE_MEDIA
 void PeerConnection::setMediaHandler(shared_ptr<MediaHandler> handler) {
 	impl()->setMediaHandler(std::move(handler));
 };
 
 shared_ptr<MediaHandler> PeerConnection::getMediaHandler() { return impl()->getMediaHandler(); };
+#endif
 
 optional<string> PeerConnection::localAddress() const {
 	auto iceTransport = impl()->getIceTransport();
@@ -286,6 +288,7 @@ void PeerConnection::onDataChannel(
 	impl()->flushPendingDataChannels();
 }
 
+#if RTC_ENABLE_MEDIA
 std::shared_ptr<Track> PeerConnection::addTrack(Description::Media description) {
 	auto trackImpl = impl()->emplaceTrack(std::move(description));
 	auto track = std::make_shared<Track>(trackImpl);
@@ -300,6 +303,7 @@ void PeerConnection::onTrack(std::function<void(std::shared_ptr<Track>)> callbac
 	impl()->trackCallback = callback;
 	impl()->flushPendingTracks();
 }
+#endif
 
 void PeerConnection::onLocalDescription(std::function<void(Description description)> callback) {
 	impl()->localDescriptionCallback = callback;
diff --git a/thirdparty/libdatachannel/src/rtcpnackresponder.cpp b/thirdparty/libdatachannel/src/rtcpnackresponder.cpp
deleted file mode 100644
index efae6d94a4..0000000000
--- a/thirdparty/libdatachannel/src/rtcpnackresponder.cpp
+++ /dev/null
@@ -1,122 +0,0 @@
-/**
- * Copyright (c) 2020 Filip Klembara (in2core)
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_MEDIA
-
-#include "rtcpnackresponder.hpp"
-
-#include "impl/internals.hpp"
-
-#include <cassert>
-
-namespace rtc {
-
-RtcpNackResponder::Storage::Element::Element(binary_ptr packet, uint16_t sequenceNumber,
-                                             shared_ptr<Element> next)
-    : packet(packet), sequenceNumber(sequenceNumber), next(next) {}
-
-unsigned RtcpNackResponder::Storage::size() { return unsigned(storage.size()); }
-
-RtcpNackResponder::Storage::Storage(unsigned _maximumSize) : maximumSize(_maximumSize) {
-	assert(maximumSize > 0);
-	storage.reserve(maximumSize);
-}
-
-optional<binary_ptr> RtcpNackResponder::Storage::get(uint16_t sequenceNumber) {
-	std::lock_guard lock(mutex);
-	auto position = storage.find(sequenceNumber);
-	return position != storage.end() ? std::make_optional(storage.at(sequenceNumber)->packet)
-	                                 : nullopt;
-}
-
-void RtcpNackResponder::Storage::store(binary_ptr packet) {
-	if (!packet || packet->size() < 12) {
-		return;
-	}
-	auto rtp = reinterpret_cast<RtpHeader *>(packet->data());
-	auto sequenceNumber = rtp->seqNumber();
-
-	std::lock_guard lock(mutex);
-	assert((storage.empty() && !oldest && !newest) || (!storage.empty() && oldest && newest));
-
-	if (size() == 0) {
-		newest = std::make_shared<Element>(packet, sequenceNumber);
-		oldest = newest;
-	} else {
-		auto current = std::make_shared<Element>(packet, sequenceNumber);
-		newest->next = current;
-		newest = current;
-	}
-
-	storage.emplace(sequenceNumber, newest);
-
-	if (size() > maximumSize) {
-		assert(oldest);
-		if (oldest) {
-			storage.erase(oldest->sequenceNumber);
-			oldest = oldest->next;
-		}
-	}
-}
-
-RtcpNackResponder::RtcpNackResponder(unsigned maxStoredPacketCount)
-    : MediaHandlerElement(), storage(std::make_shared<Storage>(maxStoredPacketCount)) {}
-
-ChainedIncomingControlProduct
-RtcpNackResponder::processIncomingControlMessage(message_ptr message) {
-	optional<ChainedOutgoingProduct> optPackets = ChainedOutgoingProduct(nullptr);
-	auto packets = make_chained_messages_product();
-
-	size_t p = 0;
-	while (p < message->size()) {
-		auto nack = reinterpret_cast<RtcpNack *>(message->data() + p);
-		p += nack->header.header.lengthInBytes();
-		// check if rtcp is nack
-		if (nack->header.header.payloadType() != 205 || nack->header.header.reportCount() != 1) {
-			continue;
-		}
-
-		auto fieldsCount = nack->getSeqNoCount();
-
-		std::vector<uint16_t> missingSequenceNumbers{};
-		for (unsigned int i = 0; i < fieldsCount; i++) {
-			auto field = nack->parts[i];
-			auto newMissingSeqenceNumbers = field.getSequenceNumbers();
-			missingSequenceNumbers.insert(missingSequenceNumbers.end(),
-			                              newMissingSeqenceNumbers.begin(),
-			                              newMissingSeqenceNumbers.end());
-		}
-		packets->reserve(packets->size() + missingSequenceNumbers.size());
-		for (auto sequenceNumber : missingSequenceNumbers) {
-			auto optPacket = storage->get(sequenceNumber);
-			if (optPacket.has_value()) {
-				auto packet = optPacket.value();
-				packets->push_back(packet);
-			}
-		}
-	}
-
-	if (!packets->empty()) {
-		return {message, ChainedOutgoingProduct(packets)};
-	} else {
-		return {message, nullopt};
-	}
-}
-
-ChainedOutgoingProduct
-RtcpNackResponder::processOutgoingBinaryMessage(ChainedMessagesProduct messages,
-                                                message_ptr control) {
-	for (auto message : *messages) {
-		storage->store(message);
-	}
-	return {messages, control};
-}
-
-} // namespace rtc
-
-#endif /* RTC_ENABLE_MEDIA */
diff --git a/thirdparty/libdatachannel/src/rtcpreceivingsession.cpp b/thirdparty/libdatachannel/src/rtcpreceivingsession.cpp
deleted file mode 100644
index 0ae719199a..0000000000
--- a/thirdparty/libdatachannel/src/rtcpreceivingsession.cpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/**
- * Copyright (c) 2020 Staz Modrzynski
- * Copyright (c) 2020 Paul-Louis Ageneau
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_MEDIA
-
-#include "rtcpreceivingsession.hpp"
-#include "track.hpp"
-
-#include "impl/logcounter.hpp"
-
-#include <cmath>
-#include <utility>
-
-#ifdef _WIN32
-#include <winsock2.h>
-#else
-#include <arpa/inet.h>
-#endif
-
-namespace rtc {
-
-static impl::LogCounter COUNTER_BAD_RTP_HEADER(plog::warning, "Number of malformed RTP headers");
-static impl::LogCounter COUNTER_UNKNOWN_PPID(plog::warning, "Number of Unknown PPID messages");
-static impl::LogCounter COUNTER_BAD_NOTIF_LEN(plog::warning,
-                                              "Number of Bad-Lengthed notifications");
-static impl::LogCounter COUNTER_BAD_SCTP_STATUS(plog::warning,
-                                                "Number of unknown SCTP_STATUS errors");
-
-message_ptr RtcpReceivingSession::outgoing(message_ptr ptr) { return ptr; }
-
-message_ptr RtcpReceivingSession::incoming(message_ptr ptr) {
-	if (ptr->type == Message::Binary) {
-		auto rtp = reinterpret_cast<const RtpHeader *>(ptr->data());
-
-		// https://www.rfc-editor.org/rfc/rfc3550.html#appendix-A.1
-		if (rtp->version() != 2) {
-			COUNTER_BAD_RTP_HEADER++;
-			PLOG_VERBOSE << "RTP packet is not version 2";
-
-			return nullptr;
-		}
-		if (rtp->payloadType() == 201 || rtp->payloadType() == 200) {
-			COUNTER_BAD_RTP_HEADER++;
-			PLOG_VERBOSE << "RTP packet has a payload type indicating RR/SR";
-
-			return nullptr;
-		}
-
-		// Padding-processing is a user-level thing
-
-		mSsrc = rtp->ssrc();
-
-		return ptr;
-	}
-
-	assert(ptr->type == Message::Control);
-	auto rr = reinterpret_cast<const RtcpRr *>(ptr->data());
-	if (rr->header.payloadType() == 201) {
-		// RR
-		mSsrc = rr->senderSSRC();
-		rr->log();
-	} else if (rr->header.payloadType() == 200) {
-		// SR
-		mSsrc = rr->senderSSRC();
-		auto sr = reinterpret_cast<const RtcpSr *>(ptr->data());
-		mSyncRTPTS = sr->rtpTimestamp();
-		mSyncNTPTS = sr->ntpTimestamp();
-		sr->log();
-
-		// TODO For the time being, we will send RR's/REMB's when we get an SR
-		pushRR(0);
-		if (mRequestedBitrate > 0)
-			pushREMB(mRequestedBitrate);
-	}
-	return nullptr;
-}
-
-void RtcpReceivingSession::requestBitrate(unsigned int newBitrate) {
-	mRequestedBitrate = newBitrate;
-
-	PLOG_DEBUG << "[GOOG-REMB] Requesting bitrate: " << newBitrate << std::endl;
-	pushREMB(newBitrate);
-}
-
-void RtcpReceivingSession::pushREMB(unsigned int bitrate) {
-	message_ptr msg = make_message(RtcpRemb::SizeWithSSRCs(1), Message::Control);
-	auto remb = reinterpret_cast<RtcpRemb *>(msg->data());
-	remb->preparePacket(mSsrc, 1, bitrate);
-	remb->setSsrc(0, mSsrc);
-
-	send(msg);
-}
-
-void RtcpReceivingSession::pushRR(unsigned int lastSR_delay) {
-	auto msg = make_message(RtcpRr::SizeWithReportBlocks(1), Message::Control);
-	auto rr = reinterpret_cast<RtcpRr *>(msg->data());
-	rr->preparePacket(mSsrc, 1);
-	rr->getReportBlock(0)->preparePacket(mSsrc, 0, 0, uint16_t(mGreatestSeqNo), 0, 0, mSyncNTPTS,
-	                                     lastSR_delay);
-	rr->log();
-
-	send(msg);
-}
-
-bool RtcpReceivingSession::send(message_ptr msg) {
-	try {
-		outgoingCallback(std::move(msg));
-		return true;
-	} catch (const std::exception &e) {
-		LOG_DEBUG << "RTCP tx failed: " << e.what();
-	}
-	return false;
-}
-
-bool RtcpReceivingSession::requestKeyframe() {
-	pushPLI();
-	return true;
-}
-
-void RtcpReceivingSession::pushPLI() {
-	auto msg = make_message(RtcpPli::Size(), Message::Control);
-	auto *pli = reinterpret_cast<RtcpPli *>(msg->data());
-	pli->preparePacket(mSsrc);
-	send(msg);
-}
-
-} // namespace rtc
-
-#endif // RTC_ENABLE_MEDIA
diff --git a/thirdparty/libdatachannel/src/rtcpsrreporter.cpp b/thirdparty/libdatachannel/src/rtcpsrreporter.cpp
deleted file mode 100644
index 6bf8d65fe8..0000000000
--- a/thirdparty/libdatachannel/src/rtcpsrreporter.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/**
- * Copyright (c) 2020 Filip Klembara (in2core)
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_MEDIA
-
-#include "rtcpsrreporter.hpp"
-
-#include <cassert>
-#include <chrono>
-#include <cmath>
-
-namespace {
-
-uint64_t ntp_time() {
-	const auto now = std::chrono::system_clock::now();
-	const double secs = std::chrono::duration<double>(now.time_since_epoch()).count();
-	// Assume the epoch is 01/01/1970 and adds the number of seconds between 1900 and 1970
-	return uint64_t(std::floor((secs + 2208988800.) * double(uint64_t(1) << 32)));
-}
-
-} // namespace
-
-namespace rtc {
-
-ChainedOutgoingProduct RtcpSrReporter::processOutgoingBinaryMessage(ChainedMessagesProduct messages,
-                                                                    message_ptr control) {
-	if (std::exchange(mNeedsToReport, false)) {
-		auto timestamp = rtpConfig->timestamp;
-		auto sr = getSenderReport(timestamp);
-		if (control) {
-			control->insert(control->end(), sr->begin(), sr->end());
-		} else {
-			control = sr;
-		}
-	}
-	for (auto message : *messages) {
-		auto rtp = reinterpret_cast<RtpHeader *>(message->data());
-		addToReport(rtp, uint32_t(message->size()));
-	}
-	return {messages, control};
-}
-
-void RtcpSrReporter::addToReport(RtpHeader *rtp, uint32_t rtpSize) {
-	mPacketCount += 1;
-	assert(!rtp->padding());
-	mPayloadOctets += rtpSize - uint32_t(rtp->getSize());
-}
-
-RtcpSrReporter::RtcpSrReporter(shared_ptr<RtpPacketizationConfig> rtpConfig)
-    : MediaHandlerElement(), rtpConfig(rtpConfig) {
-	mLastReportedTimestamp = rtpConfig->timestamp;
-}
-
-message_ptr RtcpSrReporter::getSenderReport(uint32_t timestamp) {
-	auto srSize = RtcpSr::Size(0);
-	auto msg = make_message(srSize + RtcpSdes::Size({{uint8_t(rtpConfig->cname.size())}}),
-	                        Message::Control);
-	auto sr = reinterpret_cast<RtcpSr *>(msg->data());
-	sr->setNtpTimestamp(ntp_time());
-	sr->setRtpTimestamp(timestamp);
-	sr->setPacketCount(mPacketCount);
-	sr->setOctetCount(mPayloadOctets);
-	sr->preparePacket(rtpConfig->ssrc, 0);
-
-	auto sdes = reinterpret_cast<RtcpSdes *>(msg->data() + srSize);
-	auto chunk = sdes->getChunk(0);
-	chunk->setSSRC(rtpConfig->ssrc);
-	auto item = chunk->getItem(0);
-	item->type = 1;
-	item->setText(rtpConfig->cname);
-	sdes->preparePacket(1);
-
-	mLastReportedTimestamp = timestamp;
-	return msg;
-}
-
-void RtcpSrReporter::setNeedsToReport() { mNeedsToReport = true; }
-
-uint32_t RtcpSrReporter::lastReportedTimestamp() const { return mLastReportedTimestamp; }
-
-} // namespace rtc
-
-#endif /* RTC_ENABLE_MEDIA */
diff --git a/thirdparty/libdatachannel/src/rtp.cpp b/thirdparty/libdatachannel/src/rtp.cpp
deleted file mode 100644
index bedfb18f47..0000000000
--- a/thirdparty/libdatachannel/src/rtp.cpp
+++ /dev/null
@@ -1,662 +0,0 @@
-/**
- * Copyright (c) 2020 Staz Modrzynski
- * Copyright (c) 2020 Paul-Louis Ageneau
- * Copyright (c) 2020 Filip Klembara (in2core)
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#include "rtp.hpp"
-
-#include "impl/internals.hpp"
-
-#include <cmath>
-#include <cstring>
-
-#ifdef _WIN32
-#include <winsock2.h>
-#else
-#include <arpa/inet.h>
-#endif
-
-#ifndef htonll
-#define htonll(x)                                                                                  \
-	((uint64_t)(((uint64_t)htonl((uint32_t)(x))) << 32) | (uint64_t)htonl((uint32_t)((x) >> 32)))
-#endif
-#ifndef ntohll
-#define ntohll(x) htonll(x)
-#endif
-
-namespace rtc {
-
-bool IsRtcp(const binary &data) {
-	if (data.size() < 8)
-		return false;
-
-	uint8_t payloadType = std::to_integer<uint8_t>(data[1]) & 0x7F;
-	PLOG_VERBOSE << "Demultiplexing RTCP and RTP with payload type, value=" << int(payloadType);
-
-	// RFC 5761 Multiplexing RTP and RTCP 4. Distinguishable RTP and RTCP Packets
-	// https://www.rfc-editor.org/rfc/rfc5761.html#section-4
-	// It is RECOMMENDED to follow the guidelines in the RTP/AVP profile for the choice of RTP
-	// payload type values, with the additional restriction that payload type values in the
-	// range 64-95 MUST NOT be used. Specifically, dynamic RTP payload types SHOULD be chosen in
-	// the range 96-127 where possible. Values below 64 MAY be used if that is insufficient
-	// [...]
-	return (payloadType >= 64 && payloadType <= 95); // Range 64-95 (inclusive) MUST be RTCP
-}
-
-uint8_t RtpHeader::version() const { return _first >> 6; }
-bool RtpHeader::padding() const { return (_first >> 5) & 0x01; }
-bool RtpHeader::extension() const { return (_first >> 4) & 0x01; }
-uint8_t RtpHeader::csrcCount() const { return _first & 0x0F; }
-uint8_t RtpHeader::marker() const { return _payloadType & 0b10000000; }
-uint8_t RtpHeader::payloadType() const { return _payloadType & 0b01111111; }
-uint16_t RtpHeader::seqNumber() const { return ntohs(_seqNumber); }
-uint32_t RtpHeader::timestamp() const { return ntohl(_timestamp); }
-uint32_t RtpHeader::ssrc() const { return ntohl(_ssrc); }
-
-size_t RtpHeader::getSize() const {
-	return reinterpret_cast<const char *>(&_ssrc + 1 + csrcCount()) -
-	       reinterpret_cast<const char *>(this);
-}
-
-size_t RtpHeader::getExtensionHeaderSize() const {
-	auto header = getExtensionHeader();
-	return header ? header->getSize() + sizeof(RtpExtensionHeader) : 0;
-}
-
-const RtpExtensionHeader *RtpHeader::getExtensionHeader() const {
-	return extension() ? reinterpret_cast<const RtpExtensionHeader *>(&_ssrc + 1 + csrcCount())
-	                   : nullptr;
-}
-
-RtpExtensionHeader *RtpHeader::getExtensionHeader() {
-	return extension() ? reinterpret_cast<RtpExtensionHeader *>(&_ssrc + 1 + csrcCount()) : nullptr;
-}
-
-const char *RtpHeader::getBody() const {
-	return reinterpret_cast<const char *>(&_ssrc + 1 + csrcCount()) + getExtensionHeaderSize();
-}
-
-char *RtpHeader::getBody() {
-	return reinterpret_cast<char *>(&_ssrc + 1 + csrcCount()) + getExtensionHeaderSize();
-}
-
-void RtpHeader::preparePacket() { _first |= (1 << 7); }
-
-void RtpHeader::setSeqNumber(uint16_t newSeqNo) { _seqNumber = htons(newSeqNo); }
-
-void RtpHeader::setPayloadType(uint8_t newPayloadType) {
-	_payloadType = (_payloadType & 0b10000000u) | (0b01111111u & newPayloadType);
-}
-
-void RtpHeader::setSsrc(uint32_t in_ssrc) { _ssrc = htonl(in_ssrc); }
-
-void RtpHeader::setMarker(bool marker) { _payloadType = (_payloadType & 0x7F) | (marker << 7); };
-
-void RtpHeader::setTimestamp(uint32_t i) { _timestamp = htonl(i); }
-
-void RtpHeader::setExtension(bool extension) { _first = (_first & ~0x10) | ((extension & 1) << 4); }
-
-void RtpHeader::log() const {
-	PLOG_VERBOSE << "RtpHeader V: " << (int)version() << " P: " << (padding() ? "P" : " ")
-	             << " X: " << (extension() ? "X" : " ") << " CC: " << (int)csrcCount()
-	             << " M: " << (marker() ? "M" : " ") << " PT: " << (int)payloadType()
-	             << " SEQNO: " << seqNumber() << " TS: " << timestamp();
-}
-
-uint16_t RtpExtensionHeader::profileSpecificId() const { return ntohs(_profileSpecificId); }
-
-uint16_t RtpExtensionHeader::headerLength() const { return ntohs(_headerLength); }
-
-size_t RtpExtensionHeader::getSize() const { return headerLength() * 4; }
-
-const char *RtpExtensionHeader::getBody() const {
-	return reinterpret_cast<const char *>((&_headerLength) + 1);
-}
-
-char *RtpExtensionHeader::getBody() { return reinterpret_cast<char *>((&_headerLength) + 1); }
-
-void RtpExtensionHeader::setProfileSpecificId(uint16_t profileSpecificId) {
-	_profileSpecificId = htons(profileSpecificId);
-}
-
-void RtpExtensionHeader::setHeaderLength(uint16_t headerLength) {
-	_headerLength = htons(headerLength);
-}
-
-void RtpExtensionHeader::clearBody() { std::memset(getBody(), 0, getSize()); }
-
-void RtpExtensionHeader::writeOneByteHeader(size_t offset, uint8_t id, const byte *value,
-                                            size_t size) {
-	if ((id == 0) || (id > 14) || (size == 0) || (size > 16) || ((offset + 1 + size) > getSize()))
-		return;
-	auto buf = getBody() + offset;
-	buf[0] = id << 4;
-	if (size != 1) {
-		buf[0] |= (uint8_t(size) - 1);
-	}
-	std::memcpy(buf + 1, value, size);
-}
-
-void RtpExtensionHeader::writeCurrentVideoOrientation(size_t offset, const uint8_t id,
-                                                      uint8_t value) {
-	auto v = std::byte{value};
-	writeOneByteHeader(offset, id, &v, 1);
-}
-
-SSRC RtcpReportBlock::getSSRC() const { return ntohl(_ssrc); }
-
-void RtcpReportBlock::preparePacket(SSRC in_ssrc, [[maybe_unused]] unsigned int packetsLost,
-                                    [[maybe_unused]] unsigned int totalPackets,
-                                    uint16_t highestSeqNo, uint16_t seqNoCycles, uint32_t jitter,
-                                    uint64_t lastSR_NTP, uint64_t lastSR_DELAY) {
-	setSeqNo(highestSeqNo, seqNoCycles);
-	setJitter(jitter);
-	setSSRC(in_ssrc);
-
-	// Middle 32 bits of NTP Timestamp
-	// _lastReport = lastSR_NTP >> 16u;
-	setNTPOfSR(uint64_t(lastSR_NTP));
-	setDelaySinceSR(uint32_t(lastSR_DELAY));
-
-	// The delay, expressed in units of 1/65536 seconds
-	// _delaySinceLastReport = lastSR_DELAY;
-}
-
-void RtcpReportBlock::setSSRC(SSRC in_ssrc) { _ssrc = htonl(in_ssrc); }
-
-void RtcpReportBlock::setPacketsLost([[maybe_unused]] unsigned int packetsLost,
-                                     [[maybe_unused]] unsigned int totalPackets) {
-	// TODO Implement loss percentages.
-	_fractionLostAndPacketsLost = 0;
-}
-
-unsigned int RtcpReportBlock::getLossPercentage() const {
-	// TODO Implement loss percentages.
-	return 0;
-}
-
-unsigned int RtcpReportBlock::getPacketLostCount() const {
-	// TODO Implement total packets lost.
-	return 0;
-}
-
-uint16_t RtcpReportBlock::seqNoCycles() const { return ntohs(_seqNoCycles); }
-
-uint16_t RtcpReportBlock::highestSeqNo() const { return ntohs(_highestSeqNo); }
-
-uint32_t RtcpReportBlock::jitter() const { return ntohl(_jitter); }
-
-uint32_t RtcpReportBlock::delaySinceSR() const { return ntohl(_delaySinceLastReport); }
-
-void RtcpReportBlock::setSeqNo(uint16_t highestSeqNo, uint16_t seqNoCycles) {
-	_highestSeqNo = htons(highestSeqNo);
-	_seqNoCycles = htons(seqNoCycles);
-}
-
-void RtcpReportBlock::setJitter(uint32_t jitter) { _jitter = htonl(jitter); }
-
-void RtcpReportBlock::setNTPOfSR(uint64_t ntp) { _lastReport = htonll(ntp >> 16u); }
-
-uint32_t RtcpReportBlock::getNTPOfSR() const { return ntohl(_lastReport) << 16u; }
-
-void RtcpReportBlock::setDelaySinceSR(uint32_t sr) {
-	// The delay, expressed in units of 1/65536 seconds
-	_delaySinceLastReport = htonl(sr);
-}
-
-void RtcpReportBlock::log() const {
-	PLOG_VERBOSE << "RTCP report block: "
-	             << "ssrc="
-	             << ntohl(_ssrc)
-	             // TODO: Implement these reports
-	             //	<< ", fractionLost=" << fractionLost
-	             //	<< ", packetsLost=" << packetsLost
-	             << ", highestSeqNo=" << highestSeqNo() << ", seqNoCycles=" << seqNoCycles()
-	             << ", jitter=" << jitter() << ", lastSR=" << getNTPOfSR()
-	             << ", lastSRDelay=" << delaySinceSR();
-}
-
-uint8_t RtcpHeader::version() const { return _first >> 6; }
-
-bool RtcpHeader::padding() const { return (_first >> 5) & 0x01; }
-
-uint8_t RtcpHeader::reportCount() const { return _first & 0x1F; }
-
-uint8_t RtcpHeader::payloadType() const { return _payloadType; }
-
-uint16_t RtcpHeader::length() const { return ntohs(_length); }
-
-size_t RtcpHeader::lengthInBytes() const { return (1 + length()) * 4; }
-
-void RtcpHeader::setPayloadType(uint8_t type) { _payloadType = type; }
-
-void RtcpHeader::setReportCount(uint8_t count) {
-	_first = (_first & 0b11100000u) | (count & 0b00011111u);
-}
-
-void RtcpHeader::setLength(uint16_t length) { _length = htons(length); }
-
-void RtcpHeader::prepareHeader(uint8_t payloadType, uint8_t reportCount, uint16_t length) {
-	_first = 0b10000000; // version 2, no padding
-	setReportCount(reportCount);
-	setPayloadType(payloadType);
-	setLength(length);
-}
-
-void RtcpHeader::log() const {
-	PLOG_VERBOSE << "RTCP header: "
-	             << "version=" << unsigned(version()) << ", padding=" << padding()
-	             << ", reportCount=" << unsigned(reportCount())
-	             << ", payloadType=" << unsigned(payloadType()) << ", length=" << length();
-}
-
-SSRC RtcpFbHeader::packetSenderSSRC() const { return ntohl(_packetSender); }
-
-SSRC RtcpFbHeader::mediaSourceSSRC() const { return ntohl(_mediaSource); }
-
-void RtcpFbHeader::setPacketSenderSSRC(SSRC ssrc) { _packetSender = htonl(ssrc); }
-
-void RtcpFbHeader::setMediaSourceSSRC(SSRC ssrc) { _mediaSource = htonl(ssrc); }
-
-void RtcpFbHeader::log() const {
-	header.log();
-	PLOG_VERBOSE << "FB: "
-	             << " packet sender: " << packetSenderSSRC()
-	             << " media source: " << mediaSourceSSRC();
-}
-
-unsigned int RtcpSr::Size(unsigned int reportCount) {
-	return sizeof(RtcpHeader) + 24 + reportCount * sizeof(RtcpReportBlock);
-}
-
-void RtcpSr::preparePacket(SSRC senderSSRC, uint8_t reportCount) {
-	unsigned int length = ((sizeof(header) + 24 + reportCount * sizeof(RtcpReportBlock)) / 4) - 1;
-	header.prepareHeader(200, reportCount, uint16_t(length));
-	this->_senderSSRC = htonl(senderSSRC);
-}
-
-const RtcpReportBlock *RtcpSr::getReportBlock(int num) const { return &_reportBlocks + num; }
-
-RtcpReportBlock *RtcpSr::getReportBlock(int num) { return &_reportBlocks + num; }
-
-size_t RtcpSr::getSize() const {
-	// "length" in packet is one less than the number of 32 bit words in the packet.
-	return sizeof(uint32_t) * (1 + size_t(header.length()));
-}
-
-uint64_t RtcpSr::ntpTimestamp() const { return ntohll(_ntpTimestamp); }
-uint32_t RtcpSr::rtpTimestamp() const { return ntohl(_rtpTimestamp); }
-uint32_t RtcpSr::packetCount() const { return ntohl(_packetCount); }
-uint32_t RtcpSr::octetCount() const { return ntohl(_octetCount); }
-uint32_t RtcpSr::senderSSRC() const { return ntohl(_senderSSRC); }
-
-void RtcpSr::setNtpTimestamp(uint64_t ts) { _ntpTimestamp = htonll(ts); }
-void RtcpSr::setRtpTimestamp(uint32_t ts) { _rtpTimestamp = htonl(ts); }
-void RtcpSr::setOctetCount(uint32_t ts) { _octetCount = htonl(ts); }
-void RtcpSr::setPacketCount(uint32_t ts) { _packetCount = htonl(ts); }
-
-void RtcpSr::log() const {
-	header.log();
-	PLOG_VERBOSE << "RTCP SR: "
-	             << " SSRC=" << senderSSRC() << ", NTP_TS=" << ntpTimestamp()
-	             << ", RtpTS=" << rtpTimestamp() << ", packetCount=" << packetCount()
-	             << ", octetCount=" << octetCount();
-
-	for (unsigned i = 0; i < unsigned(header.reportCount()); i++) {
-		getReportBlock(i)->log();
-	}
-}
-
-unsigned int RtcpSdesItem::Size(uint8_t textLength) { return textLength + 2; }
-
-std::string RtcpSdesItem::text() const { return std::string(_text, _length); }
-
-void RtcpSdesItem::setText(std::string text) {
-	if (text.size() > 0xFF)
-		throw std::invalid_argument("text is too long");
-
-	_length = uint8_t(text.size());
-	memcpy(_text, text.data(), text.size());
-}
-
-uint8_t RtcpSdesItem::length() const { return _length; }
-
-unsigned int RtcpSdesChunk::Size(const std::vector<uint8_t> textLengths) {
-	unsigned int itemsSize = 0;
-	for (auto length : textLengths) {
-		itemsSize += RtcpSdesItem::Size(length);
-	}
-	auto nullTerminatedItemsSize = itemsSize + 1;
-	auto words = uint8_t(std::ceil(double(nullTerminatedItemsSize) / 4)) + 1;
-	return words * 4;
-}
-
-SSRC RtcpSdesChunk::ssrc() const { return ntohl(_ssrc); }
-
-void RtcpSdesChunk::setSSRC(SSRC ssrc) { _ssrc = htonl(ssrc); }
-
-const RtcpSdesItem *RtcpSdesChunk::getItem(int num) const {
-	auto base = &_items;
-	while (num-- > 0) {
-		auto itemSize = RtcpSdesItem::Size(base->length());
-		base = reinterpret_cast<const RtcpSdesItem *>(reinterpret_cast<const uint8_t *>(base) +
-		                                              itemSize);
-	}
-	return reinterpret_cast<const RtcpSdesItem *>(base);
-}
-
-RtcpSdesItem *RtcpSdesChunk::getItem(int num) {
-	auto base = &_items;
-	while (num-- > 0) {
-		auto itemSize = RtcpSdesItem::Size(base->length());
-		base = reinterpret_cast<RtcpSdesItem *>(reinterpret_cast<uint8_t *>(base) + itemSize);
-	}
-	return reinterpret_cast<RtcpSdesItem *>(base);
-}
-
-unsigned int RtcpSdesChunk::getSize() const {
-	std::vector<uint8_t> textLengths{};
-	unsigned int i = 0;
-	auto item = getItem(i);
-	while (item->type != 0) {
-		textLengths.push_back(item->length());
-		item = getItem(++i);
-	}
-	return Size(textLengths);
-}
-
-long RtcpSdesChunk::safelyCountChunkSize(size_t maxChunkSize) const {
-	if (maxChunkSize < RtcpSdesChunk::Size({})) {
-		// chunk is truncated
-		return -1;
-	}
-
-	size_t size = sizeof(SSRC);
-	unsigned int i = 0;
-	// We can always access first 4 bytes of first item (in case of no items there will be 4
-	// null bytes)
-	auto item = getItem(i);
-	std::vector<uint8_t> textsLength{};
-	while (item->type != 0) {
-		if (size + RtcpSdesItem::Size(0) > maxChunkSize) {
-			// item is too short
-			return -1;
-		}
-		auto itemLength = item->length();
-		if (size + RtcpSdesItem::Size(itemLength) >= maxChunkSize) {
-			// item is too large (it can't be equal to chunk size because after item there
-			// must be 1-4 null bytes as padding)
-			return -1;
-		}
-		textsLength.push_back(itemLength);
-		// safely to access next item
-		item = getItem(++i);
-	}
-	auto realSize = RtcpSdesChunk::Size(textsLength);
-	if (realSize > maxChunkSize) {
-		// Chunk is too large
-		return -1;
-	}
-	return realSize;
-}
-
-unsigned int RtcpSdes::Size(const std::vector<std::vector<uint8_t>> lengths) {
-	unsigned int chunks_size = 0;
-	for (auto length : lengths)
-		chunks_size += RtcpSdesChunk::Size(length);
-
-	return 4 + chunks_size;
-}
-
-bool RtcpSdes::isValid() const {
-	auto chunksSize = header.lengthInBytes() - sizeof(header);
-	if (chunksSize == 0) {
-		return true;
-	}
-	// there is at least one chunk
-	unsigned int i = 0;
-	unsigned int size = 0;
-	while (size < chunksSize) {
-		if (chunksSize < size + RtcpSdesChunk::Size({})) {
-			// chunk is truncated
-			return false;
-		}
-		auto chunk = getChunk(i++);
-		auto chunkSize = chunk->safelyCountChunkSize(chunksSize - size);
-		if (chunkSize < 0) {
-			// chunk is invalid
-			return false;
-		}
-		size += chunkSize;
-	}
-	return size == chunksSize;
-}
-
-unsigned int RtcpSdes::chunksCount() const {
-	if (!isValid()) {
-		return 0;
-	}
-	uint16_t chunksSize = 4 * (header.length() + 1) - sizeof(header);
-	unsigned int size = 0;
-	unsigned int i = 0;
-	while (size < chunksSize) {
-		size += getChunk(i++)->getSize();
-	}
-	return i;
-}
-
-const RtcpSdesChunk *RtcpSdes::getChunk(int num) const {
-	auto base = &_chunks;
-	while (num-- > 0) {
-		auto chunkSize = base->getSize();
-		base = reinterpret_cast<const RtcpSdesChunk *>(reinterpret_cast<const uint8_t *>(base) +
-		                                               chunkSize);
-	}
-	return reinterpret_cast<const RtcpSdesChunk *>(base);
-}
-
-RtcpSdesChunk *RtcpSdes::getChunk(int num) {
-	auto base = &_chunks;
-	while (num-- > 0) {
-		auto chunkSize = base->getSize();
-		base = reinterpret_cast<RtcpSdesChunk *>(reinterpret_cast<uint8_t *>(base) + chunkSize);
-	}
-	return reinterpret_cast<RtcpSdesChunk *>(base);
-}
-
-void RtcpSdes::preparePacket(uint8_t chunkCount) {
-	unsigned int chunkSize = 0;
-	for (uint8_t i = 0; i < chunkCount; i++) {
-		auto chunk = getChunk(i);
-		chunkSize += chunk->getSize();
-	}
-	uint16_t length = uint16_t((sizeof(header) + chunkSize) / 4 - 1);
-	header.prepareHeader(202, chunkCount, length);
-}
-
-const RtcpReportBlock *RtcpRr::getReportBlock(int num) const { return &_reportBlocks + num; }
-
-RtcpReportBlock *RtcpRr::getReportBlock(int num) { return &_reportBlocks + num; }
-
-size_t RtcpRr::SizeWithReportBlocks(uint8_t reportCount) {
-	return sizeof(header) + 4 + size_t(reportCount) * sizeof(RtcpReportBlock);
-}
-
-SSRC RtcpRr::senderSSRC() const { return ntohl(_senderSSRC); }
-
-bool RtcpRr::isSenderReport() { return header.payloadType() == 200; }
-
-bool RtcpRr::isReceiverReport() { return header.payloadType() == 201; }
-
-size_t RtcpRr::getSize() const {
-	// "length" in packet is one less than the number of 32 bit words in the packet.
-	return sizeof(uint32_t) * (1 + size_t(header.length()));
-}
-
-void RtcpRr::preparePacket(SSRC senderSSRC, uint8_t reportCount) {
-	// "length" in packet is one less than the number of 32 bit words in the packet.
-	size_t length = (SizeWithReportBlocks(reportCount) / 4) - 1;
-	header.prepareHeader(201, reportCount, uint16_t(length));
-	this->_senderSSRC = htonl(senderSSRC);
-}
-
-void RtcpRr::setSenderSSRC(SSRC ssrc) { this->_senderSSRC = htonl(ssrc); }
-
-void RtcpRr::log() const {
-	header.log();
-	PLOG_VERBOSE << "RTCP RR: "
-	             << " SSRC=" << ntohl(_senderSSRC);
-
-	for (unsigned i = 0; i < unsigned(header.reportCount()); i++) {
-		getReportBlock(i)->log();
-	}
-}
-
-size_t RtcpRemb::SizeWithSSRCs(int count) { return sizeof(RtcpRemb) + (count - 1) * sizeof(SSRC); }
-
-unsigned int RtcpRemb::getSize() const {
-	// "length" in packet is one less than the number of 32 bit words in the packet.
-	return sizeof(uint32_t) * (1 + header.header.length());
-}
-
-void RtcpRemb::preparePacket(SSRC senderSSRC, unsigned int numSSRC, unsigned int in_bitrate) {
-
-	// Report Count becomes the format here.
-	header.header.prepareHeader(206, 15, 0);
-
-	// Always zero.
-	header.setMediaSourceSSRC(0);
-
-	header.setPacketSenderSSRC(senderSSRC);
-
-	_id[0] = 'R';
-	_id[1] = 'E';
-	_id[2] = 'M';
-	_id[3] = 'B';
-
-	setBitrate(numSSRC, in_bitrate);
-}
-
-void RtcpRemb::setBitrate(unsigned int numSSRC, unsigned int in_bitrate) {
-	unsigned int exp = 0;
-	while (in_bitrate > pow(2, 18) - 1) {
-		exp++;
-		in_bitrate /= 2;
-	}
-
-	// "length" in packet is one less than the number of 32 bit words in the packet.
-	header.header.setLength(uint16_t((offsetof(RtcpRemb, _ssrc) / sizeof(uint32_t)) - 1 + numSSRC));
-
-	_bitrate = htonl((numSSRC << (32u - 8u)) | (exp << (32u - 8u - 6u)) | in_bitrate);
-}
-
-void RtcpRemb::setSsrc(int iterator, SSRC newSssrc) { _ssrc[iterator] = htonl(newSssrc); }
-
-unsigned int RtcpPli::Size() { return sizeof(RtcpFbHeader); }
-
-void RtcpPli::preparePacket(SSRC messageSSRC) {
-	header.header.prepareHeader(206, 1, 2);
-	header.setPacketSenderSSRC(messageSSRC);
-	header.setMediaSourceSSRC(messageSSRC);
-}
-
-void RtcpPli::log() const { header.log(); }
-
-unsigned int RtcpFir::Size() { return sizeof(RtcpFbHeader) + sizeof(RtcpFirPart); }
-
-void RtcpFir::preparePacket(SSRC messageSSRC, uint8_t seqNo) {
-	header.header.prepareHeader(206, 4, 2 + 2 * 1);
-	header.setPacketSenderSSRC(messageSSRC);
-	header.setMediaSourceSSRC(messageSSRC);
-	parts[0].ssrc = htonl(messageSSRC);
-	parts[0].seqNo = seqNo;
-}
-
-void RtcpFir::log() const { header.log(); }
-
-uint16_t RtcpNackPart::pid() { return ntohs(_pid); }
-uint16_t RtcpNackPart::blp() { return ntohs(_blp); }
-
-void RtcpNackPart::setPid(uint16_t pid) { _pid = htons(pid); }
-void RtcpNackPart::setBlp(uint16_t blp) { _blp = htons(blp); }
-
-std::vector<uint16_t> RtcpNackPart::getSequenceNumbers() {
-	std::vector<uint16_t> result{};
-	result.reserve(17);
-	uint16_t p = pid();
-	result.push_back(p);
-	uint16_t bitmask = blp();
-	uint16_t i = p + 1;
-	while (bitmask > 0) {
-		if (bitmask & 0x1) {
-			result.push_back(i);
-		}
-		i += 1;
-		bitmask >>= 1;
-	}
-	return result;
-}
-
-unsigned int RtcpNack::Size(unsigned int discreteSeqNoCount) {
-	return offsetof(RtcpNack, parts) + sizeof(RtcpNackPart) * discreteSeqNoCount;
-}
-
-unsigned int RtcpNack::getSeqNoCount() { return header.header.length() - 2; }
-
-void RtcpNack::preparePacket(SSRC ssrc, unsigned int discreteSeqNoCount) {
-	header.header.prepareHeader(205, 1, 2 + uint16_t(discreteSeqNoCount));
-	header.setMediaSourceSSRC(ssrc);
-	header.setPacketSenderSSRC(ssrc);
-}
-
-bool RtcpNack::addMissingPacket(unsigned int *fciCount, uint16_t *fciPID, uint16_t missingPacket) {
-	if (*fciCount == 0 || missingPacket < *fciPID || missingPacket > (*fciPID + 16)) {
-		parts[*fciCount].setPid(missingPacket);
-		parts[*fciCount].setBlp(0);
-		*fciPID = missingPacket;
-		(*fciCount)++;
-		return true;
-	} else {
-		// TODO SPEED!
-		uint16_t blp = parts[(*fciCount) - 1].blp();
-		uint16_t newBit = uint16_t(1u << (missingPacket - (1 + *fciPID)));
-		parts[(*fciCount) - 1].setBlp(blp | newBit);
-		return false;
-	}
-}
-
-uint16_t RtpRtx::getOriginalSeqNo() const { return ntohs(*(uint16_t *)(header.getBody())); }
-
-const char *RtpRtx::getBody() const { return header.getBody() + sizeof(uint16_t); }
-
-char *RtpRtx::getBody() { return header.getBody() + sizeof(uint16_t); }
-
-size_t RtpRtx::getBodySize(size_t totalSize) const {
-	return totalSize - (getBody() - reinterpret_cast<const char *>(this));
-}
-
-size_t RtpRtx::getSize() const { return header.getSize() + sizeof(uint16_t); }
-
-size_t RtpRtx::normalizePacket(size_t totalSize, SSRC originalSSRC, uint8_t originalPayloadType) {
-	header.setSeqNumber(getOriginalSeqNo());
-	header.setSsrc(originalSSRC);
-	header.setPayloadType(originalPayloadType);
-	// TODO, the -12 is the size of the header (which is variable!)
-	memmove(header.getBody(), getBody(), totalSize - getSize());
-	return totalSize - 2;
-}
-
-size_t RtpRtx::copyTo(RtpHeader *dest, size_t totalSize, uint8_t originalPayloadType) {
-	memmove((char *)dest, (char *)this, header.getSize());
-	dest->setSeqNumber(getOriginalSeqNo());
-	dest->setPayloadType(originalPayloadType);
-	memmove(dest->getBody(), getBody(), getBodySize(totalSize));
-	return totalSize;
-}
-
-}; // namespace rtc
diff --git a/thirdparty/libdatachannel/src/track.cpp b/thirdparty/libdatachannel/src/track.cpp
deleted file mode 100644
index 29ab6d24cf..0000000000
--- a/thirdparty/libdatachannel/src/track.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Copyright (c) 2020-2021 Paul-Louis Ageneau
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#include "track.hpp"
-
-#include "impl/internals.hpp"
-#include "impl/track.hpp"
-
-namespace rtc {
-
-Track::Track(impl_ptr<impl::Track> impl)
-    : CheshireCat<impl::Track>(impl), Channel(std::dynamic_pointer_cast<impl::Channel>(impl)) {}
-
-Track::~Track() {}
-
-string Track::mid() const { return impl()->mid(); }
-
-Description::Direction Track::direction() const { return impl()->direction(); }
-
-Description::Media Track::description() const { return impl()->description(); }
-
-void Track::setDescription(Description::Media description) {
-	impl()->setDescription(std::move(description));
-}
-
-void Track::close() { impl()->close(); }
-
-bool Track::send(message_variant data) { return impl()->outgoing(make_message(std::move(data))); }
-
-bool Track::send(const byte *data, size_t size) { return send(binary(data, data + size)); }
-
-bool Track::isOpen(void) const { return impl()->isOpen(); }
-
-bool Track::isClosed(void) const { return impl()->isClosed(); }
-
-size_t Track::maxMessageSize() const { return impl()->maxMessageSize(); }
-
-void Track::setMediaHandler(shared_ptr<MediaHandler> handler) {
-	impl()->setMediaHandler(std::move(handler));
-}
-
-bool Track::requestKeyframe() {
-	// only push PLI for video
-	if (description().type() == "video") {
-		if (auto handler = impl()->getMediaHandler()) {
-			return handler->requestKeyframe();
-		}
-	}
-	return false;
-}
-
-shared_ptr<MediaHandler> Track::getMediaHandler() { return impl()->getMediaHandler(); }
-
-} // namespace rtc
diff --git a/thirdparty/libdatachannel/src/websocket.cpp b/thirdparty/libdatachannel/src/websocket.cpp
deleted file mode 100644
index 32458ec64a..0000000000
--- a/thirdparty/libdatachannel/src/websocket.cpp
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- * Copyright (c) 2020-2021 Paul-Louis Ageneau
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_WEBSOCKET
-
-#include "websocket.hpp"
-#include "common.hpp"
-
-#include "impl/internals.hpp"
-#include "impl/websocket.hpp"
-
-namespace rtc {
-
-WebSocket::WebSocket() : WebSocket(Configuration()) {}
-
-WebSocket::WebSocket(Configuration config)
-    : CheshireCat<impl::WebSocket>(std::move(config)),
-      Channel(std::dynamic_pointer_cast<impl::Channel>(CheshireCat<impl::WebSocket>::impl())) {}
-
-WebSocket::WebSocket(impl_ptr<impl::WebSocket> impl)
-    : CheshireCat<impl::WebSocket>(std::move(impl)),
-      Channel(std::dynamic_pointer_cast<impl::Channel>(CheshireCat<impl::WebSocket>::impl())) {}
-
-WebSocket::~WebSocket() {
-	try {
-		impl()->remoteClose();
-		impl()->resetCallbacks(); // not done by impl::WebSocket
-	} catch (const std::exception &e) {
-		PLOG_ERROR << e.what();
-	}
-}
-
-WebSocket::State WebSocket::readyState() const { return impl()->state; }
-
-bool WebSocket::isOpen() const { return impl()->state.load() == State::Open; }
-
-bool WebSocket::isClosed() const { return impl()->state.load() == State::Closed; }
-
-size_t WebSocket::maxMessageSize() const { return DEFAULT_MAX_MESSAGE_SIZE; }
-
-void WebSocket::open(const string &url) { impl()->open(url); }
-
-void WebSocket::close() { impl()->close(); }
-
-void WebSocket::forceClose() { impl()->remoteClose(); }
-
-bool WebSocket::send(message_variant data) {
-	return impl()->outgoing(make_message(std::move(data)));
-}
-
-bool WebSocket::send(const byte *data, size_t size) {
-	return impl()->outgoing(make_message(data, data + size, Message::Binary));
-}
-
-optional<string> WebSocket::remoteAddress() const {
-	auto tcpTransport = impl()->getTcpTransport();
-	return tcpTransport ? make_optional(tcpTransport->remoteAddress()) : nullopt;
-}
-
-optional<string> WebSocket::path() const {
-	auto state = impl()->state.load();
-	auto handshake = impl()->getWsHandshake();
-	return state != State::Connecting && handshake ? make_optional(handshake->path()) : nullopt;
-}
-
-} // namespace rtc
-
-#endif
diff --git a/thirdparty/libdatachannel/src/websocketserver.cpp b/thirdparty/libdatachannel/src/websocketserver.cpp
deleted file mode 100644
index 5e1f6340f5..0000000000
--- a/thirdparty/libdatachannel/src/websocketserver.cpp
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- * Copyright (c) 2021 Paul-Louis Ageneau
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at https://mozilla.org/MPL/2.0/.
- */
-
-#if RTC_ENABLE_WEBSOCKET
-
-#include "websocketserver.hpp"
-#include "common.hpp"
-
-#include "impl/internals.hpp"
-#include "impl/websocketserver.hpp"
-
-namespace rtc {
-
-WebSocketServer::WebSocketServer() : WebSocketServer(Configuration()) {}
-
-WebSocketServer::WebSocketServer(Configuration config)
-    : CheshireCat<impl::WebSocketServer>(std::move(config)) {}
-
-WebSocketServer::~WebSocketServer() { impl()->stop(); }
-
-void WebSocketServer::stop() { impl()->stop(); }
-
-uint16_t WebSocketServer::port() const { return impl()->tcpServer->port(); }
-
-void WebSocketServer::onClient(std::function<void(shared_ptr<WebSocket>)> callback) {
-	impl()->clientCallback = callback;
-}
-
-} // namespace rtc
-
-#endif
